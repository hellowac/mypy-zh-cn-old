{"config":{"lang":["en"],"separator":"[\\s\\u200b\\u3000\\-\u3001\u3002\uff0c\uff0e\uff1f\uff01\uff1b]+","pipeline":["stemmer"]},"docs":[{"location":"","title":"\u6b22\u8fce\u6765\u5230mypy\u6587\u6863!","text":"<p>Welcome to mypy documentation!</p> <p>\u539f\u6587: https://mypy.readthedocs.io/en/stable/</p> \u4e2d\u6587\u82f1\u6587 <p>Mypy \u662f\u4e00\u4e2a\u7528\u4e8e Python \u7684\u9759\u6001\u7c7b\u578b\u68c0\u67e5\u5668\u3002</p> <p>\u7c7b\u578b\u68c0\u67e5\u5668\u5e2e\u52a9\u786e\u4fdd\u4f60\u5728\u4ee3\u7801\u4e2d\u6b63\u786e\u5730\u4f7f\u7528\u53d8\u91cf\u548c\u51fd\u6570\u3002\u901a\u8fc7 mypy\uff0c\u4f60\u53ef\u4ee5\u5728 Python \u7a0b\u5e8f\u4e2d\u6dfb\u52a0\u7c7b\u578b\u63d0\u793a\uff08PEP 484\uff09\uff0c\u7136\u540e mypy \u4f1a\u5728\u4f60\u9519\u8bef\u4f7f\u7528\u8fd9\u4e9b\u7c7b\u578b\u65f6\u53d1\u51fa\u8b66\u544a\u3002</p> <p>Python \u662f\u4e00\u79cd\u52a8\u6001\u8bed\u8a00\uff0c\u56e0\u6b64\u901a\u5e38\u4f60\u53ea\u6709\u5728\u5c1d\u8bd5\u8fd0\u884c\u4ee3\u7801\u65f6\u624d\u80fd\u770b\u5230\u9519\u8bef\u3002\u800c mypy \u4f5c\u4e3a\u4e00\u4e2a\u9759\u6001\u68c0\u67e5\u5668\uff0c\u5b83\u53ef\u4ee5\u5728\u4e0d\u8fd0\u884c\u7a0b\u5e8f\u7684\u60c5\u51b5\u4e0b\u53d1\u73b0\u4ee3\u7801\u4e2d\u7684\u9519\u8bef\uff01</p> <p>\u4e0b\u9762\u662f\u4e00\u4e2a\u5c0f\u4f8b\u5b50\u6765\u5f15\u8d77\u4f60\u7684\u5174\u8da3\uff1a</p> <pre><code>number = input(\"What is your favourite number?\")\nprint(\"It is\", number + 1)  # error: Unsupported operand types for + (\"str\" and \"int\")\n</code></pre> <p>\u4e3a mypy \u6dfb\u52a0\u7c7b\u578b\u63d0\u793a\u4e0d\u4f1a\u5e72\u6270\u7a0b\u5e8f\u7684\u6b63\u5e38\u8fd0\u884c\u3002\u53ef\u4ee5\u628a\u7c7b\u578b\u63d0\u793a\u5f53\u4f5c\u7c7b\u4f3c\u6ce8\u91ca\u7684\u5b58\u5728\uff01\u5373\u4f7f mypy \u62a5\u544a\u9519\u8bef\uff0c\u4f60\u4ecd\u7136\u53ef\u4ee5\u4f7f\u7528 Python \u89e3\u91ca\u5668\u8fd0\u884c\u4ee3\u7801\u3002</p> <p>Mypy \u662f\u4e3a\u6e10\u8fdb\u7c7b\u578b\u8bbe\u8ba1\u7684\uff0c\u8fd9\u610f\u5473\u7740\u4f60\u53ef\u4ee5\u9010\u6b65\u5411\u4ee3\u7801\u5e93\u4e2d\u6dfb\u52a0\u7c7b\u578b\u63d0\u793a\uff0c\u5e76\u4e14\u5728\u9759\u6001\u7c7b\u578b\u68c0\u67e5\u4e0d\u65b9\u4fbf\u65f6\uff0c\u53ef\u4ee5\u968f\u65f6\u56de\u9000\u5230\u52a8\u6001\u7c7b\u578b\u3002</p> <p>Mypy \u5177\u6709\u529f\u80fd\u5f3a\u5927\u4e14\u6613\u4e8e\u4f7f\u7528\u7684\u7c7b\u578b\u7cfb\u7edf\uff0c\u652f\u6301\u7c7b\u578b\u63a8\u65ad\u3001\u6cdb\u578b\u3001\u53ef\u8c03\u7528\u7c7b\u578b\u3001\u5143\u7ec4\u7c7b\u578b\u3001\u8054\u5408\u7c7b\u578b\u3001\u7ed3\u6784\u6027\u5b50\u7c7b\u578b\u7b49\u529f\u80fd\u3002\u4f7f\u7528 mypy \u4f1a\u4f7f\u4f60\u7684\u7a0b\u5e8f\u66f4\u6613\u4e8e\u7406\u89e3\u3001\u8c03\u8bd5\u548c\u7ef4\u62a4\u3002</p> <p>\u6ce8\u610f</p> <p>\u5c3d\u7ba1 mypy \u5df2\u7ecf\u51c6\u5907\u597d\u7528\u4e8e\u751f\u4ea7\u73af\u5883\uff0c\u4f46\u5076\u5c14\u53ef\u80fd\u4f1a\u6709\u7834\u574f\u5411\u540e\u517c\u5bb9\u6027\u7684\u66f4\u6539\u3002Mypy \u5f00\u53d1\u56e2\u961f\u4f1a\u5c3d\u91cf\u51cf\u5c11\u5bf9\u7528\u6237\u4ee3\u7801\u7684\u5f71\u54cd\u3002\u5982\u679c\u53d1\u751f\u91cd\u5927\u7834\u574f\u6027\u66f4\u6539\uff0cmypy \u7684\u4e3b\u7248\u672c\u53f7\u5c06\u4f1a\u63d0\u9ad8\u3002</p> <p>Mypy is a static type checker for Python.</p> <p>Type checkers help ensure that you\u2019re using variables and functions in your code correctly. With mypy, add type hints (PEP 484) to your Python programs, and mypy will warn you when you use those types incorrectly.</p> <p>Python is a dynamic language, so usually you\u2019ll only see errors in your code when you attempt to run it. Mypy is a static checker, so it finds bugs in your programs without even running them!</p> <p>Here is a small example to whet your appetite:</p> <pre><code>number = input(\"What is your favourite number?\")\nprint(\"It is\", number + 1)  # error: Unsupported operand types for + (\"str\" and \"int\")\n</code></pre> <p>Adding type hints for mypy does not interfere with the way your program would otherwise run. Think of type hints as similar to comments! You can always use the Python interpreter to run your code, even if mypy reports errors.</p> <p>Mypy is designed with gradual typing in mind. This means you can add type hints to your code base slowly and that you can always fall back to dynamic typing when static typing is not convenient.</p> <p>Mypy has a powerful and easy-to-use type system, supporting features such as type inference, generics, callable types, tuple types, union types, structural subtyping and more. Using mypy will make your programs easier to understand, debug, and maintain.</p> <p>Note</p> <p>Although mypy is production ready, there may be occasional changes that break backward compatibility. The mypy development team tries to minimize the impact of changes to user code. In case of a major breaking change, mypy\u2019s major version will be bumped.</p>"},{"location":"about/","title":"\u5173\u4e8e","text":""},{"location":"about/#mkdocs","title":"mkdocs","text":"<p>MkDocs\u662f\u4e00\u79cd\u7b80\u5355\u6613\u7528\u7684\u9759\u6001\u7f51\u7ad9\u751f\u6210\u5de5\u5177\uff0c\u5141\u8bb8\u5f00\u53d1\u8005\u4f7f\u7528Markdown\u6587\u6863\u7f16\u5199\u7f51\u7ad9\uff0c\u5e76\u652f\u6301\u81ea\u5b9a\u4e49\u4e3b\u9898\u548c\u63d2\u4ef6\u3002\u57fa\u4e8ePython\u8bed\u8a00\u5f00\u53d1\uff0cMkDocs\u53ef\u4ee5\u5e2e\u52a9\u7528\u6237\u5feb\u901f\u521b\u5efa\u7f8e\u89c2\u3001\u6613\u8bfb\u7684\u6587\u6863\u7f51\u7ad9\u3002</p>"},{"location":"about/#\u5b89\u88c5","title":"\u5b89\u88c5","text":"<p>\u5b89\u88c5MkDocs\u6700\u7b80\u5355\u7684\u65b9\u6cd5\u662f\u901a\u8fc7Python\u5305\u7ba1\u7406\u5668pip\u8fdb\u884c\u5b89\u88c5\uff1a</p> <pre><code>pip install mkdocs\n</code></pre>"},{"location":"about/#\u4f7f\u7528","title":"\u4f7f\u7528","text":"<p>\u4f7f\u7528MkDocs\u521b\u5efa\u4e00\u4e2a\u65b0\u9879\u76ee\u5f88\u5bb9\u6613\u3002\u6267\u884c\u4ee5\u4e0b\u547d\u4ee4\u5c06\u5728\u5f53\u524d\u76ee\u5f55\u4e0b\u521b\u5efa\u4e00\u4e2a\u540d\u4e3a\u201cmyproject\u201d\u7684\u65b0\u9879\u76ee\uff1a</p> <pre><code>mkdocs new myproject\n</code></pre> <p>\u8fd9\u5c06\u751f\u6210\u5982\u4e0b\u6587\u4ef6\u7ed3\u6784\uff1a</p> <pre><code>myproject/\n    \u251c\u2500\u2500 docs/\n    \u2502   \u2514\u2500\u2500 index.md\n    \u251c\u2500\u2500 mkdocs.yml\n    \u2514\u2500\u2500 README.md\n</code></pre> <p>\u5176\u4e2d\uff0c\u201cdocs\u201d\u6587\u4ef6\u5939\u5b58\u653e\u6240\u6709\u7684Markdown\u6587\u6863\uff0c\u201cmkdocs.yml\u201d\u662f\u914d\u7f6e\u6587\u4ef6\uff0c\u201cREADME.md\u201d\u662f\u9879\u76ee\u7684\u8bf4\u660e\u6587\u4ef6\u3002</p> <p>\u7f16\u8f91\u201cdocs/index.md\u201d\u6587\u4ef6\uff0c\u6dfb\u52a0\u4e00\u4e9b\u5185\u5bb9\uff1a</p> <pre><code># \u6b22\u8fce\u4f7f\u7528MkDocs\n\nMkDocs\u662f\u4e00\u4e2a\u7b80\u5355\u6613\u7528\u7684\u9759\u6001\u7f51\u7ad9\u751f\u6210\u5de5\u5177\uff0c\u901a\u8fc7Markdown\u6587\u6863\u7f16\u5199\u7f51\u7ad9\u3002\n</code></pre> <p>\u4fdd\u5b58\u6587\u4ef6\u540e\uff0c\u5728\u547d\u4ee4\u884c\u4e2d\u8fdb\u5165\u9879\u76ee\u6839\u76ee\u5f55\u5e76\u6267\u884c\u4ee5\u4e0b\u547d\u4ee4\uff1a</p> <pre><code>mkdocs serve\n</code></pre> <p>\u7136\u540e\u5728\u6d4f\u89c8\u5668\u4e2d\u6253\u5f00\u201chttp://localhost:8000\u201d\u5c31\u53ef\u4ee5\u770b\u5230\u521a\u624d\u7f16\u8f91\u7684\u9875\u9762\u4e86\u3002</p>"},{"location":"about/#\u81ea\u5b9a\u4e49\u4e3b\u9898\u548c\u63d2\u4ef6","title":"\u81ea\u5b9a\u4e49\u4e3b\u9898\u548c\u63d2\u4ef6","text":"<p>MkDocs\u652f\u6301\u81ea\u5b9a\u4e49\u4e3b\u9898\u548c\u63d2\u4ef6\u3002\u7528\u6237\u53ef\u4ee5\u901a\u8fc7\u5b89\u88c5\u7b2c\u4e09\u65b9\u4e3b\u9898\u548c\u63d2\u4ef6\u6765\u589e\u5f3aMkDocs\u7684\u529f\u80fd\u3002</p> <p>\u4f8b\u5982\uff0c\u8981\u5b89\u88c5\u201cmkdocs-material\u201d\u4e3b\u9898\uff0c\u6267\u884c\u4ee5\u4e0b\u547d\u4ee4\uff1a</p> <pre><code>pip install mkdocs-material\n</code></pre> <p>\u7136\u540e\u5728\u201cmkdocs.yml\u201d\u6587\u4ef6\u4e2d\u5c06\u4e3b\u9898\u8bbe\u7f6e\u4e3a\u201cmaterial\u201d:</p> <pre><code>theme:\n    name: material\n</code></pre> <p>\u8fd9\u6837\u5c31\u53ef\u4ee5\u4f7f\u7528\u4ee3\u7801\u9ad8\u4eae\u548c\u5176\u4ed6\u6269\u5c55\u529f\u80fd\u4e86\u3002</p>"},{"location":"about/#\u90e8\u7f72","title":"\u90e8\u7f72","text":"<p>\u8981\u5c06MkDocs\u7f51\u7ad9\u90e8\u7f72\u5230\u8fdc\u7a0b\u670d\u52a1\u5668\u4e0a\uff0c\u6700\u7b80\u5355\u7684\u65b9\u6cd5\u662f\u4f7f\u7528GitHub Pages\u6216GitLab Pages\u3002\u53ea\u9700\u8981\u5c06\u751f\u6210\u7684HTML\u6587\u4ef6\u4e0a\u4f20\u5230GitHub\u6216GitLab\u4e0a\u7684\u76f8\u5e94\u4ed3\u5e93\u4e2d\u5373\u53ef\u3002</p> <p>\u53e6\u5916\uff0c\u4e5f\u53ef\u4ee5\u4f7f\u7528Python Web\u6846\u67b6\uff08\u5982Flask\u3001Django\u7b49\uff09\u5c06MkDocs\u751f\u6210\u7684HTML\u6587\u4ef6\u4f5c\u4e3a\u9759\u6001\u6587\u4ef6\u90e8\u7f72\u5230Web\u670d\u52a1\u5668\u4e0a\u3002</p> <p>\u4ee5\u4e0a\u5c31\u662fPython MkDocs\u7684\u7b80\u4ecb\uff0c\u66f4\u591a\u8be6\u7ec6\u4fe1\u606f\u8bf7\u53c2\u8003MkDocs\u5b98\u65b9\u6587\u6863\uff1ahttps://www.mkdocs.org/</p>"},{"location":"mypy/","title":"\u5f00\u59cb","text":"<p>Getting started</p> <p>\u8f6c\u81ea: https://mypy.readthedocs.io/en/stable/getting_started.html</p> \u4e2d\u6587\u82f1\u6587 <p>\u672c\u7ae0\u4ecb\u7ecd\u4e86mypy\u7684\u4e00\u4e9b\u6838\u5fc3\u6982\u5ff5\uff0c\u5305\u62ec\u51fd\u6570\u6ce8\u89e3\u3001typing \u6a21\u5757\u3001\u5b58\u6839\u6587\u4ef6\u7b49\u3002</p> <p>\u5982\u679c\u4f60\u60f3\u8981\u4e00\u4e2a\u5feb\u901f\u7684\u4ecb\u7ecd\uff0c\u8bf7\u67e5\u770bmypy\u901f\u67e5\u8868\u3002</p> <p>\u5982\u679c\u4f60\u4e0d\u719f\u6089\u9759\u6001\u548c\u52a8\u6001\u7c7b\u578b\u68c0\u67e5\u7684\u6982\u5ff5\uff0c\u8bf7\u786e\u4fdd\u4ed4\u7ec6\u9605\u8bfb\u672c\u7ae0\uff0c\u56e0\u4e3a\u5426\u5219\u6587\u6863\u7684\u5176\u4f59\u90e8\u5206\u53ef\u80fd\u4e0d\u592a\u5bb9\u6613\u7406\u89e3\u3002</p> <p>This chapter introduces some core concepts of mypy, including function annotations, the typing module, stub files, and more.</p> <p>If you\u2019re looking for a quick intro, see the mypy cheatsheet.</p> <p>If you\u2019re unfamiliar with the concepts of static and dynamic type checking, be sure to read this chapter carefully, as the rest of the documentation may not make much sense otherwise.</p>"},{"location":"mypy/#\u5b89\u88c5\u548c\u8fd0\u884cmypy","title":"\u5b89\u88c5\u548c\u8fd0\u884cmypy","text":"<p>Installing and running mypy</p> \u4e2d\u6587\u82f1\u6587 <p>Mypy \u9700\u8981 Python 3.8 \u6216\u66f4\u9ad8\u7248\u672c\u624d\u80fd\u8fd0\u884c\u3002\u4f60\u53ef\u4ee5\u4f7f\u7528 pip \u5b89\u88c5 mypy\uff1a</p> <pre><code>$ python3 -m pip install mypy\n</code></pre> <p>\u5b89\u88c5 mypy \u540e\uff0c\u4f7f\u7528 <code>mypy</code> \u5de5\u5177\u8fd0\u884c\u5b83\uff1a</p> <pre><code>$ mypy program.py\n</code></pre> <p>\u8fd9\u4e2a\u547d\u4ee4\u4f1a\u8ba9 mypy \u5bf9\u4f60\u7684 <code>program.py</code> \u6587\u4ef6\u8fdb\u884c\u7c7b\u578b\u68c0\u67e5\uff0c\u5e76\u6253\u5370\u51fa\u5b83\u53d1\u73b0\u7684\u4efb\u4f55\u9519\u8bef\u3002Mypy \u4f1a\u5bf9\u4f60\u7684\u4ee3\u7801\u8fdb\u884c\u9759\u6001\u7c7b\u578b\u68c0\u67e5\uff1a\u8fd9\u610f\u5473\u7740\u5b83\u4f1a\u5728\u4e0d\u8fd0\u884c\u4f60\u7684\u4ee3\u7801\u7684\u60c5\u51b5\u4e0b\u68c0\u67e5\u9519\u8bef\uff0c\u5c31\u50cf\u4e00\u4e2a linter\u3002</p> <p>\u8fd9\u4e5f\u610f\u5473\u7740\uff0c\u5982\u679c\u4f60\u613f\u610f\uff0c\u4f60\u603b\u662f\u53ef\u4ee5\u5ffd\u7565 mypy \u62a5\u544a\u7684\u9519\u8bef\u3002\u5373\u4f7f mypy \u62a5\u544a\u9519\u8bef\uff0c\u4f60\u4e5f\u53ef\u4ee5\u4f7f\u7528 Python \u89e3\u91ca\u5668\u6765\u8fd0\u884c\u4f60\u7684\u4ee3\u7801\u3002</p> <p>\u7136\u800c\uff0c\u5982\u679c\u4f60\u5c1d\u8bd5\u76f4\u63a5\u5728\u73b0\u6709\u7684 Python \u4ee3\u7801\u4e0a\u8fd0\u884c mypy\uff0c\u5b83\u5f88\u53ef\u80fd\u62a5\u544a\u5f88\u5c11\u6216\u6ca1\u6709\u9519\u8bef\u3002\u8fd9\u662f\u4e00\u4e2a\u7279\u6027\uff01\u5b83\u4f7f\u5f97\u9010\u6b65\u91c7\u7528 mypy \u53d8\u5f97\u5bb9\u6613\u3002</p> <p>\u4e3a\u4e86\u4ece mypy \u83b7\u5f97\u6709\u7528\u7684\u8bca\u65ad\u4fe1\u606f\uff0c\u4f60\u5fc5\u987b\u5728\u4ee3\u7801\u4e2d\u6dfb\u52a0\u7c7b\u578b\u6ce8\u89e3\u3002\u8be6\u89c1\u4e0b\u9762\u7684\u90e8\u5206\u3002</p> <p>Mypy requires Python 3.8 or later to run. You can install mypy using pip:</p> <p><code>$ python3 -m pip install mypy</code></p> <p>Once mypy is installed, run it by using the <code>mypy</code> tool:</p> <p><code>$ mypy program.py</code></p> <p>This command makes mypy type check your <code>program.py</code> file and print out any errors it finds. Mypy will type check your code statically: this means that it will check for errors without ever running your code, just like a linter.</p> <p>This also means that you are always free to ignore the errors mypy reports, if you so wish. You can always use the Python interpreter to run your code, even if mypy reports errors.</p> <p>However, if you try directly running mypy on your existing Python code, it will most likely report little to no errors. This is a feature! It makes it easy to adopt mypy incrementally.</p> <p>In order to get useful diagnostics from mypy, you must add type annotations to your code. See the section below for details.</p>"},{"location":"mypy/#\u52a8\u6001-vs-\u9759\u6001-\u7c7b\u578b","title":"\u52a8\u6001 vs \u9759\u6001 \u7c7b\u578b","text":"<p>Dynamic vs static typing</p> \u4e2d\u6587\u82f1\u6587 <p>\u6ca1\u6709\u7c7b\u578b\u6ce8\u91ca\u7684\u51fd\u6570\u88ab mypy \u8ba4\u4e3a\u662f\u52a8\u6001\u7c7b\u578b\u7684\uff1a</p> <pre><code>def greeting(name):\n    return 'Hello ' + name\n</code></pre> <p>\u9ed8\u8ba4\u60c5\u51b5\u4e0b\uff0cmypy \u4e0d\u4f1a\u5bf9\u52a8\u6001\u7c7b\u578b\u51fd\u6570\u8fdb\u884c\u7c7b\u578b\u68c0\u67e5\u3002\u8fd9\u610f\u5473\u7740\uff0c\u9664\u4e86\u4e00\u4e9b\u4f8b\u5916\u60c5\u51b5\uff0cmypy \u4e0d\u4f1a\u62a5\u544a\u5e38\u89c4\u672a\u6ce8\u91ca Python \u4ee3\u7801\u7684\u4efb\u4f55\u9519\u8bef\u3002</p> <p>\u5373\u4f7f\u4f60\u8bef\u7528\u4e86\u51fd\u6570\uff0c\u60c5\u51b5\u4e5f\u662f\u5982\u6b64\uff01</p> <pre><code>def greeting(name):\n    return 'Hello ' + name\n\n# \u5f53\u7a0b\u5e8f\u8fd0\u884c\u65f6\uff0c\u8fd9\u4e9b\u8c03\u7528\u5c06\u5931\u8d25\uff0c\u4f46 mypy \u4e0d\u62a5\u544a\u9519\u8bef\n# \u56e0\u4e3a \"greeting\" \u6ca1\u6709\u7c7b\u578b\u6ce8\u91ca\u3002\ngreeting(123)\ngreeting(b\"Alice\")\n</code></pre> <p>\u6211\u4eec\u53ef\u4ee5\u901a\u8fc7\u6dfb\u52a0\u7c7b\u578b\u6ce8\u91ca\uff08\u4e5f\u79f0\u4e3a\u7c7b\u578b\u63d0\u793a\uff09\u6765\u8ba9 mypy \u68c0\u6d4b\u8fd9\u7c7b\u9519\u8bef\u3002\u4f8b\u5982\uff0c\u4f60\u53ef\u4ee5\u544a\u8bc9 mypy <code>greeting</code> \u51fd\u6570\u65e2\u63a5\u53d7\u53c8\u8fd4\u56de\u4e00\u4e2a\u5b57\u7b26\u4e32\uff0c\u5982\u4e0b\u6240\u793a\uff1a</p> <pre><code># \"name: str\" \u6ce8\u91ca\u8868\u660e \"name\" \u53c2\u6570\u5e94\u8be5\u662f\u4e00\u4e2a\u5b57\u7b26\u4e32\n# \"-&gt; str\" \u6ce8\u91ca\u8868\u660e \"greeting\" \u5c06\u8fd4\u56de\u4e00\u4e2a\u5b57\u7b26\u4e32\ndef greeting(name: str) -&gt; str:\n    return 'Hello ' + name\n</code></pre> <p>\u8fd9\u4e2a\u51fd\u6570\u73b0\u5728\u662f\u9759\u6001\u7c7b\u578b\u7684\uff1amypy \u5c06\u4f7f\u7528\u63d0\u4f9b\u7684\u7c7b\u578b\u63d0\u793a\u6765\u68c0\u6d4b greeting \u51fd\u6570\u7684\u9519\u8bef\u4f7f\u7528\u4ee5\u53ca greeting \u51fd\u6570\u5185\u90e8\u53d8\u91cf\u7684\u9519\u8bef\u4f7f\u7528\u3002\u4f8b\u5982\uff1a</p> <pre><code>def greeting(name: str) -&gt; str:\n    return 'Hello ' + name\n\ngreeting(3)         # \"greeting\" \u7684\u53c2\u6570 1 \u6709\u4e0d\u517c\u5bb9\u7684\u7c7b\u578b \"int\"\uff1b\u9884\u671f \"str\"\ngreeting(b'Alice')  # \"greeting\" \u7684\u53c2\u6570 1 \u6709\u4e0d\u517c\u5bb9\u7684\u7c7b\u578b \"bytes\"\uff1b\u9884\u671f \"str\"\ngreeting(\"World!\")  # \u65e0\u9519\u8bef\n\ndef bad_greeting(name: str) -&gt; str:\n    return 'Hello ' * name  # \"str\" \u548c \"str\" \u5bf9\u4e8e * \u8fd0\u7b97\u7b26\u4e0d\u652f\u6301\u7684\u64cd\u4f5c\u6570\u7c7b\u578b\n</code></pre> <p>\u80fd\u591f\u9009\u62e9\u51fd\u6570\u662f\u52a8\u6001\u7c7b\u578b\u8fd8\u662f\u9759\u6001\u7c7b\u578b\u975e\u5e38\u6709\u7528\u3002\u4f8b\u5982\uff0c\u5982\u679c\u4f60\u6b63\u5728\u5c06\u73b0\u6709\u7684 Python \u4ee3\u7801\u5e93\u8fc1\u79fb\u5230\u4f7f\u7528\u9759\u6001\u7c7b\u578b\uff0c\u901a\u5e38\u9010\u4e2a\u6dfb\u52a0\u7c7b\u578b\u6ce8\u91ca\u6bd4\u4e00\u6b21\u6027\u5168\u90e8\u6dfb\u52a0\u8981\u5bb9\u6613\u3002\u540c\u6837\uff0c\u5f53\u4f60\u5728\u539f\u578b\u8bbe\u8ba1\u4e00\u4e2a\u65b0\u7279\u6027\u65f6\uff0c\u6700\u521d\u4f7f\u7528\u52a8\u6001\u7c7b\u578b\u5b9e\u73b0\u4ee3\u7801\uff0c\u4ee3\u7801\u66f4\u7a33\u5b9a\u540e\u518d\u6dfb\u52a0\u7c7b\u578b\u6ce8\u91ca\u53ef\u80fd\u66f4\u65b9\u4fbf\u3002</p> <p>\u4e00\u65e6\u4f60\u5b8c\u6210\u4e86\u8fc1\u79fb\u6216\u539f\u578b\u8bbe\u8ba1\uff0c\u4f60\u53ef\u4ee5\u4f7f\u7528 --disallow-untyped-defs \u6807\u5fd7\u8ba9 mypy \u5728\u4f60\u4e0d\u5c0f\u5fc3\u6dfb\u52a0\u4e86\u4e00\u4e2a\u52a8\u6001\u51fd\u6570\u65f6\u8b66\u544a\u4f60\u3002\u4f60\u8fd8\u53ef\u4ee5\u4f7f\u7528 --check-untyped-defs \u6807\u5fd7\u8ba9 mypy \u5bf9\u52a8\u6001\u7c7b\u578b\u51fd\u6570\u8fdb\u884c\u4e00\u4e9b\u6709\u9650\u7684\u68c0\u67e5\u3002\u6709\u5173\u914d\u7f6e mypy \u7684\u66f4\u591a\u4fe1\u606f\uff0c\u8bf7\u53c2\u89c1 The mypy command line\u3002</p> <p>A function without type annotations is considered to be dynamically typed by mypy:</p> <pre><code>def greeting(name):\n    return 'Hello ' + name\n</code></pre> <p>By default, mypy will not type check dynamically typed functions. This means that with a few exceptions, mypy will not report any errors with regular unannotated Python.</p> <p>This is the case even if you misuse the function!</p> <pre><code>def greeting(name):\n    return 'Hello ' + name\n\n# These calls will fail when the program runs, but mypy does not report an error\n# because \"greeting\" does not have type annotations.\ngreeting(123)\ngreeting(b\"Alice\")\n</code></pre> <p>We can get mypy to detect these kinds of bugs by adding type annotations (also known as type hints). For example, you can tell mypy that <code>greeting</code> both accepts and returns a string like so:</p> <pre><code># The \"name: str\" annotation says that the \"name\" argument should be a string\n# The \"-&gt; str\" annotation says that \"greeting\" will return a string\ndef greeting(name: str) -&gt; str:\n    return 'Hello ' + name\n</code></pre> <p>This function is now statically typed: mypy will use the provided type hints to detect incorrect use of the greeting function and incorrect use of variables within the greeting function. For example:</p> <pre><code>def greeting(name: str) -&gt; str:\n    return 'Hello ' + name\n\ngreeting(3)         # Argument 1 to \"greeting\" has incompatible type \"int\"; expected \"str\"\ngreeting(b'Alice')  # Argument 1 to \"greeting\" has incompatible type \"bytes\"; expected \"str\"\ngreeting(\"World!\")  # No error\n\ndef bad_greeting(name: str) -&gt; str:\n    return 'Hello ' * name  # Unsupported operand types for * (\"str\" and \"str\")\n</code></pre> <p>Being able to pick whether you want a function to be dynamically or statically typed can be very helpful. For example, if you are migrating an existing Python codebase to use static types, it\u2019s usually easier to migrate by incrementally adding type hints to your code rather than adding them all at once. Similarly, when you are prototyping a new feature, it may be convenient to initially implement the code using dynamic typing and only add type hints later once the code is more stable.</p> <p>Once you are finished migrating or prototyping your code, you can make mypy warn you if you add a dynamic function by mistake by using the --disallow-untyped-defs flag. You can also get mypy to provide some limited checking of dynamically typed functions by using the --check-untyped-defs flag. See The mypy command line for more information on configuring mypy.</p>"},{"location":"mypy/#\u4e25\u683c\u6a21\u5f0f\u4ee5\u53ca\u914d\u7f6e","title":"\u4e25\u683c\u6a21\u5f0f\u4ee5\u53ca\u914d\u7f6e","text":"<p>Strict mode and configuration</p> \u4e2d\u6587\u82f1\u6587 <p>Mypy \u63d0\u4f9b\u4e86\u4e00\u4e2a\u4e25\u683c\u6a21\u5f0f\uff0c\u8be5\u6a21\u5f0f\u542f\u7528\u4e86\u8bb8\u591a\u989d\u5916\u7684\u68c0\u67e5\uff0c\u6bd4\u5982 --disallow-untyped-defs\u3002</p> <p>\u5982\u679c\u4f60\u4f7f\u7528 --strict \u6807\u5fd7\u8fd0\u884c mypy\uff0c\u4f60\u57fa\u672c\u4e0a\u4e0d\u4f1a\u518d\u5728\u8fd0\u884c\u65f6\u9047\u5230\u4efb\u4f55\u7c7b\u578b\u76f8\u5173\u7684\u9519\u8bef\uff0c\u9664\u975e\u4f60\u4ee5\u67d0\u79cd\u65b9\u5f0f\u660e\u786e\u89c4\u907f\u4e86 mypy\u3002</p> <p>\u7136\u800c\uff0c\u5982\u679c\u4f60\u6b63\u8bd5\u56fe\u4e3a\u4e00\u4e2a\u5927\u578b\u7684\u3001\u73b0\u6709\u7684\u4ee3\u7801\u5e93\u6dfb\u52a0\u9759\u6001\u7c7b\u578b\uff0c\u8fd9\u4e2a\u6807\u5fd7\u53ef\u80fd\u4f1a\u8fc7\u4e8e\u6fc0\u8fdb\u3002\u6709\u5173\u5982\u4f55\u5904\u7406\u8fd9\u79cd\u60c5\u51b5\u7684\u5efa\u8bae\uff0c\u8bf7\u53c2\u89c1\u5728\u73b0\u6709\u4ee3\u7801\u5e93\u4e2d\u4f7f\u7528 mypy\u3002</p> <p>Mypy \u662f\u975e\u5e38\u53ef\u914d\u7f6e\u7684\uff0c\u4f60\u53ef\u4ee5\u4ece\u4f7f\u7528 <code>--strict</code> \u5f00\u59cb\uff0c\u7136\u540e\u5173\u95ed\u4e2a\u522b\u68c0\u67e5\u3002\u4f8b\u5982\uff0c\u5982\u679c\u4f60\u4f7f\u7528\u8bb8\u591a\u6ca1\u6709\u7c7b\u578b\u7684\u7b2c\u4e09\u65b9\u5e93\uff0c<code>--ignore-missing-imports</code> \u53ef\u80fd\u4f1a\u5f88\u6709\u7528\u3002\u5173\u4e8e\u5982\u4f55\u9010\u6b65\u91c7\u7528 <code>--strict</code>\uff0c\u8bf7\u53c2\u89c1\u5f15\u5165\u66f4\u4e25\u683c\u7684\u9009\u9879\u3002</p> <p>\u6709\u5173\u914d\u7f6e\u9009\u9879\u7684\u5b8c\u6574\u53c2\u8003\uff0c\u8bf7\u53c2\u89c1 mypy \u547d\u4ee4\u884c \u548c mypy \u914d\u7f6e\u6587\u4ef6\u3002</p> <p>Mypy has a strict mode that enables a number of additional checks, like --disallow-untyped-defs.</p> <p>If you run mypy with the --strict flag, you will basically never get a type related error at runtime without a corresponding mypy error, unless you explicitly circumvent mypy somehow.</p> <p>However, this flag will probably be too aggressive if you are trying to add static types to a large, existing codebase. See Using mypy with an existing codebase for suggestions on how to handle that case.</p> <p>Mypy is very configurable, so you can start with using <code>--strict</code> and toggle off individual checks. For instance, if you use many third party libraries that do not have types, --ignore-missing-imports may be useful. See Introduce stricter options for how to build up to <code>--strict</code>.</p> <p>See The mypy command line and The mypy configuration file for a complete reference on configuration options.</p>"},{"location":"mypy/#\u66f4\u591a\u590d\u6742\u7c7b\u578b","title":"\u66f4\u591a\u590d\u6742\u7c7b\u578b","text":"<p>More complex types</p> \u4e2d\u6587\u82f1\u6587 <p>\u5230\u76ee\u524d\u4e3a\u6b62\uff0c\u6211\u4eec\u5df2\u7ecf\u6dfb\u52a0\u4e86\u4f7f\u7528\u57fa\u672c\u5177\u4f53\u7c7b\u578b\uff08\u5982 <code>str</code> \u548c <code>float</code>\uff09\u7684\u7c7b\u578b\u63d0\u793a\u3002\u5982\u679c\u6211\u4eec\u60f3\u8868\u8fbe\u66f4\u590d\u6742\u7684\u7c7b\u578b\uff0c\u4f8b\u5982\u201c\u4e00\u4e2a\u5b57\u7b26\u4e32\u5217\u8868\u201d\u6216\u201c\u4e00\u4e2a\u6574\u6570\u7684\u53ef\u8fed\u4ee3\u5bf9\u8c61\u201d\u600e\u4e48\u529e\uff1f</p> <p>\u4f8b\u5982\uff0c\u8981\u8868\u793a\u67d0\u4e2a\u51fd\u6570\u53ef\u4ee5\u63a5\u53d7\u4e00\u4e2a\u5b57\u7b26\u4e32\u5217\u8868\uff0c\u53ef\u4ee5\u4f7f\u7528 <code>list[str]</code> \u7c7b\u578b\uff08\u9002\u7528\u4e8e Python 3.9 \u53ca\u66f4\u9ad8\u7248\u672c\uff09\uff1a</p> <pre><code>def greet_all(names: list[str]) -&gt; None:\n    for name in names:\n        print('Hello ' + name)\n\nnames = [\"Alice\", \"Bob\", \"Charlie\"]\nages = [10, 20, 30]\n\ngreet_all(names)   # \u53ef\u4ee5\uff01\ngreet_all(ages)    # \u7531\u4e8e\u7c7b\u578b\u4e0d\u517c\u5bb9\uff0c\u51fa\u73b0\u9519\u8bef\n</code></pre> <p>list \u7c7b\u578b\u662f\u4e00\u4e2a\u79f0\u4e3a\u6cdb\u578b\u7c7b\u578b\u7684\u793a\u4f8b\uff1a\u5b83\u53ef\u4ee5\u63a5\u53d7\u4e00\u4e2a\u6216\u591a\u4e2a\u7c7b\u578b\u53c2\u6570\u3002\u5728\u8fd9\u79cd\u60c5\u51b5\u4e0b\uff0c\u6211\u4eec\u901a\u8fc7\u5199 <code>list[str]</code> \u6765\u5bf9 list \u8fdb\u884c\u53c2\u6570\u5316\u3002\u8fd9\u4f7f\u5f97 mypy \u77e5\u9053 <code>greet_all</code> \u4ec5\u63a5\u53d7\u5305\u542b\u5b57\u7b26\u4e32\u7684\u5217\u8868\uff0c\u800c\u4e0d\u662f\u5305\u542b\u6574\u6570\u6216\u5176\u4ed6\u7c7b\u578b\u7684\u5217\u8868\u3002</p> <p>\u5728\u4e0a\u9762\u7684\u4f8b\u5b50\u4e2d\uff0c\u7c7b\u578b\u7b7e\u540d\u53ef\u80fd\u6709\u70b9\u8fc7\u4e8e\u4e25\u683c\u3002\u6bd5\u7adf\uff0c\u8fd9\u4e2a\u51fd\u6570\u5e76\u4e0d\u4e00\u5b9a\u975e\u5f97\u63a5\u53d7 \u5177\u4f53\u7684 \u5217\u8868\u2014\u2014\u5982\u679c\u4f60\u4f20\u9012\u4e00\u4e2a\u5143\u7ec4\u3001\u96c6\u5408\u6216\u4efb\u4f55\u5176\u4ed6\u81ea\u5b9a\u4e49\u7684\u53ef\u8fed\u4ee3\u5bf9\u8c61\uff0c\u5b83\u4e5f\u80fd\u6b63\u5e38\u8fd0\u884c\u3002</p> <p>\u4f60\u53ef\u4ee5\u4f7f\u7528 collections.abc.Iterable \u6765\u8868\u8fbe\u8fd9\u4e00\u60f3\u6cd5\uff1a</p> <pre><code>from collections.abc import Iterable  # \u6216\u8005 \"from typing import Iterable\"\n\ndef greet_all(names: Iterable[str]) -&gt; None:\n    for name in names:\n        print('Hello ' + name)\n</code></pre> <p>\u8fd9\u79cd\u884c\u4e3a\u5b9e\u9645\u4e0a\u662f PEP 484 \u7c7b\u578b\u7cfb\u7edf\u7684\u4e00\u4e2a\u57fa\u672c\u65b9\u9762\uff1a\u5f53\u6211\u4eec\u7528\u7c7b\u578b <code>T</code> \u6ce8\u89e3\u67d0\u4e2a\u53d8\u91cf\u65f6\uff0c\u6211\u4eec\u5b9e\u9645\u4e0a\u662f\u5728\u544a\u8bc9 mypy\uff0c\u8fd9\u4e2a\u53d8\u91cf\u53ef\u4ee5\u88ab\u8d4b\u503c\u4e3a <code>T</code> \u7684\u5b9e\u4f8b\uff0c\u6216\u8005 <code>T</code> \u7684 \u5b50\u7c7b\u578b \u7684\u5b9e\u4f8b\u3002\u4e5f\u5c31\u662f\u8bf4\uff0c<code>list[str]</code> \u662f <code>Iterable[str]</code> \u7684\u5b50\u7c7b\u578b\u3002</p> <p>\u8fd9\u4e5f\u9002\u7528\u4e8e\u7ee7\u627f\uff0c\u56e0\u6b64\u5982\u679c\u4f60\u6709\u4e00\u4e2a <code>Child</code> \u7c7b\u7ee7\u627f\u81ea <code>Parent</code>\uff0c\u90a3\u4e48 <code>Child</code> \u7c7b\u578b\u7684\u503c\u53ef\u4ee5\u8d4b\u7ed9 <code>Parent</code> \u7c7b\u578b\u7684\u53d8\u91cf\u3002\u4f8b\u5982\uff0c\u4e00\u4e2a <code>RuntimeError</code> \u5b9e\u4f8b\u53ef\u4ee5\u4f20\u9012\u7ed9\u6ce8\u89e3\u4e3a\u63a5\u53d7 <code>Exception</code> \u7684\u51fd\u6570\u3002</p> <p>\u53e6\u4e00\u4e2a\u4f8b\u5b50\uff0c\u5047\u8bbe\u4f60\u60f3\u7f16\u5199\u4e00\u4e2a\u51fd\u6570\uff0c\u8be5\u51fd\u6570\u53ef\u4ee5\u63a5\u53d7 \u6574\u6570\u6216\u5b57\u7b26\u4e32\uff0c\u4f46\u4e0d\u63a5\u53d7\u5176\u4ed6\u7c7b\u578b\u3002\u4f60\u53ef\u4ee5\u4f7f\u7528 Union \u7c7b\u578b\u6765\u8868\u8fbe\u8fd9\u79cd\u60c5\u51b5\u3002\u4f8b\u5982\uff0c<code>int</code> \u662f <code>Union[int, str]</code> \u7684\u5b50\u7c7b\u578b\uff1a</p> <pre><code>from typing import Union\n\ndef normalize_id(user_id: Union[int, str]) -&gt; str:\n    if isinstance(user_id, int):\n        return f'user-{100_000 + user_id}'\n    else:\n        return user_id\n</code></pre> <p>typing \u6a21\u5757\u5305\u542b\u8bb8\u591a\u5176\u4ed6\u6709\u7528\u7684\u7c7b\u578b\u3002</p> <p>\u8981\u5feb\u901f\u4e86\u89e3\uff0c\u53ef\u4ee5\u67e5\u770b mypy cheatsheet\u3002</p> <p>\u8981\u83b7\u5f97\u8be6\u7ec6\u7684\u6982\u8ff0\uff08\u5305\u62ec\u5982\u4f55\u521b\u5efa\u81ea\u5df1\u7684\u6cdb\u578b\u7c7b\u578b\u6216\u7c7b\u578b\u522b\u540d\uff09\uff0c\u53ef\u4ee5\u67e5\u770b \u7c7b\u578b\u7cfb\u7edf\u53c2\u8003\u3002</p> <p>\u6ce8\u610f</p> <p>\u6dfb\u52a0\u7c7b\u578b\u65f6\uff0c\u7ea6\u5b9a\u662f\u4f7f\u7528 <code>from typing import Union</code> \u5f62\u5f0f\u5bfc\u5165\u7c7b\u578b\uff08\u800c\u4e0d\u662f\u4ec5\u4ec5 <code>import typing</code> \u6216 <code>import typing as t</code> \u6216 <code>from typing import *</code>\uff09\u3002</p> <p>\u4e3a\u4e86\u7b80\u6d01\uff0c\u6211\u4eec\u5728\u4ee3\u7801\u793a\u4f8b\u4e2d\u7ecf\u5e38\u7701\u7565\u4e86\u4ece typing \u6216 collections.abc \u8fdb\u884c\u7684\u5bfc\u5165\uff0c\u4f46\u5982\u679c\u4f60\u5728\u6ca1\u6709\u9996\u5148\u5bfc\u5165\u7684\u60c5\u51b5\u4e0b\u4f7f\u7528\u50cf Iterable \u8fd9\u6837\u7684\u7c7b\u578b\uff0cmypy \u4f1a\u62a5\u9519\u3002</p> <p>\u6ce8\u610f</p> <p>\u5728\u4e00\u4e9b\u4f8b\u5b50\u4e2d\uff0c\u6211\u4eec\u4f7f\u7528\u4e86\u5927\u5199\u7684\u7c7b\u578b\u540d\u79f0\uff0c\u5982 <code>List</code>\uff0c\u800c\u6709\u65f6\u6211\u4eec\u4f7f\u7528\u666e\u901a\u7684 <code>list</code>\u3002\u5b83\u4eec\u662f\u7b49\u4ef7\u7684\uff0c\u4f46\u5982\u679c\u4f60\u4f7f\u7528\u7684\u662f Python 3.8 \u6216\u66f4\u65e9\u7684\u7248\u672c\uff0c\u5219\u9700\u8981\u4f7f\u7528\u524d\u8005\u3002</p> <p>So far, we\u2019ve added type hints that use only basic concrete types like <code>str</code> and <code>float</code>. What if we want to express more complex types, such as \u201ca list of strings\u201d or \u201can iterable of ints\u201d?</p> <p>For example, to indicate that some function can accept a list of strings, use the <code>list[str]</code> type (Python 3.9 and later):</p> <pre><code>def greet_all(names: list[str]) -&gt; None:\n    for name in names:\n        print('Hello ' + name)\n\nnames = [\"Alice\", \"Bob\", \"Charlie\"]\nages = [10, 20, 30]\n\ngreet_all(names)   # Ok!\ngreet_all(ages)    # Error due to incompatible types\n</code></pre> <p>The list type is an example of something called a generic type: it can accept one or more type parameters. In this case, we parameterized list by writing <code>list[str]</code>. This lets mypy know that <code>greet_all</code> accepts specifically lists containing strings, and not lists containing ints or any other type.</p> <p>In the above examples, the type signature is perhaps a little too rigid. After all, there\u2019s no reason why this function must accept specifically a list \u2013 it would run just fine if you were to pass in a tuple, a set, or any other custom iterable.</p> <p>You can express this idea using collections.abc.Iterable:</p> <pre><code>from collections.abc import Iterable  # or \"from typing import Iterable\"\n\ndef greet_all(names: Iterable[str]) -&gt; None:\n    for name in names:\n        print('Hello ' + name)\n</code></pre> <p>This behavior is actually a fundamental aspect of the PEP 484 type system: when we annotate some variable with a type <code>T</code>, we are actually telling mypy that variable can be assigned an instance of <code>T</code>, or an instance of a subtype of <code>T</code>. That is, <code>list[str]</code> is a subtype of <code>Iterable[str]</code>.</p> <p>This also applies to inheritance, so if you have a class <code>Child</code> that inherits from <code>Parent</code>, then a value of type <code>Child</code> can be assigned to a variable of type <code>Parent</code>. For example, a <code>RuntimeError</code> instance can be passed to a function that is annotated as taking an <code>Exception</code>.</p> <p>As another example, suppose you want to write a function that can accept either ints or strings, but no other types. You can express this using the Union type. For example, <code>int</code> is a subtype of <code>Union[int, str]</code>:</p> <pre><code>from typing import Union\n\ndef normalize_id(user_id: Union[int, str]) -&gt; str:\n    if isinstance(user_id, int):\n        return f'user-{100_000 + user_id}'\n    else:\n        return user_id\n</code></pre> <p>The typing module contains many other useful types.</p> <p>For a quick overview, look through the mypy cheatsheet.</p> <p>For a detailed overview (including information on how to make your own generic types or your own type aliases), look through the type system reference.</p> <p>Note</p> <p>When adding types, the convention is to import types using the form <code>from typing import Union</code> (as opposed to doing just <code>import typing</code> or <code>import typing as t</code> or <code>from typing import *</code>).</p> <p>For brevity, we often omit imports from typing or collections.abc in code examples, but mypy will give an error if you use types such as Iterable without first importing them.</p> <p>Note</p> <p>In some examples we use capitalized variants of types, such as <code>List</code>, and sometimes we use plain <code>list</code>. They are equivalent, but the prior variant is needed if you are using Python 3.8 or earlier.</p>"},{"location":"mypy/#\u5c40\u90e8\u7c7b\u578b\u63a8\u65ad","title":"\u5c40\u90e8\u7c7b\u578b\u63a8\u65ad","text":"<p>Local type inference</p> \u4e2d\u6587\u82f1\u6587 <p>\u4e00\u65e6\u4f60\u4e3a\u51fd\u6570\u6dfb\u52a0\u4e86\u7c7b\u578b\u63d0\u793a\uff08\u5373\u4f7f\u5b83\u53d8\u6210\u4e86\u9759\u6001\u7c7b\u578b\uff09\uff0cmypy \u5c06\u81ea\u52a8\u5bf9\u8be5\u51fd\u6570\u7684\u4e3b\u4f53\u8fdb\u884c\u7c7b\u578b\u68c0\u67e5\u3002\u5728\u6b64\u8fc7\u7a0b\u4e2d\uff0cmypy \u5c06\u5c1d\u8bd5\u63a8\u65ad\u5c3d\u53ef\u80fd\u591a\u7684\u7ec6\u8282\u3002</p> <p>\u6211\u4eec\u5728\u4e0a\u9762\u7684 <code>normalize_id</code> \u51fd\u6570\u4e2d\u770b\u5230\u4e86\u4e00\u4e2a\u4f8b\u5b50\u2014\u2014mypy \u80fd\u7406\u89e3\u57fa\u672c\u7684 isinstance \u68c0\u67e5\uff0c\u56e0\u6b64\u53ef\u4ee5\u63a8\u65ad\u51fa <code>user_id</code> \u53d8\u91cf\u5728 if \u5206\u652f\u4e2d\u662f <code>int</code> \u7c7b\u578b\uff0c\u5728 else \u5206\u652f\u4e2d\u662f <code>str</code> \u7c7b\u578b\u3002</p> <p>\u518d\u4e3e\u4e00\u4e2a\u4f8b\u5b50\uff0c\u8003\u8651\u4ee5\u4e0b\u51fd\u6570\u3002Mypy \u53ef\u4ee5\u6beb\u65e0\u95ee\u9898\u5730\u5bf9\u8be5\u51fd\u6570\u8fdb\u884c\u7c7b\u578b\u68c0\u67e5\uff1a\u5b83\u5c06\u5229\u7528\u53ef\u7528\u7684\u4e0a\u4e0b\u6587\u63a8\u65ad\u51fa <code>output</code> \u5fc5\u987b\u662f <code>list[float]</code> \u7c7b\u578b\uff0c\u5e76\u4e14 <code>num</code> \u5fc5\u987b\u662f <code>float</code> \u7c7b\u578b\uff1a</p> <pre><code>def nums_below(numbers: Iterable[float], limit: float) -&gt; list[float]:\n    output = []\n    for num in numbers:\n        if num &lt; limit:\n            output.append(num)\n    return output\n</code></pre> <p>\u6709\u5173\u66f4\u591a\u8be6\u7ec6\u4fe1\u606f\uff0c\u8bf7\u53c2\u9605 \u7c7b\u578b\u63a8\u65ad\u548c\u7c7b\u578b\u6ce8\u89e3\u3002</p> <p>Once you have added type hints to a function (i.e. made it statically typed), mypy will automatically type check that function\u2019s body. While doing so, mypy will try and infer as many details as possible.</p> <p>We saw an example of this in the <code>normalize_id</code> function above \u2013 mypy understands basic isinstance checks and so can infer that the <code>user_id</code> variable was of type <code>int</code> in the if-branch and of type <code>str</code> in the else-branch.</p> <p>As another example, consider the following function. Mypy can type check this function without a problem: it will use the available context and deduce that <code>output</code> must be of type <code>list[float]</code> and that <code>num</code> must be of type <code>float</code>:</p> <pre><code>def nums_below(numbers: Iterable[float], limit: float) -&gt; list[float]:\n    output = []\n    for num in numbers:\n        if num &lt; limit:\n            output.append(num)\n    return output\n</code></pre> <p>For more details, see Type inference and type annotations.</p>"},{"location":"mypy/#\u6765\u81ea\u5e93\u7684\u7c7b\u578b","title":"\u6765\u81ea\u5e93\u7684\u7c7b\u578b","text":"<p>Types from libraries</p> \u4e2d\u6587\u82f1\u6587 <p>Mypy \u4e5f\u53ef\u4ee5\u7406\u89e3\u5982\u4f55\u5904\u7406\u4f60\u6240\u4f7f\u7528\u7684\u5e93\u4e2d\u7684\u7c7b\u578b\u3002</p> <p>\u4f8b\u5982\uff0cmypy \u5185\u7f6e\u4e86\u5bf9 Python \u6807\u51c6\u5e93\u7684\u6df1\u5165\u4e86\u89e3\u3002\u4ee5\u4e0b\u662f\u4e00\u4e2a\u4f7f\u7528 pathlib \u6807\u51c6\u5e93\u6a21\u5757 \u4e2d\u7684 Path \u5bf9\u8c61\u7684\u51fd\u6570\u793a\u4f8b\uff1a</p> <pre><code>from pathlib import Path\n\ndef load_template(template_path: Path, name: str) -&gt; str:\n    # Mypy \u77e5\u9053 `template_path` \u6709\u4e00\u4e2a\u8fd4\u56de\u5b57\u7b26\u4e32\u7684 `read_text` \u65b9\u6cd5\n    template = template_path.read_text()\n    # \u56e0\u6b64\u5b83\u7406\u89e3\u8fd9\u884c\u4ee3\u7801\u7684\u7c7b\u578b\u68c0\u67e5\u662f\u6b63\u786e\u7684\n    return template.replace('USERNAME', name)\n</code></pre> <p>\u5982\u679c\u4f60\u4f7f\u7528\u7684\u7b2c\u4e09\u65b9\u5e93 \u58f0\u660e\u652f\u6301\u7c7b\u578b\u68c0\u67e5\uff0cmypy \u5c06\u6839\u636e\u8be5\u5e93\u4e2d\u7684\u7c7b\u578b\u63d0\u793a\u5bf9\u4f60\u4f7f\u7528\u8be5\u5e93\u7684\u4ee3\u7801\u8fdb\u884c\u7c7b\u578b\u68c0\u67e5\u3002</p> <p>\u7136\u800c\uff0c\u5982\u679c\u7b2c\u4e09\u65b9\u5e93\u6ca1\u6709\u7c7b\u578b\u63d0\u793a\uff0cmypy \u5c06\u4f1a\u63d0\u793a\u7f3a\u5c11\u7c7b\u578b\u4fe1\u606f\u3002</p> <pre><code>prog.py:1: error: Library stubs not installed for \"yaml\"\nprog.py:1: note: Hint: \"python3 -m pip install types-PyYAML\"\nprog.py:2: error: Library stubs not installed for \"requests\"\nprog.py:2: note: Hint: \"python3 -m pip install types-requests\"\n...\n</code></pre> <p>\u5728\u8fd9\u79cd\u60c5\u51b5\u4e0b\uff0c\u4f60\u53ef\u4ee5\u901a\u8fc7\u5b89\u88c5\u5b58\u6839\u5305\u6765\u4e3a mypy \u63d0\u4f9b\u53e6\u4e00\u79cd\u7c7b\u578b\u4fe1\u606f\u6765\u6e90\u3002\u5b58\u6839\u5305\u662f\u4e00\u4e2a\u4ec5\u5305\u542b\u7c7b\u578b\u63d0\u793a\u4f46\u4e0d\u5305\u542b\u5b9e\u9645\u4ee3\u7801\u7684\u5305\u3002</p> <pre><code>$ python3 -m pip install types-PyYAML types-requests\n</code></pre> <p>\u5206\u53d1\u5305\u7684\u5b58\u6839\u5305\u901a\u5e38\u547d\u540d\u4e3a <code>types-&lt;distribution&gt;</code>\u3002\u6ce8\u610f\uff0c\u5206\u53d1\u5305\u7684\u540d\u79f0\u53ef\u80fd\u4e0e\u5bfc\u5165\u7684\u5305\u540d\u4e0d\u540c\u3002\u4f8b\u5982\uff0c<code>types-PyYAML</code> \u5305\u542b <code>yaml</code> \u5305\u7684\u5b58\u6839\u3002</p> <p>\u6709\u5173\u5904\u7406\u7f3a\u5c11\u7c7b\u578b\u4fe1\u606f\u7684\u5e93\u9519\u8bef\u7684\u7b56\u7565\u7684\u66f4\u591a\u8ba8\u8bba\uff0c\u8bf7\u53c2\u9605 \u7f3a\u5c11\u5bfc\u5165\u3002</p> <p>\u6709\u5173\u5b58\u6839\u7684\u66f4\u591a\u4fe1\u606f\uff0c\u8bf7\u53c2\u9605 \u5b58\u6839\u6587\u4ef6\u3002</p> <p>Mypy can also understand how to work with types from libraries that you use.</p> <p>For instance, mypy comes out of the box with an intimate knowledge of the Python standard library. For example, here is a function which uses the Path object from the pathlib standard library module:</p> <pre><code>from pathlib import Path\n\ndef load_template(template_path: Path, name: str) -&gt; str:\n    # Mypy knows that `template_path` has a `read_text` method that returns a str\n    template = template_path.read_text()\n    # ...so it understands this line type checks\n    return template.replace('USERNAME', name)\n</code></pre> <p>If a third party library you use declares support for type checking, mypy will type check your use of that library based on the type hints it contains.</p> <p>However, if the third party library does not have type hints, mypy will complain about missing type information.</p> <pre><code>prog.py:1: error: Library stubs not installed for \"yaml\"\nprog.py:1: note: Hint: \"python3 -m pip install types-PyYAML\"\nprog.py:2: error: Library stubs not installed for \"requests\"\nprog.py:2: note: Hint: \"python3 -m pip install types-requests\"\n...\n</code></pre> <p>In this case, you can provide mypy a different source of type information, by installing a stub package. A stub package is a package that contains type hints for another library, but no actual code.</p> <p><code>$ python3 -m pip install types-PyYAML types-requests</code></p> <p>Stubs packages for a distribution are often named <code>types-&lt;distribution&gt;</code>. Note that a distribution name may be different from the name of the package that you import. For example, <code>types-PyYAML</code> contains stubs for the <code>yaml</code> package.</p> <p>For more discussion on strategies for handling errors about libraries without type information, refer to Missing imports.</p> <p>For more information about stubs, see Stub files.</p>"},{"location":"mypy/#\u4e0b\u4e00\u6b65","title":"\u4e0b\u4e00\u6b65","text":"<p>Next steps</p> \u4e2d\u6587\u82f1\u6587 <p>\u5982\u679c\u4f60\u65f6\u95f4\u7d27\u8feb\uff0c\u4e0d\u60f3\u5728\u5f00\u59cb\u4e4b\u524d\u9605\u8bfb\u5927\u91cf\u6587\u6863\uff0c\u4ee5\u4e0b\u662f\u4e00\u4e9b\u5feb\u901f\u5b66\u4e60\u8d44\u6e90\u7684\u6307\u5f15\uff1a</p> <ul> <li> <p>\u9605\u8bfb mypy cheatsheet\u3002</p> </li> <li> <p>\u5982\u679c\u4f60\u6709\u4e00\u4e2a\u73b0\u6709\u7684\u5927\u578b\u4ee3\u7801\u5e93\u4f46\u6ca1\u6709\u5f88\u591a\u7c7b\u578b\u6ce8\u89e3\uff0c\u53ef\u4ee5\u9605\u8bfb \u5982\u4f55\u5728\u73b0\u6709\u4ee3\u7801\u5e93\u4e2d\u4f7f\u7528 mypy\u3002</p> </li> <li> <p>\u9605\u8bfb\u5173\u4e8e Zulip \u9879\u76ee\u91c7\u7eb3 mypy \u7684 \u535a\u5ba2\u6587\u7ae0\u3002</p> </li> <li> <p>\u5982\u679c\u4f60\u66f4\u559c\u6b22\u89c2\u770b\u8bb2\u5ea7\u800c\u4e0d\u662f\u9605\u8bfb\uff0c\u4ee5\u4e0b\u662f\u4e00\u4e9b\u5efa\u8bae\uff1a</p> <ul> <li> <p>Carl Meyer: Type Checked Python in the Real World (PyCon 2018)</p> </li> <li> <p>Greg Price: Clearer Code at Scale: Static Types at Zulip and Dropbox (PyCon 2018)</p> </li> </ul> </li> <li> <p>\u5982\u679c\u4f60\u9047\u5230\u95ee\u9898\uff0c\u53ef\u4ee5\u67e5\u770b mypy \u7684\u5e38\u89c1\u95ee\u9898\u89e3\u51b3\u65b9\u6848\u3002</p> </li> <li> <p>\u4f60\u53ef\u4ee5\u5728 mypy \u95ee\u9898\u8ddf\u8e2a\u5668 \u548c typing \u7684 Gitter \u804a\u5929 \u4e2d\u63d0\u51fa\u6709\u5173 mypy \u7684\u95ee\u9898\u3002</p> </li> <li> <p>\u5bf9\u4e8e\u6709\u5173 Python \u7c7b\u578b\u7684\u4e00\u822c\u95ee\u9898\uff0c\u53ef\u4ee5\u5c1d\u8bd5\u5728 typing discussions \u4e2d\u53d1\u5e16\u3002</p> </li> </ul> <p>\u4f60\u4e5f\u53ef\u4ee5\u7ee7\u7eed\u9605\u8bfb\u672c\u6587\u6863\uff0c\u5e76\u8df3\u8fc7\u90a3\u4e9b\u4e0e\u4f60\u65e0\u5173\u7684\u90e8\u5206\u3002\u4f60\u4e0d\u9700\u8981\u6309\u987a\u5e8f\u9605\u8bfb\u5404\u4e2a\u7ae0\u8282\u3002</p> <p>If you are in a hurry and don\u2019t want to read lots of documentation before getting started, here are some pointers to quick learning resources:</p> <ul> <li> <p>Read the mypy cheatsheet.</p> </li> <li> <p>Read Using mypy with an existing codebase if you have a significant existing codebase without many type annotations.</p> </li> <li> <p>Read the blog post about the Zulip project\u2019s experiences with adopting mypy.</p> </li> <li> <p>If you prefer watching talks instead of reading, here are some ideas:</p> <ul> <li> <p>Carl Meyer: Type Checked Python in the Real World (PyCon 2018)</p> </li> <li> <p>Greg Price: Clearer Code at Scale: Static Types at Zulip and Dropbox (PyCon 2018)</p> </li> </ul> </li> <li> <p>Look at solutions to common issues with mypy if you encounter problems.</p> </li> <li> <p>You can ask questions about mypy in the mypy issue tracker and typing Gitter chat.</p> </li> <li> <p>For general questions about Python typing, try posting at typing discussions.</p> </li> </ul> <p>You can also continue reading this document and skip sections that aren\u2019t relevant for you. You don\u2019t need to read sections in order.</p>"},{"location":"mypy/annotation_issue_at_runtime/","title":"\u8fd0\u884c\u65f6\u7684\u6ce8\u89e3\u95ee\u9898","text":"\u4e2d\u6587\u82f1\u6587 <p>\u7c7b\u578b\u6ce8\u91ca\u7684\u60ef\u7528\u7528\u6cd5\u6709\u65f6\u53ef\u80fd\u4f1a\u4e0e\u7ed9\u5b9a\u7248\u672c\u7684 Python \u8ba4\u4e3a\u7684\u5408\u6cd5\u4ee3\u7801\u76f8\u51b2\u7a81\u3002 \u672c\u8282\u63cf\u8ff0\u8fd9\u4e9b\u573a\u666f\u5e76\u89e3\u91ca\u5982\u4f55\u8ba9\u4ee3\u7801\u518d\u6b21\u8fd0\u884c\u3002 \u4e00\u822c\u6765\u8bf4\uff0c\u6211\u4eec\u53ef\u4ee5\u4f7f\u7528\u4e09\u79cd\u5de5\u5177\uff1a</p> <ul> <li>\u4f7f\u7528 <code>from __future__ import annotations</code> (<code>PEP 563</code>) \uff08\u6b64\u884c\u4e3a\u6700\u7ec8\u53ef\u80fd\u4f1a\u5728\u672a\u6765\u7684 Python \u7248\u672c\u4e2d\u6210\u4e3a\u9ed8\u8ba4\u884c\u4e3a\uff09</li> <li>\u4f7f\u7528\u5b57\u7b26\u4e32\u6587\u5b57\u7c7b\u578b\u6216\u7c7b\u578b\u6ce8\u91ca</li> <li>\u4f7f\u7528 <code>typing.TYPE_CHECKING</code></li> </ul> <p>\u5728\u8ba8\u8bba\u60a8\u53ef\u80fd\u9047\u5230\u7684\u5177\u4f53\u95ee\u9898\u4e4b\u524d\uff0c\u6211\u4eec\u4f1a\u5148\u63d0\u4f9b\u8fd9\u4e9b\u5185\u5bb9\u7684\u63cf\u8ff0\u3002</p> <p>Annotation issues at runtime</p> <p>Idiomatic use of type annotations can sometimes run up against what a given version of Python considers legal code. This section describes these scenarios and explains how to get your code running again. Generally speaking, we have three tools at our disposal:</p> <ul> <li>Use of <code>from __future__ import annotations</code> (<code>PEP 563</code>)  (this behaviour may eventually be made the default in a future Python version)</li> <li>Use of string literal types or type comments</li> <li>Use of <code>typing.TYPE_CHECKING</code></li> </ul> <p>We provide a description of these before moving onto discussion of specific problems you may encounter.</p>"},{"location":"mypy/annotation_issue_at_runtime/#\u5b57\u7b26\u4e32\u6587\u5b57\u7c7b\u578b\u548c\u7c7b\u578b\u6ce8\u91ca","title":"\u5b57\u7b26\u4e32\u6587\u5b57\u7c7b\u578b\u548c\u7c7b\u578b\u6ce8\u91ca","text":"\u4e2d\u6587\u82f1\u6587 <p>Mypy \u5141\u8bb8\u60a8\u4f7f\u7528\u4ee5 <code># type:</code> \u5f62\u5f0f\u6dfb\u52a0\u7c7b\u578b\u6ce8\u91ca\u3002 \u4f8b\u5982\uff1a</p> <pre><code>a = 1  # type: int\n\ndef f(x):  # type: (int) -&gt; int\n    return x + 1\n\n# \u5177\u6709\u591a\u4e2a\u53c2\u6570\u7684\u51fd\u6570\u7684\u66ff\u4ee3\u7c7b\u578b\u6ce8\u91ca\u8bed\u6cd5\ndef send_email(\n    address,     # type: Union[str, List[str]]\n    sender,      # type: str\n    cc,          # type: Optional[List[str]]\n    subject='',\n    body=None    # type: List[str]\n):\n    # type: (...) -&gt; bool\n</code></pre> <p>\u7c7b\u578b\u6ce8\u91ca\u4e0d\u4f1a\u5bfc\u81f4\u8fd0\u884c\u65f6\u9519\u8bef\uff0c\u56e0\u4e3a Python \u4e0d\u4f1a\u8bc4\u4f30\u6ce8\u91ca\u3002</p> <p>\u4ee5\u7c7b\u4f3c\u7684\u65b9\u5f0f\uff0c\u4f7f\u7528\u5b57\u7b26\u4e32\u6587\u5b57\u7c7b\u578b\u53ef\u4ee5\u56de\u907f\u53ef\u80fd\u5bfc\u81f4\u8fd0\u884c\u65f6\u9519\u8bef\u7684\u6ce8\u91ca\u95ee\u9898\u3002</p> <p>\u4efb\u4f55\u7c7b\u578b\u90fd\u53ef\u4ee5\u4f5c\u4e3a\u5b57\u7b26\u4e32\u6587\u5b57\u8f93\u5165\uff0c\u5e76\u4e14\u60a8\u53ef\u4ee5\u81ea\u7531\u5730\u5c06\u5b57\u7b26\u4e32\u6587\u5b57\u7c7b\u578b\u4e0e\u975e\u5b57\u7b26\u4e32\u6587\u5b57\u7c7b\u578b\u7ec4\u5408\uff1a</p> <pre><code>def f(a: list['A']) -&gt; None: ...  # OK, \u9632\u6b62 NameError \u56e0\u4e3a A \u662f\u7a0d\u540e\u5b9a\u4e49\u7684\ndef g(n: 'int') -&gt; None: ...      # \u540c\u6837 OK, \u867d\u7136\u6ca1\u7528\n\nclass A: pass\n</code></pre> <p><code># type:</code> \u6ce8\u91ca\u548c <code>\u5b58\u6839\u6587\u4ef6</code> \u4e2d\u6c38\u8fdc\u4e0d\u9700\u8981\u5b57\u7b26\u4e32\u6587\u5b57\u7c7b\u578b\u3002</p> <p>\u5b57\u7b26\u4e32\u6587\u5b57\u7c7b\u578b\u5fc5\u987b\u7a0d\u540e\u5728\u540c\u4e00\u6a21\u5757\u4e2d\u5b9a\u4e49\uff08\u6216\u5bfc\u5165\uff09\u3002 \u5b83\u4eec\u4e0d\u80fd\u7528\u4e8e\u7559\u4e0b\u672a\u89e3\u51b3\u7684\u8de8\u6a21\u5757\u5f15\u7528\u3002(\u6709\u5173\u5904\u7406\u5bfc\u5165\u5468\u671f\uff0c\u8bf7\u53c2\u9605 <code>import-cycles</code>.)</p> <p>String literal types and type comments</p> <p>Mypy allows you to add type annotations using <code># type:</code> type comments. For example:</p> <pre><code>a = 1  # type: int\n\ndef f(x):  # type: (int) -&gt; int\n    return x + 1\n\n# Alternative type comment syntax for functions with many arguments\ndef send_email(\n    address,     # type: Union[str, List[str]]\n    sender,      # type: str\n    cc,          # type: Optional[List[str]]\n    subject='',\n    body=None    # type: List[str]\n):\n    # type: (...) -&gt; bool\n</code></pre> <p>Type comments can't cause runtime errors because comments are not evaluated by Python.</p> <p>In a similar way, using string literal types sidesteps the problem of annotations tha would cause runtime errors.</p> <p>Any type can be entered as a string literal, and you can combine string-literal types with non-string-literal types freely:</p> <pre><code>def f(a: list['A']) -&gt; None: ...  # OK, prevents NameError since A is defined later\ndef g(n: 'int') -&gt; None: ...      # Also OK, though not useful\n\nclass A: pass\n</code></pre> <p>String literal types are never needed in <code># type:</code> comments and <code>stub files</code>.</p> <p>String literal types must be defined (or imported) later in the same module. They cannot be used to leave cross-module references unresolved.  (For dealing with import cycles, see <code>import-cycles</code>.)</p> <p>(future-annotations)=</p>"},{"location":"mypy/annotation_issue_at_runtime/#future-\u6a21\u5757\u6ce8\u89e3\u5bfc\u5165-pep-563","title":"Future \u6a21\u5757\u6ce8\u89e3\u5bfc\u5165 (PEP 563)","text":"\u4e2d\u6587\u82f1\u6587 <p>\u8fd9\u91cc\u63cf\u8ff0\u7684\u8bb8\u591a\u95ee\u9898\u90fd\u662f\u7531 Python \u5c1d\u8bd5\u8bc4\u4f30\u6ce8\u91ca\u5f15\u8d77\u7684\u3002 \u672a\u6765\u7684 Python \u7248\u672c\uff08\u53ef\u80fd\u662f Python 3.12\uff09\u5c06\u9ed8\u8ba4\u4e0d\u518d\u5c1d\u8bd5\u8ba1\u7b97\u51fd\u6570\u548c\u53d8\u91cf\u6ce8\u91ca\u3002 Python 3.7 \u53ca\u66f4\u9ad8\u7248\u672c\u4e2d\u901a\u8fc7\u4f7f\u7528 <code>from __future__ import annotation</code>\u63d0\u4f9b\u4e86\u6b64\u884c\u4e3a\u3002</p> <p>\u8fd9\u53ef\u4ee5\u88ab\u8ba4\u4e3a\u662f\u6240\u6709\u51fd\u6570\u548c\u53d8\u91cf\u6ce8\u91ca\u7684\u81ea\u52a8\u5b57\u7b26\u4e32\u6587\u5b57\u5316\u3002 \u8bf7\u6ce8\u610f\uff0c\u51fd\u6570\u548c\u53d8\u91cf\u6ce8\u91ca\u4ecd\u7136\u9700\u8981\u662f\u6709\u6548\u7684 Python \u8bed\u6cd5\u3002 \u6709\u5173\u66f4\u591a\u8be6\u7ec6\u4fe1\u606f\uff0c\u8bf7\u53c2\u9605<code>PEP 563</code>.</p> <p>Note</p> <p>\u5373\u4f7f\u4f7f\u7528 <code>__future__</code> \u5bfc\u5165\uff0c\u5728\u67d0\u4e9b\u60c5\u51b5\u4e0b\u4ecd\u7136\u53ef\u80fd\u9700\u8981\u5b57\u7b26\u4e32\u6587\u5b57\u6216\u5bfc\u81f4\u9519\u8bef\uff0c\u901a\u5e38\u6d89\u53ca\u5728\u4ee5\u4e0b\u60c5\u51b5\u4e2d\u4f7f\u7528\u524d\u7f6e\u5f15\u7528\u6216\u6cdb\u578b\uff1a</p> <ul> <li><code>type aliases</code>;</li> <li><code>type narrowing</code>;</li> <li>\u7c7b\u578b\u5b9a\u4e49 (\u53c2\u8003 <code>typing.TypeVar</code>, <code>typing.NewType</code>, <code>typing.NamedTuple</code>);</li> <li>\u57fa\u7c7b.</li> </ul> <pre><code># \u57fa\u7c7b\u793a\u4f8b\nfrom __future__ import annotations\nclass A(tuple['B', 'C']): ... # \u8fd9\u91cc\u9700\u8981\u5b57\u7b26\u4e32\u6587\u5b57\u7c7b\u578b\nclass B: ...\nclass C: ...\n</code></pre> <p>Warning</p> <p>\u67d0\u4e9b\u5e93\u53ef\u80fd\u5177\u6709\u52a8\u6001\u8bc4\u4f30\u6ce8\u91ca\u7684\u7528\u4f8b\uff0c\u4f8b\u5982\u901a\u8fc7\u4f7f\u7528<code>typing.get_type_hints</code>\u6216<code>eval</code>\u3002 \u5982\u679c\u60a8\u7684\u6ce8\u91ca\u5728\u8bc4\u4f30\u65f6\u4f1a\u5f15\u53d1\u9519\u8bef\uff08\u4f8b\u5982\u4f7f\u7528 Python 3.9 \u7684 <code>PEP 604</code> \u8bed\u6cd5\uff09\uff0c\u5219\u5728\u4f7f\u7528\u6b64\u7c7b\u65f6\u53ef\u80fd\u9700\u8981\u5c0f\u5fc3\u8fd9\u6837\u7684\u5e93\u3002</p> <p>Future annotations import (PEP 563)</p> <p>Many of the issues described here are caused by Python trying to evaluate annotations. Future Python versions (potentially Python 3.12) will by default no longer attempt to evaluate function and variable annotations. This behaviour is made available in Python 3.7 and later through the use of <code>from __future__ import annotations</code>.</p> <p>This can be thought of as automatic string literal-ification of all function and variable annotations. Note that function and variable annotations are still required to be valid Python syntax. For more details, see <code>PEP 563</code>.</p> <p>Note</p> <p>Even with the <code>__future__</code> import, there are some scenarios that could still require string literals or result in errors, typically involving use of forward references or generics in:</p> <ul> <li><code>type aliases</code>;</li> <li><code>type narrowing</code>;</li> <li>type definitions (see <code>typing.TypeVar</code>, <code>typing.NewType</code>, <code>typing.NamedTuple</code>);</li> <li>base classes.</li> </ul> <pre><code># base class example\nfrom __future__ import annotations\nclass A(tuple['B', 'C']): ... # String literal types needed here\nclass B: ...\nclass C: ...\n</code></pre> <p>Warning</p> <p>Some libraries may have use cases for dynamic evaluation of annotations, for instance, through use of <code>typing.get_type_hints</code> or <code>eval</code>. If your annotation would raise an error when evaluated (say by using <code>PEP 604</code> syntax with Python 3.9), you may need to be careful when using such libraries.</p>"},{"location":"mypy/annotation_issue_at_runtime/#typingtype_checking-\u53d8\u91cf","title":"typing.TYPE_CHECKING \u53d8\u91cf","text":"\u4e2d\u6587\u82f1\u6587 <p><code>typing</code> \u6a21\u5757\u5b9a\u4e49\u4e86\u4e00\u4e2a <code>typing.TYPE_CHECKING</code> \u5e38\u91cf\u5728\u8fd0\u884c\u65f6\u4e3a <code>False</code>\uff0c\u4f46\u5728\u7c7b\u578b\u68c0\u67e5\u65f6\u88ab\u89c6\u4e3a <code>True</code>\u3002</p> <p>\u5728 <code>if TYPE_CHECKING</code> \u4ee3\u7801\u7684\u5185\u90e8: \u4ee3\u7801\u4e0d\u4f1a\u5728\u8fd0\u884c\u65f6\u6267\u884c\uff0c\u56e0\u6b64\u5b83\u63d0\u4f9b\u4e86\u4e00\u79cd\u65b9\u4fbf\u7684\u65b9\u6cd5\u6765\u544a\u8bc9 mypy \u67d0\u4e9b\u5185\u5bb9\uff0c\u800c\u65e0\u9700\u5728\u8fd0\u884c\u65f6\u8bc4\u4f30\u4ee3\u7801\u3002 \u8fd9\u5bf9\u4e8e\u89e3\u51b3\u5faa\u73af\u5bfc\u5165\u6700\u6709\u7528\u3002</p> <p>typing.TYPE_CHECKING</p> <p>The <code>typing</code> module defines a <code>typing.TYPE_CHECKING</code> constant that is <code>False</code> at runtime but treated as <code>True</code> while type checking.</p> <p>Since code inside <code>if TYPE_CHECKING:</code> is not executed at runtime, it provides a convenient way to tell mypy something without the code being evaluated at runtime. This is most useful for resolving <code>import cycles</code>.</p>"},{"location":"mypy/annotation_issue_at_runtime/#\u7c7b\u540d\u524d\u7f6e\u5f15\u7528","title":"\u7c7b\u540d\u524d\u7f6e\u5f15\u7528","text":"\u4e2d\u6587\u82f1\u6587 <p>Python \u4e0d\u5141\u8bb8\u5728\u5b9a\u4e49\u7c7b\u4e4b\u524d\u5f15\u7528\u7c7b\u5bf9\u8c61\uff08\u4e5f\u79f0\u4e3a\u524d\u5411\u5f15\u7528\uff09\u3002 \u56e0\u6b64\u8fd9\u6bb5\u4ee3\u7801\u4e0d\u80fd\u6309\u9884\u671f\u5de5\u4f5c\uff1a</p> <pre><code>def f(x: A) -&gt; None: ...  # NameError: name \"A\" is not defined\nclass A: ...\n</code></pre> <p>\u4ece Python 3.7 \u5f00\u59cb\uff0c\u60a8\u53ef\u4ee5\u6dfb\u52a0 <code>from __future__ import annotations</code> \u6765\u89e3\u51b3\u6b64\u95ee\u9898\uff0c\u5982\u524d\u6240\u8ff0\uff1a</p> <pre><code>from __future__ import annotations\n\ndef f(x: A) -&gt; None: ...  # OK\nclass A: ...\n</code></pre> <p>\u5bf9\u4e8e Python 3.6 \u53ca\u66f4\u4f4e\u7248\u672c\uff0c\u60a8\u53ef\u4ee5\u5c06\u7c7b\u578b\u8f93\u5165\u4e3a\u5b57\u7b26\u4e32\u6587\u5b57\u6216\u7c7b\u578b\u6ce8\u91ca\uff1a</p> <pre><code>def f(x: 'A') -&gt; None: ...  # OK\n\n# Also OK\ndef g(x):  # type: (A) -&gt; None\n    ...\n\nclass A: ...\n</code></pre> <p>\u5f53\u7136\uff0c\u60a8\u53ef\u4ee5\u5c06\u51fd\u6570\u5b9a\u4e49\u79fb\u5230\u7c7b\u5b9a\u4e49\u4e4b\u540e\uff0c\u800c\u4e0d\u662f\u4f7f\u7528\u5c06\u6765\u7684\u6ce8\u91ca\u5bfc\u5165\u6216\u5b57\u7b26\u4e32\u6587\u5b57\u7c7b\u578b\u3002 \u4f46\u8fd9\u5e76\u4e0d\u603b\u662f\u53ef\u53d6\u7684\uff0c\u751a\u81f3\u662f\u4e0d\u53ef\u80fd\u7684\u3002</p> <p>Class name forward references</p> <p>Python does not allow references to a class object before the class is defined (aka forward reference). Thus this code does not work as expected:</p> <pre><code>def f(x: A) -&gt; None: ...  # NameError: name \"A\" is not defined\nclass A: ...\n</code></pre> <p>Starting from Python 3.7, you can add <code>from __future__ import annotations</code> to resolve this, as discussed earlier:</p> <pre><code>from __future__ import annotations\n\ndef f(x: A) -&gt; None: ...  # OK\nclass A: ...\n</code></pre> <p>For Python 3.6 and below, you can enter the type as a string literal or type comment:</p> <pre><code>def f(x: 'A') -&gt; None: ...  # OK\n\n# Also OK\ndef g(x):  # type: (A) -&gt; None\n    ...\n\nclass A: ...\n</code></pre> <p>Of course, instead of using future annotations import or string literal types, you could move the function definition after the class definition. This is not always desirable or even possible, though.</p>"},{"location":"mypy/annotation_issue_at_runtime/#\u5faa\u73af\u5bfc\u5165","title":"\u5faa\u73af\u5bfc\u5165","text":"\u4e2d\u6587\u82f1\u6587 <p>\u5f53\u6a21\u5757 A \u5bfc\u5165\u6a21\u5757 B \u5e76\u4e14\u6a21\u5757 B \u5bfc\u5165\u6a21\u5757 A\uff08\u53ef\u80fd\u662f\u95f4\u63a5\u7684\uff0c\u4f8b\u5982 <code>A -&gt; B -&gt; C -&gt; A</code>\uff09\u65f6\uff0c\u4f1a\u53d1\u751f\u5bfc\u5165\u5faa\u73af\u3002 \u6709\u65f6\uff0c\u4e3a\u4e86\u6dfb\u52a0\u7c7b\u578b\u6ce8\u91ca\uff0c\u60a8\u5fc5\u987b\u5411\u6a21\u5757\u6dfb\u52a0\u989d\u5916\u7684\u5bfc\u5165\uff0c\u800c\u8fd9\u4e9b\u5bfc\u5165\u4f1a\u5bfc\u81f4\u4ee5\u524d\u4e0d\u5b58\u5728\u7684\u5faa\u73af\u3002 \u8fd9\u53ef\u80fd\u4f1a\u5bfc\u81f4\u8fd0\u884c\u65f6\u51fa\u73b0\u9519\u8bef\uff0c\u4f8b\u5982\uff1a</p> <pre><code>ImportError: cannot import name 'b' from partially initialized module 'A' (most likely due to a circular import)\n</code></pre> <p>\u5982\u679c\u8fd9\u4e9b\u5faa\u73af\u5728\u8fd0\u884c\u7a0b\u5e8f\u65f6\u786e\u5b9e\u6210\u4e3a\u95ee\u9898\uff0c\u90a3\u4e48\u6709\u4e00\u4e2a\u6280\u5de7\uff1a\u5982\u679c\u4ec5\u7c7b\u578b\u6ce8\u91ca\u9700\u8981\u5bfc\u5165\u5e76\u4e14\u60a8\u6b63\u5728\u4f7f\u7528 a) <code>future comments import</code>\uff0c\u6216 b) \u76f8\u5173\u6ce8\u91ca\u7684\u5b57\u7b26\u4e32\u6587\u5b57\u6216\u7c7b\u578b\u6ce8\u91ca\uff0c\u60a8\u53ef\u4ee5\u5c06\u5bfc\u5165\u5199\u5165 <code>if TYPE_CHECKING:</code> \u4e2d\uff0c\u8fd9\u6837\u5b83\u4eec\u5c31\u4e0d\u4f1a\u5728\u8fd0\u884c\u65f6\u6267\u884c\u3002 \u4f8b\u5b50\uff1a</p> <p>\u6587\u4ef6 <code>foo.py</code>:</p> <pre><code>from typing import TYPE_CHECKING\n\nif TYPE_CHECKING:\n    import bar\n\ndef listify(arg: 'bar.BarClass') -&gt; 'list[bar.BarClass]':\n    return [arg]\n</code></pre> <p>\u6587\u4ef6 <code>bar.py</code>:</p> <pre><code>from foo import listify\n\nclass BarClass:\n    def listifyme(self) -&gt; 'list[BarClass]':\n        return listify(self)\n</code></pre> <p>Import cycles</p> <p>An import cycle occurs where module A imports module B and module B imports module A (perhaps indirectly, e.g. <code>A -&gt; B -&gt; C -&gt; A</code>). Sometimes in order to add type annotations you have to add extra imports to a module and those imports cause cycles that didn't exist before. This can lead to errors at runtime like:</p> <pre><code>ImportError: cannot import name 'b' from partially initialized module 'A' (most likely due to a circular import)\n</code></pre> <p>If those cycles do become a problem when running your program, there's a trick: if the import is only needed for type annotations and you're using a) the <code>future annotations import</code>, or b) string literals or type comments for the relevant annotations, you can write the imports inside <code>if TYPE_CHECKING:</code> so that they are not executed at runtime. Example:</p> <p>File <code>foo.py</code>:</p> <pre><code>from typing import TYPE_CHECKING\n\nif TYPE_CHECKING:\n    import bar\n\ndef listify(arg: 'bar.BarClass') -&gt; 'list[bar.BarClass]':\n    return [arg]\n</code></pre> <p>File <code>bar.py</code>:</p> <pre><code>from foo import listify\n\nclass BarClass:\n    def listifyme(self) -&gt; 'list[BarClass]':\n        return listify(self)\n</code></pre>"},{"location":"mypy/annotation_issue_at_runtime/#\u4f7f\u7528\u5b58\u6839\u4e2d\u7684\u6cdb\u578b\u7c7b\u4f46\u8fd0\u884c\u65f6\u4e0d\u7528","title":"\u4f7f\u7528\u5b58\u6839\u4e2d\u7684\u6cdb\u578b\u7c7b\uff0c\u4f46\u8fd0\u884c\u65f6\u4e0d\u7528","text":"\u4e2d\u6587\u82f1\u6587 <p>\u6709\u4e9b\u7c7b\u5728\u5b58\u6839\u4e2d\u58f0\u660e\u4e3a <code>generic</code>\uff0c\u4f46\u4e0d\u662f\u5728\u8fd0\u884c\u65f6\u58f0\u660e\u3002</p> <p>\u5728 Python 3.8 \u53ca\u66f4\u65e9\u7248\u672c\u4e2d\uff0c\u6807\u51c6\u5e93\u4e2d\u6709\u51e0\u4e2a\u793a\u4f8b\uff0c\u4f8b\u5982 <code>os.PathLike</code> \u548c  <code>queue.Queue</code>\u3002 \u4e3a\u8fd9\u6837\u7684\u7c7b\u6dfb\u52a0\u4e0b\u6807\u5c06\u5bfc\u81f4\u8fd0\u884c\u65f6\u9519\u8bef\uff1a</p> <pre><code>from queue import Queue\n\nclass Tasks(Queue[str]):  # TypeError: 'type' object is not subscriptable\n    ...\n\nresults: Queue[int] = Queue()  # TypeError: 'type' object is not subscriptable\n</code></pre> <p>\u4e3a\u4e86\u907f\u514d\u5728\u6ce8\u91ca\u4e2d\u4f7f\u7528\u8fd9\u4e9b\u6cdb\u578b\u800c\u4ea7\u751f\u9519\u8bef\uff0c\u53ea\u9700\u4f7f\u7528 <code>future comments import</code> \uff08\u6216\u5b57\u7b26\u4e32\u6587\u5b57\u6216\u7c7b\u578b Python 3.6 \u53ca\u4ee5\u4e0b\u7248\u672c\u7684\u6ce8\u91ca\uff09\u3002</p> <p>\u4e3a\u4e86\u907f\u514d\u4ece\u8fd9\u4e9b\u7c7b\u7ee7\u627f\u65f6\u51fa\u73b0\u9519\u8bef\uff0c\u4e8b\u60c5\u4f1a\u7a0d\u5fae\u590d\u6742\u4e00\u4e9b\uff0c\u60a8\u9700\u8981\u4f7f\u7528 [<code>typing.TYPE_CHECKING</code>](https://mypy.readthedocs.io/en/latest/runtime_troubles.html#typing-type- \u68c0\u67e5\uff09\uff1a</p> <pre><code>from typing import TYPE_CHECKING\nfrom queue import Queue\n\nif TYPE_CHECKING:\n    BaseQueue = Queue[str]  # this is only processed by mypy\nelse:\n    BaseQueue = Queue  # this is not seen by mypy but will be executed at runtime\n\nclass Tasks(BaseQueue):  # OK\n    ...\n\ntask_queue: Tasks\nreveal_type(task_queue.get())  # Reveals str\n</code></pre> <p>\u5982\u679c\u60a8\u7684\u5b50\u7c7b\u4e5f\u662f\u901a\u7528\u7684\uff0c\u60a8\u53ef\u4ee5\u4f7f\u7528\u4ee5\u4e0b\u5185\u5bb9\uff1a</p> <pre><code>from typing import TYPE_CHECKING, TypeVar, Generic\nfrom queue import Queue\n\n_T = TypeVar(\"_T\")\nif TYPE_CHECKING:\n    class _MyQueueBase(Queue[_T]): pass\nelse:\n    class _MyQueueBase(Generic[_T], Queue): pass\n\nclass MyQueue(_MyQueueBase[_T]): pass\n\ntask_queue: MyQueue[str]\nreveal_type(task_queue.get())  # Reveals str\n</code></pre> <p>\u5728Python 3.9\u4e2d\uff0c\u6211\u4eec\u53ef\u4ee5\u76f4\u63a5\u7ee7\u627f<code>Queue[str]</code>\u6216<code>Queue[T]</code>\uff0c\u56e0\u4e3a\u5b83\u7684[<code>queue.Queue</code>](https://docs.python.org/3/library/queue.html#queue.Queue \u5b9e\u73b0\u4e86 <code>__class_getitem__</code>\uff0c\u56e0\u6b64\u7c7b\u5bf9\u8c61\u53ef\u4ee5\u5728\u8fd0\u884c\u65f6\u4f7f\u7528\u4e0b\u6807\u800c\u4e0d\u4f1a\u51fa\u73b0\u95ee\u9898\u3002</p> <p>Using classes that are generic in stubs but not at runtime</p> <p>Some classes are declared as <code>generic</code> in stubs, but not at runtime.</p> <p>In Python 3.8 and earlier, there are several examples within the standard library, for instance, <code>os.PathLike</code> and <code>queue.Queue</code>. Subscripting such a class will result in a runtime error:</p> <pre><code>from queue import Queue\n\nclass Tasks(Queue[str]):  # TypeError: 'type' object is not subscriptable\n    ...\n\nresults: Queue[int] = Queue()  # TypeError: 'type' object is not subscriptable\n</code></pre> <p>To avoid errors from use of these generics in annotations, just use the <code>future annotations import</code> (or string literals or type comments for Python 3.6 and below).</p> <p>To avoid errors when inheriting from these classes, things are a little more complicated and you need to use <code>typing.TYPE_CHECKING</code>:</p> <pre><code>from typing import TYPE_CHECKING\nfrom queue import Queue\n\nif TYPE_CHECKING:\n    BaseQueue = Queue[str]  # this is only processed by mypy\nelse:\n    BaseQueue = Queue  # this is not seen by mypy but will be executed at runtime\n\nclass Tasks(BaseQueue):  # OK\n    ...\n\ntask_queue: Tasks\nreveal_type(task_queue.get())  # Reveals str\n</code></pre> <p>If your subclass is also generic, you can use the following:</p> <pre><code>from typing import TYPE_CHECKING, TypeVar, Generic\nfrom queue import Queue\n\n_T = TypeVar(\"_T\")\nif TYPE_CHECKING:\n    class _MyQueueBase(Queue[_T]): pass\nelse:\n    class _MyQueueBase(Generic[_T], Queue): pass\n\nclass MyQueue(_MyQueueBase[_T]): pass\n\ntask_queue: MyQueue[str]\nreveal_type(task_queue.get())  # Reveals str\n</code></pre> <p>In Python 3.9, we can just inherit directly from <code>Queue[str]</code> or <code>Queue[T]</code> since its [<code>queue.Queue</code>](https://docs.python.org/3/library/queue.html#queue.Queue implements {py:meth}<code>__class_getitem__</code>, so the class object can be subscripted at runtime without issue.</p>"},{"location":"mypy/annotation_issue_at_runtime/#\u4f7f\u7528\u5b58\u6839\u4e2d\u5b9a\u4e49\u7684\u7c7b\u578b\u4f46\u4e0d\u5728\u8fd0\u884c\u65f6\u4f7f\u7528","title":"\u4f7f\u7528\u5b58\u6839\u4e2d\u5b9a\u4e49\u7684\u7c7b\u578b\uff0c\u4f46\u4e0d\u5728\u8fd0\u884c\u65f6\u4f7f\u7528","text":"\u4e2d\u6587\u82f1\u6587 <p>\u6709\u65f6\uff0c\u60a8\u6b63\u5728\u4f7f\u7528\u7684\u5b58\u6839\u53ef\u80fd\u4f1a\u5b9a\u4e49\u60a8\u5e0c\u671b\u91cd\u7528\u7684\u7c7b\u578b\uff0c\u4f46\u8fd9\u4e9b\u7c7b\u578b\u5728\u8fd0\u884c\u65f6\u5e76\u4e0d\u5b58\u5728\u3002 \u5929\u771f\u5730\u5bfc\u5165\u8fd9\u4e9b\u7c7b\u578b\u5c06\u5bfc\u81f4\u60a8\u7684\u4ee3\u7801\u5728\u8fd0\u884c\u65f6\u5931\u8d25\uff0c\u5e76\u51fa\u73b0\u201cImportError\u201d\u6216\u201cModuleNotFoundError\u201d\u3002 \u4e0e\u524d\u9762\u7684\u90e8\u5206\u7c7b\u4f3c\uff0c\u8fd9\u4e9b\u53ef\u4ee5\u901a\u8fc7\u4f7f\u7528 <code>typing.TYPE_CHECKING</code> \u6765\u5904\u7406\uff1a</p> <pre><code>from __future__ import annotations\nfrom typing import TYPE_CHECKING\nif TYPE_CHECKING:\n    from _typeshed import SupportsRichComparison\n\ndef f(x: SupportsRichComparison) -&gt; None\n</code></pre> <p>\u4f7f\u7528\u5bfc\u5165\u7b26\u53f7\u65f6\u9700\u8981\u4f7f\u7528 \u201cfrom future import annotations\u201d \u4ee5\u907f\u514d\u51fa\u73b0 \u201cNameError\u201d\u3002 \u6709\u5173\u66f4\u591a\u4fe1\u606f\u548c\u6ce8\u610f\u4e8b\u9879\uff0c\u8bf7\u53c2\u9605\u6709\u5173<code>future annotations</code>\u7684\u90e8\u5206\u3002</p> <p>Using types defined in stubs but not at runtime</p> <p>Sometimes stubs that you're using may define types you wish to re-use that do not exist at runtime. Importing these types naively will cause your code to fail at runtime with <code>ImportError</code> or <code>ModuleNotFoundError</code>. Similar to previous sections, these can be dealt with by using <code>typing.TYPE_CHECKING</code>:</p> <pre><code>from __future__ import annotations\nfrom typing import TYPE_CHECKING\nif TYPE_CHECKING:\n    from _typeshed import SupportsRichComparison\n\ndef f(x: SupportsRichComparison) -&gt; None\n</code></pre> <p>The <code>from __future__ import annotations</code> is required to avoid a <code>NameError</code> when using the imported symbol. For more information and caveats, see the section on <code>future annotations</code>.</p>"},{"location":"mypy/annotation_issue_at_runtime/#\u4f7f\u7528\u5185\u7f6e\u7684\u6cdb\u578b","title":"\u4f7f\u7528\u5185\u7f6e\u7684\u6cdb\u578b","text":"\u4e2d\u6587\u82f1\u6587 <p>\u4ecePython 3.9\uff08<code>585</code>\uff09\u5f00\u59cb\uff0c\u6807\u51c6\u5e93\u4e2d\u8bb8\u591a\u96c6\u5408\u7684\u7c7b\u578b\u5bf9\u8c61\u652f\u6301\u8fd0\u884c\u65f6\u8ba2\u9605\u3002 \u8fd9\u610f\u5473\u7740\u60a8\u4e0d\u518d\u9700\u8981\u4ece <code>typing</code> \u5bfc\u5165\u7b49\u6548\u9879\uff1b \u60a8\u53ef\u4ee5\u7b80\u5355\u5730\u4f7f\u7528\u5185\u7f6e\u96c6\u5408\u6216\u6765\u81ea <code>collections.abc</code> \u7684\u96c6\u5408\uff1a</p> <pre><code>from collections.abc import Sequence\nx: list[str]\ny: dict[int, str]\nz: Sequence[str] = x\n</code></pre> <p>Python 3.7 \u53ca\u66f4\u9ad8\u7248\u672c\u4e2d\u5bf9\u4f7f\u7528\u6b64\u8bed\u6cd5\u7684\u652f\u6301\u4e5f\u5f88\u6709\u9650\uff1a\u5982\u679c\u60a8\u4f7f\u7528 \u201cfrom future import annotations\u201d\uff0cmypy \u5c06\u5728\u6ce8\u91ca\u4e2d\u7406\u89e3\u6b64\u8bed\u6cd5\u3002 \u4f46\u662f\uff0c\u7531\u4e8e Python \u89e3\u91ca\u5668\u5728\u8fd0\u884c\u65f6\u4e0d\u652f\u6301\u6b64\u529f\u80fd\uff0c\u56e0\u6b64\u8bf7\u786e\u4fdd\u60a8\u4e86\u89e3 <code>future comments import</code> \u6ce8\u91ca\u4e2d\u63d0\u5230\u7684\u6ce8\u610f\u4e8b\u9879 en/latest/runtime_troubles.html#future-annotations\uff09\u3002</p> <p>Using generic builtins</p> <p>Starting with Python 3.9 (<code>585</code>), the type objects of many collections in the standard library support subscription at runtime. This means that you no longer have to import the equivalents from <code>typing</code>; you can simply use the built-in collections or those from <code>collections.abc</code>:</p> <pre><code>from collections.abc import Sequence\nx: list[str]\ny: dict[int, str]\nz: Sequence[str] = x\n</code></pre> <p>There is limited support for using this syntax in Python 3.7 and later as well: if you use <code>from __future__ import annotations</code>, mypy will understand this syntax in annotations. However, since this will not be supported by the Python interpreter at runtime, make sure you're aware of the caveats mentioned in the notes at {ref} <code>future annotations import</code>.</p>"},{"location":"mypy/annotation_issue_at_runtime/#\u4f7f\u7528union\u7684-x--y-\u8bed\u6cd5","title":"\u4f7f\u7528Union\u7684 X | Y \u8bed\u6cd5","text":"\u4e2d\u6587\u82f1\u6587 <p>\u4ece Python 3.10 <code>PEP 604</code> \u5f00\u59cb\uff0c\u60a8\u53ef\u4ee5\u5c06\u8054\u5408\u7c7b\u578b\u62fc\u5199\u4e3a <code>x: int | str</code>\uff0c\u800c\u4e0d\u662f<code>x:typing.Union[int, str]</code>\u3002</p> <p>Python 3.7 \u53ca\u66f4\u9ad8\u7248\u672c\u4e2d\u5bf9\u4f7f\u7528\u6b64\u8bed\u6cd5\u7684\u652f\u6301\u4e5f\u5f88\u6709\u9650\uff1a\u5982\u679c\u60a8\u4f7f\u7528\u201cfrom future import annotations\u201d\uff0cmypy \u5c06\u5728\u6ce8\u91ca\u3001\u5b57\u7b26\u4e32\u6587\u5b57\u7c7b\u578b\u3001\u7c7b\u578b\u6ce8\u91ca\u548c\u5b58\u6839\u6587\u4ef6\u4e2d\u7406\u89e3\u6b64\u8bed\u6cd5\u3002 \u4f46\u662f\uff0c\u7531\u4e8e Python \u89e3\u91ca\u5668\u5728\u8fd0\u884c\u65f6\u4e0d\u652f\u6301\u8fd9\u4e00\u70b9\uff08\u5982\u679c\u8ba1\u7b97\uff0c<code>int | str</code> \u5c06\u5f15\u53d1 <code>TypeError: unsupported operand type(s) for |: 'type' and 'type'</code>\uff09\uff0c\u8bf7\u786e\u4fdd \u4e86\u89e3 <code>future \u6ce8\u91ca import&lt;future-annotations&gt;</code> \u7684\u6ce8\u91ca\u4e2d\u63d0\u5230\u7684\u8b66\u544a\u3002</p> <p>Using X | Y syntax for Unions</p> <p>Starting with Python 3.10 <code>PEP 604</code>, you can spell union types as <code>x: int | str</code>, instead of <code>x: typing.Union[int, str]</code>.</p> <p>There is limited support for using this syntax in Python 3.7 and later as well: if you use <code>from __future__ import annotations</code>, mypy will understand this syntax in annotations, string literal types, type comments and stub files. However, since this will not be supported by the Python interpreter at runtime (if evaluated, <code>int | str</code> will raise <code>TypeError: unsupported operand type(s) for |: 'type' and 'type'</code>), make sure you're aware of the caveats mentioned in the notes at <code>future annotations import&lt;future-annotations&gt;</code>.</p>"},{"location":"mypy/annotation_issue_at_runtime/#\u4f7f\u7528typing\u6a21\u5757\u7684\u65b0\u529f\u80fd","title":"\u4f7f\u7528typing\u6a21\u5757\u7684\u65b0\u529f\u80fd","text":"\u4e2d\u6587\u82f1\u6587 <p>\u60a8\u53ef\u80fd\u4f1a\u53d1\u73b0\u81ea\u5df1\u60f3\u8981\u4f7f\u7528\u65e9\u671f\u7248\u672c\u7684 Python \u4e2d\u6dfb\u52a0\u5230 <code>typing</code> \u6a21\u5757\u7684\u529f\u80fd\uff0c\u4f8b\u5982\uff0c\u5728 Python 3.6 \u4e2d\u4f7f\u7528 <code>Literal</code>\u3001<code>Protocol</code>\u3001<code>TypedDict</code> \u4e2d\u7684\u4efb\u4f55\u4e00\u4e2a\u3002</p> <p>\u6700\u7b80\u5355\u7684\u65b9\u6cd5\u662f\u5b89\u88c5\u5e76\u4f7f\u7528 PyPI \u4e2d\u7684 typing_extensions \u5305\u8fdb\u884c\u76f8\u5173\u5bfc\u5165\uff0c\u4f8b\u5982\uff1a</p> <pre><code>from typing_extensions import Literal\nx: Literal[\"open\", \"close\"]\n</code></pre> <p>\u5982\u679c\u60a8\u4e0d\u60f3\u4f9d\u8d56\u5728\u8f83\u65b0\u7684 Python \u4e0a\u5b89\u88c5\u7684 <code>typing_extensions</code>\uff0c\u60a8\u4e5f\u53ef\u4ee5\u4f7f\u7528\uff1a</p> <pre><code>import sys\nif sys.version_info &gt;= (3, 8):\n    from typing import Literal\nelse:\n    from typing_extensions import Literal\n\nx: Literal[\"open\", \"close\"]\n</code></pre> <p>\u8fd9\u4e0e\u4ee5\u4e0b <code>PEP 508</code> \u4f9d\u8d56\u9879\u89c4\u8303\u914d\u5408\u5f97\u5f88\u597d\uff1a<code>typing_extensions; python_version &lt;\u201c3.8\u201d</code></p> <p>Using new additions to the typing module</p> <p>You may find yourself wanting to use features added to the {py:mod}<code>typing</code> module in earlier versions of Python than the addition, for example, using any of <code>Literal</code>, <code>Protocol</code>, <code>TypedDict</code> with Python 3.6.</p> <p>The easiest way to do this is to install and use the <code>typing_extensions</code> package from PyPI for the relevant imports, for example:</p> <pre><code>from typing_extensions import Literal\nx: Literal[\"open\", \"close\"]\n</code></pre> <p>If you don't want to rely on <code>typing_extensions</code> being installed on newer Pythons, you could alternatively use:</p> <pre><code>import sys\nif sys.version_info &gt;= (3, 8):\n    from typing import Literal\nelse:\n    from typing_extensions import Literal\n\nx: Literal[\"open\", \"close\"]\n</code></pre> <p>This plays nicely well with following <code>PEP 508</code> dependency specification: <code>typing_extensions; python_version&lt;\"3.8\"</code></p>"},{"location":"mypy/builtin_types/","title":"\u5185\u7f6e\u7c7b\u578b","text":"\u4e2d\u6587\u82f1\u6587 <p>\u672c\u7ae0\u4ecb\u7ecd\u4e00\u4e9b\u5e38\u7528\u7684\u5185\u7f6e\u7c7b\u578b\u3002 \u7a0d\u540e\u6211\u4eec\u5c06\u4ecb\u7ecd\u8bb8\u591a\u5176\u4ed6\u7c7b\u578b\u3002</p> <p>Built-in types</p> <p>This chapter introduces some commonly used built-in types. We will cover many other kinds of types later.</p>"},{"location":"mypy/builtin_types/#\u7b80\u5355\u7c7b\u578b","title":"\u7b80\u5355\u7c7b\u578b","text":"\u4e2d\u6587\u82f1\u6587 <p>\u4ee5\u4e0b\u662f\u4e00\u4e9b\u5e38\u89c1\u5185\u7f6e\u7c7b\u578b\u7684\u793a\u4f8b\uff1a</p> \u7c7b\u578b \u63cf\u8ff0 <code>int</code> \u6574\u6570 <code>float</code> \u6d6e\u70b9\u6570 <code>bool</code> \u5e03\u5c14\u503c\uff08<code>int</code>\u7684\u5b50\u7c7b\uff09 <code>str</code> \u6587\u672c\uff0cunicode \u4ee3\u7801\u70b9\u5e8f\u5217 <code>bytes</code> 8 \u4f4d\u5b57\u7b26\u4e32\uff0c\u5b57\u8282\u503c\u5e8f\u5217 <code>object</code> \u4efb\u610f\u5bf9\u8c61\uff08object\u662f\u516c\u5171\u57fa\u7c7b\uff09 <p>\u6240\u6709\u5185\u7f6e\u7c7b\u90fd\u53ef\u4ee5\u7528\u4f5c\u7c7b\u578b\u3002</p> <p>Simple types</p> <p>Here are examples of some common built-in types:</p> Type Description <code>int</code> integer <code>float</code> floating point number <code>bool</code> boolean value (subclass of <code>int</code>) <code>str</code> text, sequence of unicode codepoints <code>bytes</code> 8-bit string, sequence of byte values <code>object</code> an arbitrary object (object is the common base class) <p>All built-in classes can be used as types.</p> Type Description aaa bbb aaa bbb aaa bbb aaa bbb aaa bbb"},{"location":"mypy/builtin_types/#any-type","title":"Any type","text":"\u4e2d\u6587\u82f1\u6587 <p>\u5982\u679c\u4f60\u627e\u4e0d\u5230\u67d0\u4e2a\u503c\u7684\u5408\u9002\u7c7b\u578b\uff0c\u4f60\u53ef\u4ee5\u968f\u65f6\u56de\u9000\u5230 Any\uff1a</p> Type Description <code>Any</code> \u4efb\u610f\u7c7b\u578b\u7684\u52a8\u6001\u7c7b\u578b\u503c <p>Any \u7c7b\u578b\u5728 typing \u6a21\u5757\u4e2d\u5b9a\u4e49\u3002 \u6709\u5173\u66f4\u591a\u8be6\u7ec6\u4fe1\u606f\uff0c\u8bf7\u53c2\u9605\u52a8\u6001\u7c7b\u578b\u4ee3\u7801\u3002</p> <p>Any type</p> <p>If you can\u2019t find a good type for some value, you can always fall back to Any:</p> Type Description <code>Any</code> dynamically typed value with an arbitrary type <p>The type Any is defined in the typing module. See Dynamically typed code for more details.</p>"},{"location":"mypy/builtin_types/#\u8303\u578b\u7c7b\u578b","title":"\u8303\u578b\u7c7b\u578b","text":"\u4e2d\u6587\u82f1\u6587 <p>\u5728Python 3.9\u53ca\u66f4\u9ad8\u7248\u672c\u4e2d\uff0c\u5185\u7f6e\u96c6\u5408\u7c7b\u578b\u5bf9\u8c61\u652f\u6301\u7d22\u5f15\uff1a</p> \u7c7b\u578b \u63cf\u8ff0 <code>list[str]</code> <code>str</code> \u5bf9\u8c61\u5217\u8868 <code>tuple[int, int]</code> \u4e24\u4e2a <code>int</code> \u5bf9\u8c61\u7684\u5143\u7ec4\uff08<code>tuple[()]</code> \u662f\u7a7a\u5143\u7ec4\uff09 <code>tuple[int, ...]</code> \u4efb\u610f\u6570\u91cf\u7684 <code>int</code> \u5bf9\u8c61\u7684\u5143\u7ec4 <code>dict[str, int]</code> \u5b57\u5178\u4ece str \u952e\u5230 <code>int</code> \u503c <code>Iterable[int]</code> \u5305\u542b\u6574\u6570\u7684\u53ef\u8fed\u4ee3\u5bf9\u8c61 <code>Sequence[bool]</code> \u5e03\u5c14\u503c\u5e8f\u5217\uff08\u53ea\u8bfb\uff09 <code>Mapping[str, int]</code> \u4ece str \u952e\u5230 int \u503c\u7684\u6620\u5c04\uff08\u53ea\u8bfb\uff09 <code>type[C]</code> <code>C</code> \u7684\u7c7b\u578b\u5bf9\u8c61\uff08<code>C</code> \u662f\u7c7b/\u7c7b\u578b\u53d8\u91cf/\u7c7b\u578b\u8054\u5408\uff09 <p>\u7c7b\u578b <code>dict</code> \u662f\u4e00\u4e2a\u6cdb\u578b\u7c7b\uff0c\u7531 <code>[...]</code> \u4e2d\u7684\u7c7b\u578b\u53c2\u6570\u8868\u793a\u3002 \u4f8b\u5982\uff0c<code>dict[int, str]</code> \u662f\u4ece\u6574\u6570\u5230\u5b57\u7b26\u4e32\u7684\u5b57\u5178\uff0c<code>dict[Any, Any]</code> \u662f\u52a8\u6001\u7c7b\u578b\uff08\u4efb\u610f\uff09\u503c\u548c\u952e\u7684\u5b57\u5178\u3002 <code>list</code> \u662f\u53e6\u4e00\u4e2a\u6cdb\u578b\u7c7b\u3002</p> <p><code>Iterable</code>\u3001<code>Sequence</code> \u548c <code>Mapping</code> \u662f\u4e0e Python \u534f\u8bae\u76f8\u5bf9\u5e94\u7684\u6cdb\u578b\u7c7b\u578b\u3002 \u4f8b\u5982\uff0c\u5f53\u9700\u8981<code>Iterable[str]</code>\u6216<code>Sequence[str]</code>\u65f6\uff0c<code>str</code>\u5bf9\u8c61\u6216<code>list[str]</code>\u5bf9\u8c61\u662f\u6709\u6548\u7684\u3002 \u60a8\u53ef\u4ee5\u4ece <code>collections.abc</code> \u5bfc\u5165\uff0c\u800c\u4e0d\u662f\u4ece Python 3.9 \u4e2d\u7684 <code>typing</code>\u5bfc\u5165\u5b83\u4eec\u3002</p> <p>\u6709\u5173\u66f4\u591a\u8be6\u7ec6\u4fe1\u606f\uff0c\u8bf7\u53c2\u9605 <code>generic-builtins</code>\uff0c\u5305\u62ec\u5982\u4f55\u5728 Python 3.7 \u548c 3.8 \u4e2d\u7684\u6ce8\u91ca\u4e2d\u4f7f\u7528\u5b83\u4eec\u3002</p> <p>\u5982\u679c\u60a8\u9700\u8981\u652f\u6301 Python 3.8 \u53ca\u66f4\u65e9\u7248\u672c\uff0c\u5219\u9700\u8981 <code>typing</code> \u4e2d\u5b9a\u4e49\u7684\u8fd9\u4e9b\u65e7\u7c7b\u578b\uff1a</p> \u7c7b\u578b \u63cf\u8ff0 <code>List[str]</code> <code>str</code> \u5bf9\u8c61\u5217\u8868 <code>Tuple[int, int]</code> \u4e24\u4e2a <code>int</code> \u5bf9\u8c61\u7684\u5143\u7ec4\uff08<code>tuple[()]</code> \u662f\u7a7a\u5143\u7ec4\uff09 <code>Tuple[int, ...]</code> \u4efb\u610f\u6570\u91cf\u7684 <code>int</code> \u5bf9\u8c61\u7684\u5143\u7ec4 <code>Dict[str, int]</code> \u5b57\u5178\u4ece str \u952e\u5230 <code>int</code> \u503c <code>Iterable[int]</code> \u5305\u542b\u6574\u6570\u7684\u53ef\u8fed\u4ee3\u5bf9\u8c61 <code>Sequence[bool]</code> \u5e03\u5c14\u503c\u5e8f\u5217\uff08\u53ea\u8bfb\uff09 <code>Mapping[str, int]</code> \u4ece str \u952e\u5230 int \u503c\u7684\u6620\u5c04\uff08\u53ea\u8bfb\uff09 <code>Type[C]</code> <code>C</code> \u7684\u7c7b\u578b\u5bf9\u8c61\uff08<code>C</code> \u662f\u7c7b/\u7c7b\u578b\u53d8\u91cf/\u7c7b\u578b\u8054\u5408\uff09 <p><code>List</code> \u662f\u652f\u6301\u7d22\u5f15\u7684\u5185\u7f6e\u7c7b\u578b <code>list</code> \u7684\u522b\u540d (<code>dict</code>/<code>Dict</code> \u548c <code>tuple</code>/<code>Tuple</code> \u4e5f\u90fd\u662f\u7c7b\u4f3c\u7684).</p> <p>\u8bf7\u6ce8\u610f\uff0c\u5c3d\u7ba1 <code>Iterable</code>\u3001<code>Sequence</code> \u548c <code>Mapping</code> \u770b\u8d77\u6765\u4e0e <code>collections.abc</code>\uff08\u4ee5\u524d\u7684 <code>collections</code>\uff09\u4e2d\u5b9a\u4e49\u7684\u62bd\u8c61\u57fa\u7c7b\u7c7b\u4f3c\uff0c\u4f46\u5b83\u4eec\u5e76\u4e0d\u76f8\u540c\uff0c\u56e0\u4e3a\u540e\u8005\u4e0d\u652f\u6301\u7d22\u5f15 Python 3.9 \u4e4b\u524d\u7684\u7248\u672c\u3002</p> <p>Generic types</p> <p>In Python 3.9 and later, built-in collection type objects support indexing:</p> Type Description <code>list[str]</code> list of <code>str</code> objects <code>tuple[int, int]</code> tuple of two int objects (<code>tuple[()]</code> is the empty tuple) <code>tuple[int, ...]</code> tuple of an arbitrary number of <code>int</code> objects <code>dict[str, int]</code> dictionary from str keys to <code>int</code> values <code>Iterable[int]</code> iterable object containing ints <code>Sequence[bool]</code> sequence of booleans (read-only) <code>Mapping[str, int]</code> mapping from str keys to int values (read-only) <code>type[C]</code> type object of <code>C</code> (<code>C</code> is a class/type variable/union of types) <p>The type <code>dict</code> is a generic class, signified by type arguments within <code>[...]</code>. For example, <code>dict[int, str]</code> is a dictionary from integers to strings and <code>dict[Any, Any]</code> is a dictionary of dynamically typed (arbitrary) values and keys. <code>list</code> is another generic class.</p> <p><code>Iterable</code>, <code>Sequence</code>, and <code>Mapping</code> are generic types that correspond to Python protocols. For example, a <code>str</code> object or a <code>list[str]</code> object is valid when <code>Iterable[str]</code> or <code>Sequence[str]</code> is expected. You can import them from <code>collections.abc</code> instead of importing from <code>typing</code> in Python 3.9.</p> <p>See <code>generic-builtins</code> for more details, including how you can use these in annotations also in Python 3.7 and 3.8.</p> <p>These legacy types defined in <code>typing</code> are needed if you need to support Python 3.8 and earlier:</p> Type Description <code>List[str]</code> list of <code>str</code> objects <code>Tuple[int, int]</code> tuple of two <code>int</code> objects (<code>Tuple[()]</code> is the empty tuple) <code>Tuple[int, ...]</code> tuple of an arbitrary number of <code>int</code> objects <code>Dict[str, int]</code> dictionary from <code>str</code> keys to <code>int</code> values <code>Iterable[int]</code> iterable object containing ints <code>Sequence[bool]</code> sequence of booleans (read-only) <code>Mapping[str, int]</code> mapping from <code>str</code> keys to <code>int</code> values (read-only) <code>Type[C]</code> type object of <code>C</code> (<code>C</code> is a class/type variable/union of types) <p><code>List</code> is an alias for the built-in type <code>list</code> that supports indexing (and similarly for <code>dict</code>/<code>Dict</code> and <code>tuple</code>/<code>Tuple</code>).</p> <p>Note that even though <code>Iterable</code>, <code>Sequence</code> and <code>Mapping</code> look similar to abstract base classes defined in <code>collections.abc</code> (formerly <code>collections</code>), they are not identical, since the latter don't support indexing prior to Python 3.9.</p>"},{"location":"mypy/cheat_sheet_py3/","title":"\u7c7b\u578b\u63d0\u793a\u5907\u5fd8\u5f55","text":"<p>Type hints cheat sheet</p> <p>\u8f6c\u81ea: https://mypy.readthedocs.io/en/stable/cheat_sheet_py3.html</p>"},{"location":"mypy/cheat_sheet_py3/#\u53d8\u91cf","title":"\u53d8\u91cf","text":"\u4e2d\u6587\u539f\u6587 <p>\u4ece\u6280\u672f\u4e0a\u8bb2\uff0c\u4e0b\u9762\u663e\u793a\u7684\u8bb8\u591a\u7c7b\u578b\u6ce8\u89e3\u90fd\u662f\u591a\u4f59\u7684\uff0c\u56e0\u4e3a mypy \u901a\u5e38\u53ef\u4ee5\u4ece\u53d8\u91cf\u7684\u503c\u63a8\u65ad\u51fa\u53d8\u91cf\u7684\u7c7b\u578b\u3002 \u6709\u5173\u66f4\u591a\u8be6\u7ec6\u4fe1\u606f\uff0c\u8bf7\u53c2\u9605\u7c7b\u578b\u63a8\u65ad\u548c\u7c7b\u578b\u6ce8\u89e3\u3002</p> <pre><code># \u8fd9\u662f\u58f0\u660e\u53d8\u91cf\u7c7b\u578b\u7684\u65b9\u5f0f\nage: int = 1\n\n# \u60a8\u4e0d\u9700\u8981\u521d\u59cb\u5316\u53d8\u91cf\u6765\u6ce8\u89e3\u5b83\na: int  # Ok (\u5728\u5206\u914d\u4e4b\u524d\u5728\u8fd0\u884c\u65f6\u6ca1\u6709\u503c)\n\n# \u8fd9\u6837\u505a\u5728\u6761\u4ef6\u5206\u652f\u4e2d\u5f88\u6709\u7528\nchild: bool\nif age &lt; 18:\n    child = True\nelse:\n    child = False\n</code></pre> <p>Variables</p> <p>Technically many of the type annotations shown below are redundant, since mypy can usually infer the type of a variable from its value. See Type inference and type annotations for more details.</p> <pre><code># This is how you declare the type of a variable\nage: int = 1\n\n# You don't need to initialize a variable to annotate it\na: int  # Ok (no value at runtime until assigned)\n\n# Doing so can be useful in conditional branches\nchild: bool\nif age &lt; 18:\n    child = True\nelse:\n    child = False\n</code></pre>"},{"location":"mypy/cheat_sheet_py3/#\u6709\u7528\u7684\u5185\u7f6e\u7c7b\u578b","title":"\u6709\u7528\u7684\u5185\u7f6e\u7c7b\u578b","text":"\u4e2d\u6587\u539f\u6587 <pre><code># \u5bf9\u4e8e\u5927\u591a\u6570\u7c7b\u578b\uff0c\u53ea\u9700\u5728\u6ce8\u89e3\u4e2d\u4f7f\u7528\u7c7b\u578b\u7684\u540d\u79f0, \u8bf7\u6ce8\u610f\uff0cmypy \u901a\u5e38\u53ef\u4ee5\u4ece\u53d8\u91cf\u7684\u503c\u63a8\u65ad\u53d8\u91cf\u7684\u7c7b\u578b\uff0c\u56e0\u6b64\u4ece\u6280\u672f\u4e0a\u8bb2\uff0c\u8fd9\u4e9b\u6ce8\u89e3\u662f\u591a\u4f59\u7684\nx: int = 1\nx: float = 1.0\nx: bool = True\nx: str = \"test\"\nx: bytes = b\"test\"\n\n# \u5bf9\u4e8e Python 3.9+ \u4e0a\u7684\u96c6\u5408\uff0c\u96c6\u5408\u9879\u7684\u7c7b\u578b\u4f4d\u4e8e\u62ec\u53f7\u4e2d\nx: list[int] = [1]\nx: set[int] = {6, 7}\n\n# \u5bf9\u4e8e\u6620\u5c04\uff0c\u6211\u4eec\u9700\u8981\u952e\u548c\u503c\u7684\u7c7b\u578b\nx: dict[str, float] = {\"field\": 2.0}  # Python 3.9+\n\n# \u5bf9\u4e8e\u56fa\u5b9a\u5927\u5c0f\u7684\u5143\u7ec4\uff0c\u6211\u4eec\u6307\u5b9a\u6240\u6709\u5143\u7d20\u7684\u7c7b\u578b\nx: tuple[int, str, float] = (3, \"yes\", 7.5)  # Python 3.9+\n\n# \u5bf9\u4e8e\u53ef\u53d8\u5927\u5c0f\u7684\u5143\u7ec4\uff0c\u6211\u4eec\u4f7f\u7528\u4e00\u79cd\u7c7b\u578b\u548c\u7701\u7565\u53f7\nx: tuple[int, ...] = (1, 2, 3)  # Python 3.9+\n\n# \u5728 Python 3.8 \u53ca\u66f4\u65e9\u7248\u672c\u4e2d\uff0c\u96c6\u5408\u7c7b\u578b\u7684\u540d\u79f0\u5927\u5199\uff0c\u5e76\u4e14\u7c7b\u578b\u662f\u4ece\u201ctyping\u201d\u6a21\u5757\u5bfc\u5165\u7684\nfrom typing import List, Set, Dict, Tuple\nx: List[int] = [1]\nx: Set[int] = {6, 7}\nx: Dict[str, float] = {\"field\": 2.0}\nx: Tuple[int, str, float] = (3, \"yes\", 7.5)\nx: Tuple[int, ...] = (1, 2, 3)\n\nfrom typing import Union, Optional\n\n# \u5728 Python 3.10+ \u4e0a\uff0c\u4f7f\u7528 | \u5f53\u67d0\u503c\u53ef\u80fd\u662f\u51e0\u79cd\u7c7b\u578b\u4e4b\u4e00\u65f6\u7684\u8fd0\u7b97\u7b26\nx: list[int | str] = [3, 5, \"test\", \"fun\"]  # Python 3.10+\n# \u5728\u65e9\u671f\u7248\u672c\u4e2d\uff0c\u4f7f\u7528 Union\nx: list[Union[int, str]] = [3, 5, \"test\", \"fun\"]\n\n# \u4f7f\u7528 Optional[X] \u4f5c\u4e3a\u53ef\u80fd\u4e3aNone\u7684\u503c\n# Optional[X] \u4e0e X | None \u76f8\u540c \u6216 Union[X\uff0cNone]\nx: Optional[str] = \"something\" if some_condition() else None\nif x is not None:\n    # \u7531\u4e8e if \u8bed\u53e5\uff0cMypy \u77e5\u9053 x \u4e0d\u4f1a\u5728\u8fd9\u91cc\u4e3a None\n    print(x.upper())\n# \u5982\u679c\u60a8\u77e5\u9053\u7531\u4e8e mypy \u4e0d\u7406\u89e3\u7684\u67d0\u4e9b\u903b\u8f91\uff0c\u67d0\u4e2a\u503c\u6c38\u8fdc\u4e0d\u53ef\u80fd\u4e3a None\uff0c\u8bf7\u4f7f\u7528\u65ad\u8a00\nassert x is not None\nprint(x.upper())\n</code></pre> <p>Useful built-in types</p> <pre><code># For most types, just use the name of the type in the annotation\n# Note that mypy can usually infer the type of a variable from its value,\n# so technically these annotations are redundant\nx: int = 1\nx: float = 1.0\nx: bool = True\nx: str = \"test\"\nx: bytes = b\"test\"\n\n# For collections on Python 3.9+, the type of the collection item is in brackets\nx: list[int] = [1]\nx: set[int] = {6, 7}\n\n# For mappings, we need the types of both keys and values\nx: dict[str, float] = {\"field\": 2.0}  # Python 3.9+\n\n# For tuples of fixed size, we specify the types of all the elements\nx: tuple[int, str, float] = (3, \"yes\", 7.5)  # Python 3.9+\n\n# For tuples of variable size, we use one type and ellipsis\nx: tuple[int, ...] = (1, 2, 3)  # Python 3.9+\n\n# On Python 3.8 and earlier, the name of the collection type is\n# capitalized, and the type is imported from the 'typing' module\nfrom typing import List, Set, Dict, Tuple\nx: List[int] = [1]\nx: Set[int] = {6, 7}\nx: Dict[str, float] = {\"field\": 2.0}\nx: Tuple[int, str, float] = (3, \"yes\", 7.5)\nx: Tuple[int, ...] = (1, 2, 3)\n\nfrom typing import Union, Optional\n\n# On Python 3.10+, use the | operator when something could be one of a few types\nx: list[int | str] = [3, 5, \"test\", \"fun\"]  # Python 3.10+\n# On earlier versions, use Union\nx: list[Union[int, str]] = [3, 5, \"test\", \"fun\"]\n\n# Use Optional[X] for a value that could be None\n# Optional[X] is the same as X | None or Union[X, None]\nx: Optional[str] = \"something\" if some_condition() else None\nif x is not None:\n    # Mypy understands x won't be None here because of the if-statement\n    print(x.upper())\n# If you know a value can never be None due to some logic that mypy doesn't\n# understand, use an assert\nassert x is not None\nprint(x.upper())\n</code></pre>"},{"location":"mypy/cheat_sheet_py3/#\u51fd\u6570","title":"\u51fd\u6570","text":"\u4e2d\u6587\u539f\u6587 <pre><code>from typing import Callable, Iterator, Union, Optional\n\n# \u8fd9\u662f\u6ce8\u89e3\u51fd\u6570\u5b9a\u4e49\u7684\u65b9\u5f0f\ndef stringify(num: int) -&gt; str:\n    return str(num)\n\n# \u4ee5\u4e0b\u662f\u6307\u5b9a\u591a\u4e2a\u53c2\u6570\u7684\u65b9\u6cd5\ndef plus(num1: int, num2: int) -&gt; int:\n    return num1 + num2\n\n# \u5982\u679c\u51fd\u6570\u6ca1\u6709\u8fd4\u56de\u503c\uff0c\u5219\u4f7f\u7528 None \u4f5c\u4e3a\u8fd4\u56de\u7c7b\u578b\n# \u53c2\u6570\u7684\u9ed8\u8ba4\u503c\u4f4d\u4e8e\u7c7b\u578b\u6ce8\u89e3\u4e4b\u540e\ndef show(value: str, excitement: int = 10) -&gt; None:\n    print(value + \"!\" * excitement)\n\n# \u8bf7\u6ce8\u610f\uff0c\u6ca1\u6709\u7c7b\u578b\u7684\u53c2\u6570\u662f\u52a8\u6001\u7c7b\u578b\u7684\uff08\u89c6\u4e3a Any\uff09\n# \u5e76\u4e14\u8be5\u51fd\u6570\u6ca1\u6709\u4efb\u4f55\u672a\u68c0\u67e5\u7684\u6ce8\u89e3\ndef untyped(x):\n    x.anything() + 1 + \"string\"  # no errors\n\n# \u8fd9\u662f\u6ce8\u89e3\u53ef\u8c03\u7528\uff08\u51fd\u6570\uff09\u503c\u7684\u65b9\u5f0f\nx: Callable[[int, float], float] = f\ndef register(callback: Callable[[str], int]) -&gt; None: ...\n\n# \u751f\u6210\u6574\u6570\u7684\u751f\u6210\u5668\u51fd\u6570\u5b9e\u9645\u4e0a\u53ea\u662f\u4e00\u4e2a\u51fd\u6570\n# \u8fd4\u56de\u4e00\u4e2a\u6574\u6570\u8fed\u4ee3\u5668\uff0c\u8fd9\u5c31\u662f\u6211\u4eec\u6ce8\u89e3\u5b83\u7684\u65b9\u5f0f\ndef gen(n: int) -&gt; Iterator[int]:\n    i = 0\n    while i &lt; n:\n        yield i\n        i += 1\n\n# \u60a8\u5f53\u7136\u53ef\u4ee5\u5c06\u51fd\u6570\u6ce8\u89e3\u62c6\u5206\u4e3a\u591a\u884c\ndef send_email(address: Union[str, list[str]],\n               sender: str,\n               cc: Optional[list[str]],\n               bcc: Optional[list[str]],\n               subject: str = '',\n               body: Optional[list[str]] = None\n               ) -&gt; bool:\n    ...\n\n# Mypy \u80fd\u591f\u7406\u89e3\u4ec5\u4f4d\u7f6e\u53c2\u6570\u548c\u4ec5\u5173\u952e\u5b57\u53c2\u6570\n# \u4e5f\u53ef\u4ee5\u4f7f\u7528\u4ee5\u4e24\u4e2a\u4e0b\u5212\u7ebf\u5f00\u5934\u7684\u540d\u79f0\u6765\u6807\u8bb0\u4ec5\u4f4d\u7f6e\u53c2\u6570\ndef quux(x: int, /, *, y: int) -&gt; None:\n    pass\n\nquux(3, y=5)  # Ok\nquux(3, 5)  # error: \u201cquux\u201d\u7684\u4f4d\u7f6e\u53c2\u6570\u592a\u591a\nquux(x=3, y=5)  # error: \u201cquux\u201d\u7684\u610f\u5916\u5173\u952e\u5b57\u53c2\u6570\u201cx\u201d\n\n# \u8fd9\u8868\u793a\u6bcf\u4e2a\u4f4d\u7f6e\u53c2\u6570\u548c\u6bcf\u4e2a\u5173\u952e\u5b57\u53c2\u6570\u90fd\u662f\u4e00\u4e2a\u201cstr\u201d\ndef call(self, *args: str, **kwargs: str) -&gt; str:\n    reveal_type(args)  # \u63ed\u793a\u7684\u7c7b\u578b\u662f \"tuple[str, ...]\"\n    reveal_type(kwargs)  # \u63ed\u793a\u7684\u7c7b\u578b\u662f \"dict[str, str]\"\n    request = make_request(*args, **kwargs)\n    return self.do_api_query(request)\n</code></pre> <p>Functions</p> <pre><code>from typing import Callable, Iterator, Union, Optional\n\n# This is how you annotate a function definition\ndef stringify(num: int) -&gt; str:\n    return str(num)\n\n# And here's how you specify multiple arguments\ndef plus(num1: int, num2: int) -&gt; int:\n    return num1 + num2\n\n# If a function does not return a value, use None as the return type\n# Default value for an argument goes after the type annotation\ndef show(value: str, excitement: int = 10) -&gt; None:\n    print(value + \"!\" * excitement)\n\n# Note that arguments without a type are dynamically typed (treated as Any)\n# and that functions without any annotations not checked\ndef untyped(x):\n    x.anything() + 1 + \"string\"  # no errors\n\n# This is how you annotate a callable (function) value\nx: Callable[[int, float], float] = f\ndef register(callback: Callable[[str], int]) -&gt; None: ...\n\n# A generator function that yields ints is secretly just a function that\n# returns an iterator of ints, so that's how we annotate it\ndef gen(n: int) -&gt; Iterator[int]:\n    i = 0\n    while i &lt; n:\n        yield i\n        i += 1\n\n# You can of course split a function annotation over multiple lines\ndef send_email(address: Union[str, list[str]],\n               sender: str,\n               cc: Optional[list[str]],\n               bcc: Optional[list[str]],\n               subject: str = '',\n               body: Optional[list[str]] = None\n               ) -&gt; bool:\n    ...\n\n# Mypy understands positional-only and keyword-only arguments\n# Positional-only arguments can also be marked by using a name starting with\n# two underscores\ndef quux(x: int, /, *, y: int) -&gt; None:\n    pass\n\nquux(3, y=5)  # Ok\nquux(3, 5)  # error: Too many positional arguments for \"quux\"\nquux(x=3, y=5)  # error: Unexpected keyword argument \"x\" for \"quux\"\n\n# This says each positional arg and each keyword arg is a \"str\"\ndef call(self, *args: str, **kwargs: str) -&gt; str:\n    reveal_type(args)  # Revealed type is \"tuple[str, ...]\"\n    reveal_type(kwargs)  # Revealed type is \"dict[str, str]\"\n    request = make_request(*args, **kwargs)\n    return self.do_api_query(request)\n</code></pre>"},{"location":"mypy/cheat_sheet_py3/#\u7c7b","title":"\u7c7b","text":"\u4e2d\u6587\u539f\u6587 <pre><code>class BankAccount:\n    # \u201c__init__\u201d\u65b9\u6cd5\u4e0d\u8fd4\u56de\u4efb\u4f55\u5185\u5bb9\uff0c\u56e0\u6b64\u5b83\u7684\u8fd4\u56de\u7c7b\u578b\u4e3a\u201cNone\u201d\uff0c\u5c31\u50cf\u4efb\u4f55\u5176\u4ed6\u4e0d\u8fd4\u56de\u4efb\u4f55\u5185\u5bb9\u7684\u65b9\u6cd5\u4e00\u6837\n    def __init__(self, account_name: str, initial_balance: int = 0) -&gt; None:\n        # mypy \u5c06\u6839\u636e\u53c2\u6570\u7684\u7c7b\u578b\u63a8\u65ad\u8fd9\u4e9b\u5b9e\u4f8b\u53d8\u91cf\u7684\u6b63\u786e\u7c7b\u578b\u3002\n        self.account_name = account_name\n        self.balance = initial_balance\n\n    # \u5bf9\u4e8e\u5b9e\u4f8b\u65b9\u6cd5\uff0c\u7701\u7565\u201cself\u201d\u7684\u7c7b\u578b\n    def deposit(self, amount: int) -&gt; None:\n        self.balance += amount\n\n    def withdraw(self, amount: int) -&gt; None:\n        self.balance -= amount\n\n# \u7528\u6237\u5b9a\u4e49\u7684\u7c7b\u4f5c\u4e3a\u6ce8\u89e3\u4e2d\u7684\u7c7b\u578b\u6709\u6548\naccount: BankAccount = BankAccount(\"Alice\", 400)\ndef transfer(src: BankAccount, dst: BankAccount, amount: int) -&gt; None:\n    src.withdraw(amount)\n    dst.deposit(amount)\n\n# \u63a5\u53d7 BankAccount \u7684\u51fd\u6570\u4e5f\u63a5\u53d7 BankAccount \u7684\u4efb\u4f55\u5b50\u7c7b\uff01\nclass AuditedBankAccount(BankAccount):\n    # \u60a8\u53ef\u4ee5\u9009\u62e9\u5728\u7c7b\u4e3b\u4f53\u4e2d\u58f0\u660e\u5b9e\u4f8b\u53d8\u91cf\n    audit_log: list[str]\n    # \u8fd9\u662f\u4e00\u4e2a\u5177\u6709\u9ed8\u8ba4\u503c\u7684\u5b9e\u4f8b\u53d8\u91cf\n    auditor_name: str = \"The Spanish Inquisition\"\n\n    def __init__(self, account_name: str, initial_balance: int = 0) -&gt; None:\n        super().__init__(account_name, initial_balance)\n        self.audit_log: list[str] = []\n\n    def deposit(self, amount: int) -&gt; None:\n        self.audit_log.append(f\"Deposited {amount}\")\n        self.balance += amount\n\n    def withdraw(self, amount: int) -&gt; None:\n        self.audit_log.append(f\"Withdrew {amount}\")\n        self.balance -= amount\n\naudited = AuditedBankAccount(\"Bob\", 300)\ntransfer(audited, account, 100)  # \u7c7b\u578b\u68c0\u67e5!\n\n# \u53ef\u4ee5\u4f7f\u7528ClassVar\u6ce8\u89e3\u6765\u58f0\u660e\u7c7b\u53d8\u91cf\nclass Car:\n    seats: ClassVar[int] = 4\n    passengers: ClassVar[list[str]]\n\n# \u5982\u679c\u60a8\u60f3\u8981\u7c7b\u4e0a\u7684\u52a8\u6001\u5c5e\u6027\uff0c\u8bf7\u8ba9\u5b83\u8986\u76d6\u201c__setattr__\u201d\u6216\u201c__getattr__\u201d\nclass A:\n    # \u5982\u679c x \u4e0e\u201cvalue\u201d\u7684\u7c7b\u578b\u76f8\u540c\uff0c\u5219\u8fd9\u5c06\u5141\u8bb8\u5206\u914d\u7ed9\u4efb\u4f55 A.x\n    # \uff08\u4f7f\u7528\u201cvalue: Any\u201d\u5141\u8bb8\u4efb\u610f\u7c7b\u578b\uff09\n    def __setattr__(self, name: str, value: int) -&gt; None: ...\n\n    # \u5982\u679c x \u4e0e\u8fd4\u56de\u7c7b\u578b\u517c\u5bb9\uff0c\u8fd9\u5c06\u5141\u8bb8\u8bbf\u95ee\u4efb\u4f55 A.x\n    def __getattr__(self, name: str) -&gt; int: ...\n\na.foo = 42  # OK\na.bar = 'Ex-parrot'  # \u7c7b\u578b\u68c0\u67e5\u5931\u8d25\n</code></pre> <p>Classes</p> <pre><code>class BankAccount:\n    # The \"__init__\" method doesn't return anything, so it gets return\n    # type \"None\" just like any other method that doesn't return anything\n    def __init__(self, account_name: str, initial_balance: int = 0) -&gt; None:\n        # mypy will infer the correct types for these instance variables\n        # based on the types of the parameters.\n        self.account_name = account_name\n        self.balance = initial_balance\n\n    # For instance methods, omit type for \"self\"\n    def deposit(self, amount: int) -&gt; None:\n        self.balance += amount\n\n    def withdraw(self, amount: int) -&gt; None:\n        self.balance -= amount\n\n# User-defined classes are valid as types in annotations\naccount: BankAccount = BankAccount(\"Alice\", 400)\ndef transfer(src: BankAccount, dst: BankAccount, amount: int) -&gt; None:\n    src.withdraw(amount)\n    dst.deposit(amount)\n\n# Functions that accept BankAccount also accept any subclass of BankAccount!\nclass AuditedBankAccount(BankAccount):\n    # You can optionally declare instance variables in the class body\n    audit_log: list[str]\n    # This is an instance variable with a default value\n    auditor_name: str = \"The Spanish Inquisition\"\n\n    def __init__(self, account_name: str, initial_balance: int = 0) -&gt; None:\n        super().__init__(account_name, initial_balance)\n        self.audit_log: list[str] = []\n\n    def deposit(self, amount: int) -&gt; None:\n        self.audit_log.append(f\"Deposited {amount}\")\n        self.balance += amount\n\n    def withdraw(self, amount: int) -&gt; None:\n        self.audit_log.append(f\"Withdrew {amount}\")\n        self.balance -= amount\n\naudited = AuditedBankAccount(\"Bob\", 300)\ntransfer(audited, account, 100)  # type checks!\n\n# You can use the ClassVar annotation to declare a class variable\nclass Car:\n    seats: ClassVar[int] = 4\n    passengers: ClassVar[list[str]]\n\n# If you want dynamic attributes on your class, have it\n# override \"__setattr__\" or \"__getattr__\"\nclass A:\n    # This will allow assignment to any A.x, if x is the same type as \"value\"\n    # (use \"value: Any\" to allow arbitrary types)\n    def __setattr__(self, name: str, value: int) -&gt; None: ...\n\n    # This will allow access to any A.x, if x is compatible with the return type\n    def __getattr__(self, name: str) -&gt; int: ...\n\na.foo = 42  # Works\na.bar = 'Ex-parrot'  # Fails type checking\n</code></pre>"},{"location":"mypy/cheat_sheet_py3/#\u5f53\u4f60\u611f\u5230\u56f0\u60d1\u6216\u4e8b\u60c5\u53d8\u5f97\u590d\u6742\u65f6","title":"\u5f53\u4f60\u611f\u5230\u56f0\u60d1\u6216\u4e8b\u60c5\u53d8\u5f97\u590d\u6742\u65f6","text":"\u4e2d\u6587\u539f\u6587 <pre><code>from typing import Union, Any, Optional, TYPE_CHECKING, cast\n\n# \u8981\u627e\u51fa mypy \u4e3a\u7a0b\u5e8f\u4e2d\u4efb\u4f55\u4f4d\u7f6e\u7684\u8868\u8fbe\u5f0f\u63a8\u65ad\u51fa\u4ec0\u4e48\u7c7b\u578b\uff0c\u8bf7\u5c06\u5176\u5305\u88c5\u5728 Reveal_type() \u4e2d\u3002 Mypy \u5c06\u6253\u5370\u4e00\u6761\u5e26\u6709\u7c7b\u578b\u7684\u9519\u8bef\u6d88\u606f\uff1b \u5728\u8fd0\u884c\u4ee3\u7801\u4e4b\u524d\u518d\u6b21\u5220\u9664\u5b83\u3002\nreveal_type(1)  # \u63ed\u793a\u7684\u7c7b\u578b\u662f \"builtins.int\"\n\n# \u5982\u679c\u60a8\u4f7f\u7528\u7a7a\u5bb9\u5668\u6216\u201cNone\u201d\u521d\u59cb\u5316\u53d8\u91cf\uff0c\u60a8\u53ef\u80fd\u9700\u8981\u901a\u8fc7\u63d0\u4f9b\u663e\u5f0f\u7c7b\u578b\u6ce8\u89e3\u6765\u5e2e\u52a9 mypy\nx: list[str] = []\nx: Optional[str] = None\n\n# \u5982\u679c\u60a8\u4e0d\u77e5\u9053\u67d0\u4e8b\u7269\u7684\u7c7b\u578b\u6216\u8005\u5b83\u592a\u52a8\u6001\u800c\u65e0\u6cd5\u4e3a\u5176\u7f16\u5199\u7c7b\u578b\uff0c\u8bf7\u4f7f\u7528 Any\nx: Any = mystery_function()\n# Mypy \u4f1a\u8ba9\u4f60\u7528 x \u505a\u4efb\u4f55\u4e8b\u60c5\uff01\nx.whatever() * x[\"you\"] + x(\"want\") - any(x) and all(x) is super  # no errors\n\n# \u5f53\u60a8\u7684\u4ee3\u7801\u6df7\u6dc6 mypy \u6216\u5728 mypy \u4e2d\u9047\u5230\u5f7b\u5e95\u7684\u9519\u8bef\u65f6\uff0c\u4f7f\u7528\u201ctype:ignore\u201d\u6ce8\u89e3\u6765\u6291\u5236\u7ed9\u5b9a\u884c\u4e0a\u7684\u9519\u8bef\u3002\n# \u597d\u7684\u505a\u6cd5\u662f\u6dfb\u52a0\u89e3\u91ca\u95ee\u9898\u7684\u8bc4\u8bba\u3002\nx = confusing_function()  # type: ignore  # \u6df7\u4e71\u7684\u51fd\u6570\u4e0d\u4f1a\u5728\u8fd9\u91cc\u8fd4\u56de None \u56e0\u4e3a......\n\n# \u201ccast\u201d\u662f\u4e00\u4e2a\u8f85\u52a9\u51fd\u6570\uff0c\u53ef\u8ba9\u60a8\u8986\u76d6\u8868\u8fbe\u5f0f\u7684\u63a8\u65ad\u7c7b\u578b\u3002 \u5b83\u4ec5\u9002\u7528\u4e8e mypy\u2014\u2014\u6ca1\u6709\u8fd0\u884c\u65f6\u68c0\u67e5\u3002\na = [4]\nb = cast(list[int], a)  # \u901a\u8fc7\u826f\u597d\nc = cast(list[str], a)  # \u5c3d\u7ba1\u662f\u8c0e\u8a00\uff0c\u4f46\u4ecd\u901a\u8fc7\u826f\u597d\uff08\u6ca1\u6709\u8fd0\u884c\u65f6\u68c0\u67e5\uff09\nreveal_type(c)  # \u63ed\u793a\u7684\u7c7b\u578b\u662f \"builtins.list[builtins.str]\"\nprint(c)  # \u4ecd\u7136\u6253\u5370 [4] ...\u8be5\u5bf9\u8c61\u5728\u8fd0\u884c\u65f6\u672a\u66f4\u6539\u6216\u8f6c\u6362\n\n# \u5982\u679c\u60a8\u60f3\u8981 mypy \u53ef\u4ee5\u770b\u5230\u4f46\u4e0d\u4f1a\u5728\u8fd0\u884c\u65f6\u6267\u884c\u7684\u4ee3\u7801\uff08\u6216\u8005\u60f3\u8981 mypy \u770b\u4e0d\u5230\u7684\u4ee3\u7801\uff09\uff0c\u8bf7\u4f7f\u7528\u201cTYPE_CHECKING\u201d\nif TYPE_CHECKING:\n    import json\nelse:\n    import orjson as json  # mypy \u4e0d\u77e5\u9053\u8fd9\u4e00\u70b9\n</code></pre> <p>\u5728\u67d0\u4e9b\u60c5\u51b5\u4e0b\uff0c\u7c7b\u578b\u6ce8\u89e3\u53ef\u80fd\u4f1a\u5728\u8fd0\u884c\u65f6\u5bfc\u81f4\u95ee\u9898\uff0c\u8bf7\u53c2\u9605\u8fd0\u884c\u65f6\u6ce8\u89e3\u95ee\u9898\u6765\u5904\u7406\u6b64\u95ee\u9898\u3002</p> <p>\u6709\u5173\u5982\u4f55\u6d88\u9664\u9519\u8bef\u7684\u8be6\u7ec6\u4fe1\u606f\uff0c\u8bf7\u53c2\u9605\u6d88\u9664\u7c7b\u578b\u9519\u8bef\u3002</p> <p>When you\u2019re puzzled or when things are complicated</p> <pre><code>from typing import Union, Any, Optional, TYPE_CHECKING, cast\n\n# To find out what type mypy infers for an expression anywhere in\n# your program, wrap it in reveal_type().  Mypy will print an error\n# message with the type; remove it again before running the code.\nreveal_type(1)  # Revealed type is \"builtins.int\"\n\n# If you initialize a variable with an empty container or \"None\"\n# you may have to help mypy a bit by providing an explicit type annotation\nx: list[str] = []\nx: Optional[str] = None\n\n# Use Any if you don't know the type of something or it's too\n# dynamic to write a type for\nx: Any = mystery_function()\n# Mypy will let you do anything with x!\nx.whatever() * x[\"you\"] + x(\"want\") - any(x) and all(x) is super  # no errors\n\n# Use a \"type: ignore\" comment to suppress errors on a given line,\n# when your code confuses mypy or runs into an outright bug in mypy.\n# Good practice is to add a comment explaining the issue.\nx = confusing_function()  # type: ignore  # confusing_function won't return None here because ...\n\n# \"cast\" is a helper function that lets you override the inferred\n# type of an expression. It's only for mypy -- there's no runtime check.\na = [4]\nb = cast(list[int], a)  # Passes fine\nc = cast(list[str], a)  # Passes fine despite being a lie (no runtime check)\nreveal_type(c)  # Revealed type is \"builtins.list[builtins.str]\"\nprint(c)  # Still prints [4] ... the object is not changed or casted at runtime\n\n# Use \"TYPE_CHECKING\" if you want to have code that mypy can see but will not\n# be executed at runtime (or to have code that mypy can't see)\nif TYPE_CHECKING:\n    import json\nelse:\n    import orjson as json  # mypy is unaware of this\n</code></pre> <p>In some cases type annotations can cause issues at runtime, see Annotation issues at runtime for dealing with this.</p> <p>See Silencing type errors for details on how to silence errors.</p>"},{"location":"mypy/cheat_sheet_py3/#\u6807\u51c6\u9e2d\u5b50\u7c7b\u578b","title":"\u6807\u51c6\u201c\u9e2d\u5b50\u7c7b\u578b\u201d","text":"\u4e2d\u6587\u539f\u6587 <p>\u5728\u5178\u578b\u7684 Python \u4ee3\u7801\u4e2d\uff0c\u8bb8\u591a\u53ef\u4ee5\u5c06\u5217\u8868\u6216\u5b57\u5178\u4f5c\u4e3a\u53c2\u6570\u7684\u51fd\u6570\u53ea\u9700\u8981\u5b83\u4eec\u7684\u53c2\u6570\u5728\u67d0\u79cd\u7a0b\u5ea6\u4e0a\u201c\u7c7b\u4f3c\u4e8e\u5217\u8868\u201d\u6216\u201c\u7c7b\u4f3c\u4e8e\u5b57\u5178\u201d\u3002 \u201c\u7c7b\u4f3c\u5217\u8868\u201d\u6216\u201c\u7c7b\u4f3c\u5b57\u5178\u201d\uff08\u6216\u7c7b\u4f3c\u5176\u4ed6\u4e1c\u897f\uff09\u7684\u7279\u5b9a\u542b\u4e49\u79f0\u4e3a\u201c\u9e2d\u5b50\u7c7b\u578b\u201d\uff0c\u5e76\u4e14\u5728\u60ef\u7528\u7684Python\u4e2d\u5e38\u89c1\u7684\u51e0\u79cd\u9e2d\u5b50\u7c7b\u578b\u5df2\u6807\u51c6\u5316\u3002</p> <pre><code>from typing import Mapping, MutableMapping, Sequence, Iterable\n\n# \u5c06 Iterable \u7528\u4e8e\u901a\u7528\u53ef\u8fed\u4ee3\u5bf9\u8c61\uff08\u201cfor\u201d\u4e2d\u53ef\u7528\u7684\u4efb\u4f55\u5185\u5bb9\uff09\uff0c\u5e76\u5728\u9700\u8981\u5e8f\u5217\uff08\u652f\u6301\u201clen\u201d\u548c\u201c__getitem__\u201d\uff09\u65f6\u4f7f\u7528 Sequence\ndef f(ints: Iterable[int]) -&gt; list[str]:\n    return [str(x) for x in ints]\n\nf(range(1, 3))\n\n# Mapping \u63cf\u8ff0\u4e86\u4e00\u4e2a\u6211\u4eec\u4e0d\u4f1a\u6539\u53d8\u7684\u7c7b\u4f3c dict \u7684\u5bf9\u8c61\uff08\u5e26\u6709\u201c__getitem__\u201d\uff09\uff0c\u800c MutableMapping \u5219\u63cf\u8ff0\u4e86\u4e00\u4e2a\u6211\u4eec\u53ef\u80fd\u4f1a\u6539\u53d8\u7684\u5bf9\u8c61\uff08\u5e26\u6709\u201c__setitem__\u201d\uff09\ndef f(my_mapping: Mapping[int, str]) -&gt; list[int]:\n    my_mapping[5] = 'maybe'  # mypy \u4f1a\u62b1\u6028\u8fd9\u884c......\n    return list(my_mapping.keys())\n\nf({3: 'yes', 4: 'no'})\n\ndef f(my_mapping: MutableMapping[int, str]) -&gt; set[str]:\n    my_mapping[5] = 'maybe'  # ...\u4f46 mypy \u5bf9\u6b64\u8868\u793a\u540c\u610f\u3002\n    return set(my_mapping.values())\n\nf({3: 'yes', 4: 'no'})\n\nimport sys\nfrom typing import IO\n\n# \u5bf9\u4e8e\u5e94\u8be5\u63a5\u53d7\u6216\u8fd4\u56de\u6765\u81ea open() \u8c03\u7528\u7684\u5bf9\u8c61\u7684\u51fd\u6570\uff0c\u8bf7\u4f7f\u7528 IO[str] \u6216 IO[bytes]\uff08\u8bf7\u6ce8\u610f\uff0cIO \u4e0d\u533a\u5206\u8bfb\u3001\u5199\u6216\u5176\u4ed6\u6a21\u5f0f\uff09\ndef get_sys_IO(mode: str = 'w') -&gt; IO[str]:\n    if mode == 'w':\n        return sys.stdout\n    elif mode == 'r':\n        return sys.stdin\n    else:\n        return sys.stdout\n</code></pre> <p>\u60a8\u751a\u81f3\u53ef\u4ee5\u4f7f\u7528\u534f\u8bae\u548c\u7ed3\u6784\u5b50\u7c7b\u578b\u521b\u5efa\u81ea\u5df1\u7684\u9e2d\u5b50\u7c7b\u578b\u3002</p> <p>Standard \u201cduck types\u201d</p> <p>In typical Python code, many functions that can take a list or a dict as an argument only need their argument to be somehow \u201clist-like\u201d or \u201cdict-like\u201d. A specific meaning of \u201clist-like\u201d or \u201cdict-like\u201d (or something-else-like) is called a \u201cduck type\u201d, and several duck types that are common in idiomatic Python are standardized.</p> <pre><code>from typing import Mapping, MutableMapping, Sequence, Iterable\n\n# Use Iterable for generic iterables (anything usable in \"for\"),\n# and Sequence where a sequence (supporting \"len\" and \"__getitem__\") is\n# required\ndef f(ints: Iterable[int]) -&gt; list[str]:\n    return [str(x) for x in ints]\n\nf(range(1, 3))\n\n# Mapping describes a dict-like object (with \"__getitem__\") that we won't\n# mutate, and MutableMapping one (with \"__setitem__\") that we might\ndef f(my_mapping: Mapping[int, str]) -&gt; list[int]:\n    my_mapping[5] = 'maybe'  # mypy will complain about this line...\n    return list(my_mapping.keys())\n\nf({3: 'yes', 4: 'no'})\n\ndef f(my_mapping: MutableMapping[int, str]) -&gt; set[str]:\n    my_mapping[5] = 'maybe'  # ...but mypy is OK with this.\n    return set(my_mapping.values())\n\nf({3: 'yes', 4: 'no'})\n\nimport sys\nfrom typing import IO\n\n# Use IO[str] or IO[bytes] for functions that should accept or return\n# objects that come from an open() call (note that IO does not\n# distinguish between reading, writing or other modes)\ndef get_sys_IO(mode: str = 'w') -&gt; IO[str]:\n    if mode == 'w':\n        return sys.stdout\n    elif mode == 'r':\n        return sys.stdin\n    else:\n        return sys.stdout\n</code></pre> <p>You can even make your own duck types using Protocols and structural subtyping.</p>"},{"location":"mypy/cheat_sheet_py3/#\u524d\u7f6e\u5f15\u7528forward-reference","title":"\u524d\u7f6e\u5f15\u7528\uff08forward reference\uff09","text":"\u4e2d\u6587\u539f\u6587 <pre><code># \u60a8\u53ef\u80fd\u60f3\u5728\u5b9a\u4e49\u7c7b\u4e4b\u524d\u5f15\u7528\u5b83\u3002\u8fd9\u79f0\u4e3a\u201c\u524d\u7f6e\u7c7b\u578b\uff08forward reference\uff09\u201d\u3002\ndef f(foo: A) -&gt; int:  # \u8fd9\u5c06\u5728\u8fd0\u884c\u65f6\u5931\u8d25\uff0c\u56e0\u4e3a\u201cA\u201d\u672a\u5b9a\u4e49\n    ...\n\n# \u4f46\u662f\uff0c\u5982\u679c\u6dfb\u52a0\u4ee5\u4e0b\u7279\u6b8a\u5bfc\u5165\uff1a\nfrom __future__ import annotations\n# \u5b83\u5c06\u5728\u8fd0\u884c\u65f6\u5de5\u4f5c\uff0c\u5e76\u4e14\u53ea\u8981\u6587\u4ef6\u4e2d\u7a0d\u540e\u5b58\u5728\u8be5\u540d\u79f0\u7684\u7c7b\uff0c\u7c7b\u578b\u68c0\u67e5\u5c31\u4f1a\u6210\u529f\ndef f(foo: A) -&gt; int:  # Ok\n    ...\n\n# \u53e6\u4e00\u79cd\u9009\u62e9\u662f\u5c06\u7c7b\u578b\u653e\u5728\u5f15\u53f7\u4e2d\ndef f(foo: 'A') -&gt; int:  # Also ok\n    ...\n\nclass A:\n    # \u5982\u679c\u60a8\u9700\u8981\u5728\u8be5\u7c7b\u5b9a\u4e49\u5185\u7684\u7c7b\u578b\u6ce8\u89e3\u4e2d\u5f15\u7528\u8be5\u7c7b\uff0c\u4e5f\u4f1a\u51fa\u73b0\u8fd9\u79cd\u60c5\u51b5\n    @classmethod\n    def create(cls) -&gt; A:\n        ...\n</code></pre> <p>\u6709\u5173\u66f4\u591a\u8be6\u7ec6\u4fe1\u606f\uff0c\u8bf7\u53c2\u9605\u7c7b\u540d\u524d\u7f6e\u5f15\u7528\u3002</p> <p>Forward references</p> <pre><code># You may want to reference a class before it is defined.\n# This is known as a \"forward reference\".\ndef f(foo: A) -&gt; int:  # This will fail at runtime with 'A' is not defined\n    ...\n\n# However, if you add the following special import:\nfrom __future__ import annotations\n# It will work at runtime and type checking will succeed as long as there\n# is a class of that name later on in the file\ndef f(foo: A) -&gt; int:  # Ok\n    ...\n\n# Another option is to just put the type in quotes\ndef f(foo: 'A') -&gt; int:  # Also ok\n    ...\n\nclass A:\n    # This can also come up if you need to reference a class in a type\n    # annotation inside the definition of that class\n    @classmethod\n    def create(cls) -&gt; A:\n        ...\n</code></pre> <p>See Class name forward references for more details.</p>"},{"location":"mypy/cheat_sheet_py3/#\u88c5\u9970\u5668","title":"\u88c5\u9970\u5668","text":"\u4e2d\u6587\u539f\u6587 <p>\u88c5\u9970\u5668\u51fd\u6570\u53ef\u4ee5\u901a\u8fc7\u6cdb\u578b\u6765\u8868\u8fbe\u3002 \u6709\u5173\u66f4\u591a\u8be6\u7ec6\u4fe1\u606f\uff0c\u8bf7\u53c2\u9605\u58f0\u660e\u88c5\u9970\u5668\u3002</p> <pre><code>from typing import Any, Callable, TypeVar\n\nF = TypeVar('F', bound=Callable[..., Any])\n\ndef bare_decorator(func: F) -&gt; F:\n    ...\n\ndef decorator_args(url: str) -&gt; Callable[[F], F]:\n    ...\n</code></pre> <p>Decorators</p> <p>Decorator functions can be expressed via generics. See Declaring decorators for more details.</p> <pre><code>from typing import Any, Callable, TypeVar\n\nF = TypeVar('F', bound=Callable[..., Any])\n\ndef bare_decorator(func: F) -&gt; F:\n    ...\n\ndef decorator_args(url: str) -&gt; Callable[[F], F]:\n    ...\n</code></pre>"},{"location":"mypy/cheat_sheet_py3/#\u534f\u7a0b\u548c-asyncio","title":"\u534f\u7a0b\u548c asyncio","text":"\u4e2d\u6587\u539f\u6587 <p>\u6709\u5173\u7f16\u5199\u534f\u7a0b\u548c\u5f02\u6b65\u4ee3\u7801\u7684\u5b8c\u6574\u8be6\u7ec6\u4fe1\u606f\uff0c\u8bf7\u53c2\u9605\u6ce8\u89e3 async/await\u3002</p> <pre><code>import asyncio\n\n# \u534f\u7a0b\u7684\u7c7b\u578b\u4e0e\u666e\u901a\u51fd\u6570\u7c7b\u4f3c\n\nasync def countdown(tag: str, count: int) -&gt; str:\n    while count &gt; 0:\n        print(f'T-minus {count} ({tag})')\n        await asyncio.sleep(0.1)\n        count -= 1\n    return \"Blastoff!\"\n</code></pre> <p>Coroutines and asyncio</p> <p>See Typing async/await for the full detail on typing coroutines and asynchronous code.</p> <pre><code>import asyncio\n\n# A coroutine is typed like a normal function\n\nasync def countdown(tag: str, count: int) -&gt; str:\n    while count &gt; 0:\n        print(f'T-minus {count} ({tag})')\n        await asyncio.sleep(0.1)\n        count -= 1\n    return \"Blastoff!\"\n</code></pre>"},{"location":"mypy/class_basics/","title":"\u7c7b\u57fa\u7840","text":"\u4e2d\u6587\u82f1\u6587 <p>\u672c\u8282\u5c06\u5e2e\u52a9\u60a8\u5f00\u59cb\u4e3a\u7c7b\u6dfb\u52a0\u6ce8\u89e3\u3002 \u8bf8\u5982 \u201cint\u201d \u4e4b\u7c7b\u7684\u5185\u7f6e\u7c7b\u4e5f\u9075\u5faa\u8fd9\u4e9b\u76f8\u540c\u7684\u89c4\u5219\u3002</p> <p>Class basics</p> <p>This section will help get you started annotating your classes. Built-in classes such as <code>int</code> also follow these same rules.</p>"},{"location":"mypy/class_basics/#\u5b9e\u4f8b\u548c\u7c7b\u5c5e\u6027","title":"\u5b9e\u4f8b\u548c\u7c7b\u5c5e\u6027","text":"\u4e2d\u6587\u82f1\u6587 <p>mypy \u7c7b\u578b\u68c0\u67e5\u5668\u4f1a\u68c0\u6d4b\u60a8\u662f\u5426\u5c1d\u8bd5\u8bbf\u95ee\u4e22\u5931\u7684\u5c5e\u6027\uff0c\u8fd9\u662f\u4e00\u4e2a\u975e\u5e38\u5e38\u89c1\u7684\u7f16\u7a0b\u9519\u8bef\u3002 \u4e3a\u4e86\u4f7f\u5176\u6b63\u5e38\u5de5\u4f5c\uff0c\u5fc5\u987b\u5728\u7c7b\u4e2d\u5b9a\u4e49\u6216\u521d\u59cb\u5316\u5b9e\u4f8b\u548c\u7c7b\u5c5e\u6027\u3002 Mypy \u63a8\u65ad\u5c5e\u6027\u7684\u7c7b\u578b\uff1a</p> <pre><code>class A:\n    def __init__(self, x: int) -&gt; None:\n        self.x = x  # Aha, attribute 'x' of type 'int'\n\na = A(1)\na.x = 2  # OK!\na.y = 3  # Error: \"A\" has no attribute \"y\"\n</code></pre> <p>\u8fd9\u6709\u70b9\u50cf\u6bcf\u4e2a\u7c7b\u90fd\u6709\u4e00\u4e2a\u9690\u5f0f\u5b9a\u4e49\u7684 <code>__slots__</code> \u5c5e\u6027\u3002 \u8fd9\u4ec5\u5728\u7c7b\u578b\u68c0\u67e5\u671f\u95f4\u5f3a\u5236\u6267\u884c\uff0c\u800c\u4e0d\u662f\u5728\u7a0b\u5e8f\u8fd0\u884c\u65f6\u5f3a\u5236\u6267\u884c\u3002</p> <p>\u60a8\u53ef\u4ee5\u4f7f\u7528\u7c7b\u578b\u6ce8\u91ca\u663e\u5f0f\u58f0\u660e\u7c7b\u4e3b\u4f53\u4e2d\u7684\u53d8\u91cf\u7c7b\u578b\uff1a</p> <pre><code>class A:\n    x: list[int]  # Declare attribute 'x' of type list[int]\n\na = A()\na.x = [1]     # OK\n</code></pre> <p>\u901a\u5e38\u5728 Python \u4e2d\uff0c\u7c7b\u4f53\u4e2d\u5b9a\u4e49\u7684\u53d8\u91cf\u53ef\u4ee5\u7528\u4f5c\u7c7b\u53d8\u91cf\u6216\u5b9e\u4f8b\u53d8\u91cf\u3002 \uff08\u5982\u4e0b\u4e00\u8282\u6240\u8ff0\uff0c\u60a8\u53ef\u4ee5\u4f7f\u7528 <code>typing.ClassVar</code> \u6ce8\u91ca\u8986\u76d6\u5b83\u3002\uff09</p> <p>\u540c\u6837\uff0c\u60a8\u53ef\u4ee5\u4e3a\u65b9\u6cd5\u4e2d\u5b9a\u4e49\u7684\u5b9e\u4f8b\u53d8\u91cf\u6307\u5b9a\u663e\u5f0f\u7c7b\u578b\uff1a</p> <pre><code>class A:\n    def __init__(self) -&gt; None:\n        self.x: list[int] = []\n\n    def f(self) -&gt; None:\n        self.y: Any = 0\n</code></pre> <p>\u5982\u679c\u60a8\u4f7f\u7528 <code>self</code> \u663e\u5f0f\u5206\u914d\u5b9e\u4f8b\u53d8\u91cf\uff0c\u5219\u53ea\u80fd\u5728\u65b9\u6cd5\u4e2d\u5b9a\u4e49\u5b9e\u4f8b\u53d8\u91cf\uff1a</p> <pre><code>class A:\n    def __init__(self) -&gt; None:\n        self.y = 1   # Define 'y'\n        a = self\n        a.x = 1      # Error: 'x' not defined\n</code></pre> <p>Instance and class attributes</p> <p>The mypy type checker detects if you are trying to access a missing attribute, which is a very common programming error. For this to work correctly, instance and class attributes must be defined or initialized within the class. Mypy infers the types of attributes:</p> <pre><code>class A:\n    def __init__(self, x: int) -&gt; None:\n        self.x = x  # Aha, attribute 'x' of type 'int'\n\na = A(1)\na.x = 2  # OK!\na.y = 3  # Error: \"A\" has no attribute \"y\"\n</code></pre> <p>This is a bit like each class having an implicitly defined <code>__slots__</code> attribute. This is only enforced during type checking and not when your program is running.</p> <p>You can declare types of variables in the class body explicitly using a type annotation:</p> <pre><code>class A:\n    x: list[int]  # Declare attribute 'x' of type list[int]\n\na = A()\na.x = [1]     # OK\n</code></pre> <p>As in Python generally, a variable defined in the class body can be used as a class or an instance variable. (As discussed in the next section, you can override this with a <code>typing.ClassVar</code> annotation.)</p> <p>Similarly, you can give explicit types to instance variables defined in a method:</p> <pre><code>class A:\n    def __init__(self) -&gt; None:\n        self.x: list[int] = []\n\n    def f(self) -&gt; None:\n        self.y: Any = 0\n</code></pre> <p>You can only define an instance variable within a method if you assign to it explicitly using <code>self</code>:</p> <pre><code>class A:\n    def __init__(self) -&gt; None:\n        self.y = 1   # Define 'y'\n        a = self\n        a.x = 1      # Error: 'x' not defined\n</code></pre>"},{"location":"mypy/class_basics/#\u6ce8\u89e3-__init__-\u65b9\u6cd5","title":"\u6ce8\u89e3 __init__ \u65b9\u6cd5","text":"\u4e2d\u6587\u82f1\u6587 <p><code>__init__</code> \u65b9\u6cd5\u6709\u4e9b\u7279\u6b8a\u2014\u2014\u5b83\u4e0d\u8fd4\u56de\u503c\u3002 \u8fd9\u6700\u597d\u8868\u8fbe\u4e3a <code>-&gt; None</code>\u3002 \u7136\u800c\uff0c\u7531\u4e8e\u8bb8\u591a\u4eba\u8ba4\u4e3a\u8fd9\u662f\u591a\u4f59\u7684\uff0c\u56e0\u6b64\u5141\u8bb8\u7701\u7565 <code>__init__</code> \u65b9\u6cd5\u7684\u8fd4\u56de\u7c7b\u578b\u58f0\u660e \u5982\u679c\u81f3\u5c11\u6709\u4e00\u4e2a\u53c2\u6570\u88ab\u6ce8\u91ca\u3002 \u4f8b\u5982\uff0c\u5728\u4ee5\u4e0b\u7c7b\u4e2d <code>__init__</code> \u88ab\u8ba4\u4e3a\u662f\u5b8c\u5168\u6ce8\u91ca\u7684\uff1a</p> <pre><code>class C1:\n    def __init__(self) -&gt; None:\n        self.var = 42\n\nclass C2:\n    def __init__(self, arg: int):\n        self.var = arg\n</code></pre> <p>\u4f46\u662f\uff0c\u5982\u679c <code>__init__</code> \u6ca1\u6709\u5e26\u6ce8\u89e3\u7684\u53c2\u6570\uff0c\u4e5f\u6ca1\u6709\u8fd4\u56de\u7c7b\u578b\u6ce8\u89e3\uff0c\u5219\u5b83\u88ab\u89c6\u4e3a\u65e0\u7c7b\u578b\u6ce8\u89e3\u65b9\u6cd5\uff1a</p> <pre><code>class C3:\n    def __init__(self):\n        # \u8be5\u4e3b\u4f53\u5c06\u4e0d\u4f1a\u8fdb\u884c\u7c7b\u578b\u68c0\u67e5\n        self.var = 42 + 'abc'\n</code></pre> <p>Annotating __init__ methods</p> <p>The <code>__init__</code> method is somewhat special -- it doesn't return a value.  This is best expressed as <code>-&gt; None</code>.  However, since many feel this is redundant, it is allowed to omit the return type declaration on <code>__init__</code> methods if at least one argument is annotated.  For example, in the following classes <code>__init__</code> is considered fully annotated:</p> <pre><code>class C1:\n    def __init__(self) -&gt; None:\n        self.var = 42\n\nclass C2:\n    def __init__(self, arg: int):\n        self.var = arg\n</code></pre> <p>However, if <code>__init__</code> has no annotated arguments and no return type annotation, it is considered an untyped method:</p> <pre><code>class C3:\n    def __init__(self):\n        # This body is not type checked\n        self.var = 42 + 'abc'\n</code></pre>"},{"location":"mypy/class_basics/#\u7c7b\u5c5e\u6027\u6ce8\u89e3","title":"\u7c7b\u5c5e\u6027\u6ce8\u89e3","text":"\u4e2d\u6587\u82f1\u6587 <p>\u60a8\u53ef\u4ee5\u4f7f\u7528 <code>ClassVar[t]</code> \u6ce8\u91ca\u6765\u663e\u5f0f\u58f0\u660e\u4e0d\u5e94\u5728\u5b9e\u4f8b\u4e0a\u8bbe\u7f6e\u7279\u5b9a\u5c5e\u6027\uff1a</p> <pre><code>from typing import ClassVar\n\nclass A:\n    x: ClassVar[int] = 0  # \u4ec5\u7c7b\u53d8\u91cf\n\nA.x += 1  # OK\n\na = A()\na.x = 1  # Error: \u65e0\u6cd5\u901a\u8fc7\u5b9e\u4f8b\u5206\u914d\u7ed9\u7c7b\u53d8\u91cf\u201cx\u201d\nprint(a.x)  # OK -- \u53ef\u4ee5\u901a\u8fc7\u5b9e\u4f8b\u8bfb\u53d6\n</code></pre> <p>\u6ca1\u6709\u5fc5\u8981\u4f7f\u7528 <code>ClassVar[t]</code> \u6ce8\u89e3\u6240\u6709\u7c7b\u53d8\u91cf\u3002 \u6ca1\u6709 <code>ClassVar[t]</code> \u6ce8\u91ca\u7684\u5c5e\u6027\u4ecd\u7136\u53ef\u4ee5\u7528\u4f5c\u7c7b\u53d8\u91cf\u3002 \u7136\u800c\uff0cmypy \u4e0d\u4f1a\u963b\u6b62\u5b83\u88ab\u7528\u4f5c\u5b9e\u4f8b\u53d8\u91cf\uff0c\u5982\u524d\u9762\u6240\u8ba8\u8bba\u7684\uff1a</p> <pre><code>class A:\n    x = 0  # \u53ef\u4ee5\u7528\u4f5c\u7c7b\u6216\u5b9e\u4f8b\u53d8\u91cf\n\nA.x += 1  # OK\n\na = A()\na.x = 1  # \u8fd8\u53ef\u4ee5\n</code></pre> <p>\u8bf7\u6ce8\u610f\uff0c <code>ClassVar[t]</code> \u4e0d\u662f\u4e00\u4e2a\u7c7b\uff0c\u5e76\u4e14\u60a8\u4e0d\u80fd\u5c06\u5b83\u4e0e <code>isinstance</code> \u4e00\u8d77\u4f7f\u7528  \u6216 <code>issubclass</code>\u3002 \u5b83\u4e0d\u4f1a\u6539\u53d8 Python \u8fd0\u884c\u65f6\u884c\u4e3a\u2014\u2014\u5b83\u4ec5\u9002\u7528\u4e8e\u7c7b\u578b\u68c0\u67e5\u5668\uff0c\u4f8b\u5982 mypy\uff08\u5bf9\u4eba\u7c7b\u8bfb\u8005\u4e5f\u6709\u5e2e\u52a9\uff09\u3002</p> <p>\u60a8\u8fd8\u53ef\u4ee5\u5728 <code>ClassVar[t]</code> \u6ce8\u91ca\u4e2d\u7701\u7565\u65b9\u62ec\u53f7\u548c\u53d8\u91cf\u7c7b\u578b\uff0c\u4f46\u8fd9\u53ef\u80fd\u4e0d\u4f1a\u662f\u4f60\u6240\u671f\u671b\u7684\uff1a</p> <pre><code>class A:\n    y: ClassVar = 0  # \u7c7b\u578b\u9690\u5f0f\u4e3a Any!\n</code></pre> <p>\u5728\u8fd9\u79cd\u60c5\u51b5\u4e0b\uff0c\u5c5e\u6027\u7684\u7c7b\u578b\u5c06\u9690\u5f0f\u4e3a\u201cAny\u201d\u3002 \u8fd9\u79cd\u884c\u4e3a\u5c06\u6765\u4f1a\u6539\u53d8\uff0c\u56e0\u4e3a\u5b83\u4ee4\u4eba\u60ca\u8bb6\u3002</p> <p>\u663e\u5f0f\u7684 <code>ClassVar[t]</code> \u53ef\u80fd\u7279\u522b\u65b9\u4fbf\u533a\u5206\u5177\u6709\u53ef\u8c03\u7528\u7c7b\u578b\u7684\u7c7b\u53d8\u91cf\u548c\u5b9e\u4f8b\u53d8\u91cf\u3002 \u4f8b\u5982\uff1a</p> <pre><code>from typing import Callable, ClassVar\n\nclass A:\n    foo: Callable[[int], None]\n    bar: ClassVar[Callable[[A, int], None]]\n    bad: Callable[[A], None]\n\nA().foo(42)  # OK\nA().bar(42)  # OK\nA().bad()  # Error: Too few arguments\n</code></pre> <p>Note</p> <p><code>ClassVar[t]</code> \u7c7b\u578b\u53c2\u6570\u4e0d\u80fd\u5305\u542b\u7c7b\u578b\u53d8\u91cf\uff1a<code>ClassVar[T]</code> \u548c <code>ClassVar[list \u5982\u679c</code>T<code>\u662f\u7c7b\u578b\u53d8\u91cf\uff0c\u5219 [T]]</code> \u5747\u65e0\u6548\uff08\u6709\u5173\u66f4\u591a\u4fe1\u606f\uff0c\u8bf7\u53c2\u9605 <code>generic-classes</code> \u5173\u4e8e\u7c7b\u578b\u53d8\u91cf\uff09\u3002</p> <p>Class attribute annotations</p> <p>You can use a <code>ClassVar[t]</code> annotation to explicitly declare that a particular attribute should not be set on instances:</p> <pre><code>from typing import ClassVar\n\nclass A:\n    x: ClassVar[int] = 0  # Class variable only\n\nA.x += 1  # OK\n\na = A()\na.x = 1  # Error: Cannot assign to class variable \"x\" via instance\nprint(a.x)  # OK -- can be read through an instance\n</code></pre> <p>It's not necessary to annotate all class variables using <code>ClassVar[t]</code>. An attribute without the <code>ClassVar[t]</code> annotation can still be used as a class variable. However, mypy won't prevent it from being used as an instance variable, as discussed previously:</p> <pre><code>class A:\n    x = 0  # Can be used as a class or instance variable\n\nA.x += 1  # OK\n\na = A()\na.x = 1  # Also OK\n</code></pre> <p>Note that <code>ClassVar[t]</code> is not a class, and you can't use it with <code>isinstance</code> or <code>issubclass</code>. It does not change Python runtime behavior -- it's only for type checkers such as mypy (and also helpful for human readers).</p> <p>You can also omit the square brackets and the variable type in a <code>ClassVar[t]</code> annotation, but this might not do what you'd expect:</p> <pre><code>class A:\n    y: ClassVar = 0  # Type implicitly Any!\n</code></pre> <p>In this case the type of the attribute will be implicitly <code>Any</code>. This behavior will change in the future, since it's surprising.</p> <p>An explicit <code>ClassVar[t]</code> may be particularly handy to distinguish between class and instance variables with callable types. For example:</p> <pre><code>from typing import Callable, ClassVar\n\nclass A:\n    foo: Callable[[int], None]\n    bar: ClassVar[Callable[[A, int], None]]\n    bad: Callable[[A], None]\n\nA().foo(42)  # OK\nA().bar(42)  # OK\nA().bad()  # Error: Too few arguments\n</code></pre> <p>Note</p> <p>A <code>ClassVar[t]</code> type parameter cannot include type variables: <code>ClassVar[T]</code> and <code>ClassVar[list[T]]</code> are both invalid if <code>T</code> is a type variable (see <code>generic-classes</code> for more about type variables).</p>"},{"location":"mypy/class_basics/#\u91cd\u5199\u9759\u6001\u7c7b\u578b\u65b9\u6cd5","title":"\u91cd\u5199\u9759\u6001\u7c7b\u578b\u65b9\u6cd5","text":"\u4e2d\u6587\u82f1\u6587 <p>\u5f53\u91cd\u5199\u9759\u6001\u7c7b\u578b\u65b9\u6cd5\u65f6\uff0cmypy \u68c0\u67e5\u91cd\u5199\u662f\u5426\u5177\u6709\u517c\u5bb9\u7684\u7b7e\u540d\uff1a</p> <pre><code>class Base:\n    def f(self, x: int) -&gt; None:\n        ...\n\nclass Derived1(Base):\n    def f(self, x: str) -&gt; None:   # Error: type of 'x' incompatible (\u4e0d\u517c\u5bb9)\n        ...\n\nclass Derived2(Base):\n    def f(self, x: int, y: int) -&gt; None:  # Error: too many arguments\n        ...\n\nclass Derived3(Base):\n    def f(self, x: int) -&gt; None:   # OK\n        ...\n\nclass Derived4(Base):\n    def f(self, x: float) -&gt; None:   # OK: mypy \u5c06 int \u89c6\u4e3a float \u7684\u5b50\u7c7b\u578b\n        ...\n\nclass Derived5(Base):\n    def f(self, x: int, y: int = 0) -&gt; None:   # OK: \u63a5\u53d7\u6bd4\u57fa\u7c7b\u66f4\u591a\u53c2\u6570\u7684\u65b9\u6cd5\n</code></pre> <p>Note</p> <p>\u60a8\u8fd8\u53ef\u4ee5\u5728\u91cd\u5199\u4e2d\u534f\u53d8\u5730\u6539\u53d8\u8fd4\u56de\u7c7b\u578b\u3002 \u4f8b\u5982\uff0c\u60a8\u53ef\u4ee5\u4f7f\u7528 <code>list[int]</code> \u7b49\u5b50\u7c7b\u578b\u8986\u76d6\u8fd4\u56de\u7c7b\u578b <code>Iterable[int]</code> \u3002 \u7c7b\u4f3c\u5730\uff0c\u60a8\u53ef\u4ee5\u9006\u53d8\u5730\u6539\u53d8\u53c2\u6570\u7c7b\u578b\u2014\u2014\u5b50\u7c7b\u53ef\u4ee5\u6709\u66f4\u901a\u7528\u7684\u53c2\u6570\u7c7b\u578b\u3002</p> <p>\u4e3a\u4e86\u786e\u4fdd\u91cd\u547d\u540d\u65b9\u6cd5\u65f6\u4ee3\u7801\u4fdd\u6301\u6b63\u786e\uff0c\u5c06\u65b9\u6cd5\u663e\u5f0f\u6807\u8bb0\u4e3a\u8986\u76d6\u57fa\u672c\u65b9\u6cd5\u4f1a\u5f88\u6709\u5e2e\u52a9\u3002 \u8fd9\u53ef\u4ee5\u901a\u8fc7 <code>@override</code> \u88c5\u9970\u5668\u6765\u5b8c\u6210\u3002 \u5982\u679c\u968f\u540e\u91cd\u547d\u540d\u4e86\u57fa\u672c\u65b9\u6cd5\uff0c\u800c\u672a\u91cd\u547d\u540d\u91cd\u5199\u65b9\u6cd5\uff0c\u5219 mypy \u5c06\u663e\u793a\u9519\u8bef\uff1a</p> <pre><code>from typing import override\n\nclass Base:\n    def f(self, x: int) -&gt; None:\n        ...\n    def g_renamed(self, y: str) -&gt; None:\n        ...\n\nclass Derived1(Base):\n    @override\n    def f(self, x: int) -&gt; None:   # OK\n        ...\n\n    @override\n    def g(self, y: str) -&gt; None:   # Error: \u6ca1\u6709\u627e\u5230\u5bf9\u5e94\u7684\u57fa\u7840\u65b9\u6cd5\n        ...\n</code></pre> <p>\u60a8\u8fd8\u53ef\u4ee5\u4f7f\u7528\u52a8\u6001\u7c7b\u578b\u65b9\u6cd5\u8986\u76d6\u9759\u6001\u7c7b\u578b\u65b9\u6cd5\u3002 \u8fd9\u5141\u8bb8\u52a8\u6001\u7c7b\u578b\u4ee3\u7801\u8986\u76d6\u5e93\u7c7b\u4e2d\u5b9a\u4e49\u7684\u65b9\u6cd5\uff0c\u800c\u65e0\u9700\u62c5\u5fc3\u5b83\u4eec\u7684\u7c7b\u578b\u7b7e\u540d\u3002</p> <p>\u4e00\u5982\u65e2\u5f80\uff0c\u4f9d\u8d56\u52a8\u6001\u7c7b\u578b\u4ee3\u7801\u53ef\u80fd\u662f\u4e0d\u5b89\u5168\u7684\u3002 \u6ca1\u6709\u8fd0\u884c\u65f6\u5f3a\u5236\u65b9\u6cd5\u91cd\u5199\u8fd4\u56de\u4e0e\u539f\u59cb\u8fd4\u56de\u7c7b\u578b\u517c\u5bb9\u7684\u503c\uff0c\u56e0\u4e3a\u6ce8\u89e3\u5728\u8fd0\u884c\u65f6\u4e0d\u8d77\u4f5c\u7528\uff1a</p> <pre><code>class Base:\n    def inc(self, x: int) -&gt; int:\n        return x + 1\n\nclass Derived(Base):\n    def inc(self, x):   # Override, dynamically typed\n        return 'hello'  # Incompatible with 'Base', but no mypy error\n</code></pre> <p>Overriding statically typed methods</p> <p>When overriding a statically typed method, mypy checks that the override has a compatible signature:</p> <pre><code>class Base:\n    def f(self, x: int) -&gt; None:\n        ...\n\nclass Derived1(Base):\n    def f(self, x: str) -&gt; None:   # Error: type of 'x' incompatible\n        ...\n\nclass Derived2(Base):\n    def f(self, x: int, y: int) -&gt; None:  # Error: too many arguments\n        ...\n\nclass Derived3(Base):\n    def f(self, x: int) -&gt; None:   # OK\n        ...\n\nclass Derived4(Base):\n    def f(self, x: float) -&gt; None:   # OK: mypy treats int as a subtype of float\n        ...\n\nclass Derived5(Base):\n    def f(self, x: int, y: int = 0) -&gt; None:   # OK: accepts more than the base\n        ...                                    #     class method\n</code></pre> <p>Note</p> <p>You can also vary return types covariantly in overriding. For example, you could override the return type <code>Iterable[int]</code> with a subtype such as <code>list[int]</code>. Similarly, you can vary argument types contravariantly -- subclasses can have more general argument types.</p> <p>In order to ensure that your code remains correct when renaming methods, it can be helpful to explicitly mark a method as overriding a base method. This can be done with the <code>@override</code> decorator. If the base method is then renamed while the overriding method is not, mypy will show an error:</p> <pre><code>from typing import override\n\nclass Base:\n    def f(self, x: int) -&gt; None:\n        ...\n    def g_renamed(self, y: str) -&gt; None:\n        ...\n\nclass Derived1(Base):\n    @override\n    def f(self, x: int) -&gt; None:   # OK\n        ...\n\n    @override\n    def g(self, y: str) -&gt; None:   # Error: no corresponding base method found\n        ...\n</code></pre> <p>You can also override a statically typed method with a dynamically typed one. This allows dynamically typed code to override methods defined in library classes without worrying about their type signatures.</p> <p>As always, relying on dynamically typed code can be unsafe. There is no runtime enforcement that the method override returns a value that is compatible with the original return type, since annotations have no effect at runtime:</p> <pre><code>class Base:\n    def inc(self, x: int) -&gt; int:\n        return x + 1\n\nclass Derived(Base):\n    def inc(self, x):   # Override, dynamically typed\n        return 'hello'  # Incompatible with 'Base', but no mypy error\n</code></pre>"},{"location":"mypy/class_basics/#\u62bd\u8c61\u57fa\u7c7b\u548c\u591a\u91cd\u7ee7\u627f","title":"\u62bd\u8c61\u57fa\u7c7b\u548c\u591a\u91cd\u7ee7\u627f","text":"\u4e2d\u6587\u82f1\u6587 <p>Mypy \u652f\u6301 Python <code>\u62bd\u8c61\u57fa\u7c7b</code> (ABC)\u3002 \u62bd\u8c61\u7c7b\u81f3\u5c11\u6709\u4e00\u4e2a\u62bd\u8c61\u65b9\u6cd5\u6216\u5c5e\u6027\uff0c\u5fc5\u987b\u7531\u4efb\u4f55 \u201c\u5177\u4f53\u201d\uff08\u975e\u62bd\u8c61\uff09\u5b50\u7c7b\u5b9e\u73b0\u3002 \u60a8\u53ef\u4ee5\u4f7f\u7528 <code>abc.ABCMeta</code> \u5143\u7c7b\u548c [<code>@abc.abstractmethod</code>]( https://docs.python.org/3/library/abc.html#abc.abstractmethod\uff09\u51fd\u6570\u88c5\u9970\u5668\u3002 \u4f8b\u5b50\uff1a</p> <pre><code>from abc import ABCMeta, abstractmethod\n\nclass Animal(metaclass=ABCMeta):\n    @abstractmethod\n    def eat(self, food: str) -&gt; None: pass\n\n    @property\n    @abstractmethod\n    def can_walk(self) -&gt; bool: pass\n\nclass Cat(Animal):\n    def eat(self, food: str) -&gt; None:\n        ...  # Body omitted\n\n    @property\n    def can_walk(self) -&gt; bool:\n        return True\n\nx = Animal()  # Error: 'Animal' is abstract due to 'eat' and 'can_walk'\ny = Cat()     # OK\n</code></pre> <p>\u8bf7\u6ce8\u610f\uff0c\u5373\u4f7f\u60a8\u7701\u7565\u4e86 <code>abc.ABCMeta</code> \u5143\u7c7b\uff0cmypy \u4e5f\u4f1a\u6267\u884c\u672a\u5b9e\u73b0\u7684\u62bd\u8c61\u65b9\u6cd5\u7684\u68c0\u67e5\u3002 \u5982\u679c\u5143\u7c7b\u4f1a\u5bfc\u81f4\u8fd0\u884c\u65f6\u5143\u7c7b\u51b2\u7a81\uff0c\u8fd9\u53ef\u80fd\u5f88\u6709\u7528\u3002</p> <p>\u7531\u4e8e\u60a8\u65e0\u6cd5\u521b\u5efa ABC \u7684\u5b9e\u4f8b\uff0c\u56e0\u6b64\u5b83\u4eec\u6700\u5e38\u7528\u4e8e\u7c7b\u578b\u6ce8\u91ca\u4e2d\u3002 \u4f8b\u5982\uff0c\u6b64\u65b9\u6cd5\u63a5\u53d7\u5305\u542b\u4efb\u610f\u52a8\u7269\u7684\u4efb\u610f\u8fed\u4ee3\uff08\u5177\u4f53\u201cAnimal\u201d\u5b50\u7c7b\u7684\u5b9e\u4f8b\uff09\uff1a</p> <pre><code>def feed_all(animals: Iterable[Animal], food: str) -&gt; None:\n    for animal in animals:\n        animal.eat(food)\n</code></pre> <p>Python \u4e2d ABC \u7684\u5de5\u4f5c\u65b9\u5f0f\u6709\u4e00\u4e2a\u91cd\u8981\u7684\u7279\u70b9\u2014\u2014\u7279\u5b9a\u7c7b\u662f\u5426\u662f\u62bd\u8c61\u7684\u5728\u67d0\u79cd\u7a0b\u5ea6\u4e0a\u662f\u9690\u542b\u7684\u3002 \u5728\u4e0b\u9762\u7684\u793a\u4f8b\u4e2d\uff0c\u201cDerived\u201d\u88ab\u89c6\u4e3a\u62bd\u8c61\u57fa\u7c7b\uff0c\u56e0\u4e3a\u201cDerived\u201d\u4ece\u201cBase\u201d\u7ee7\u627f\u4e86\u62bd\u8c61\u201cf\u201d\u65b9\u6cd5\uff0c\u5e76\u4e14\u6ca1\u6709\u663e\u5f0f\u5b9e\u73b0\u5b83\u3002 <code>Derived</code> \u7684\u5b9a\u4e49\u4e0d\u4f1a\u4ece mypy \u4e2d\u751f\u6210\u9519\u8bef\uff0c\u56e0\u4e3a\u5b83\u662f\u6709\u6548\u7684 ABC\uff1a</p> <pre><code>from abc import ABCMeta, abstractmethod\n\nclass Base(metaclass=ABCMeta):\n    @abstractmethod\n    def f(self, x: int) -&gt; None: pass\n\nclass Derived(Base):  # No error -- Derived \u9690\u5f0f \u62bd\u8c61\n    def g(self) -&gt; None:\n        ...\n</code></pre> <p>\u4f46\u662f\uff0c\u5c1d\u8bd5\u521b\u5efa \u201cDerived\u201d \u5b9e\u4f8b\u5c06\u88ab\u62d2\u7edd\uff1a</p> <pre><code>d = Derived()  # Error: 'Derived' is abstract\n</code></pre> <p>Note</p> <p>\u5fd8\u8bb0\u5b9e\u73b0\u62bd\u8c61\u65b9\u6cd5\u662f\u4e00\u4e2a\u5e38\u89c1\u7684\u9519\u8bef\u3002 \u5982\u4e0a\u6240\u793a\uff0c\u5728\u8fd9\u79cd\u60c5\u51b5\u4e0b\uff0c\u7c7b\u5b9a\u4e49\u4e0d\u4f1a\u751f\u6210\u9519\u8bef\uff0c\u4f46\u4efb\u4f55\u6784\u9020\u5b9e\u4f8b\u7684\u5c1d\u8bd5\u90fd\u5c06\u88ab\u6807\u8bb0\u4e3a\u9519\u8bef\u3002</p> <p>Mypy \u5141\u8bb8\u60a8\u7701\u7565\u62bd\u8c61\u65b9\u6cd5\u7684\u4e3b\u4f53\uff0c\u4f46\u5982\u679c\u8fd9\u6837\u505a\uff0c\u901a\u8fc7 <code>super()</code> \u8c03\u7528\u6b64\u7c7b\u65b9\u6cd5\u662f\u4e0d\u5b89\u5168\u7684\u3002 \u4f8b\u5982\uff1a</p> <pre><code>from abc import abstractmethod\nclass Base:\n    @abstractmethod\n    def foo(self) -&gt; int: pass\n    @abstractmethod\n    def bar(self) -&gt; int:\n        return 0\nclass Sub(Base):\n    def foo(self) -&gt; int:\n        return super().foo() + 1  # error: \u901a\u8fc7 super() \u8c03\u7528\u5e26\u6709\u7b80\u5355\u4e3b\u4f53\u7684\u201cBase\u201d\u7684\u62bd\u8c61\u65b9\u6cd5\u201cfoo\u201d\u662f\u4e0d\u5b89\u5168\u7684\n    @abstractmethod\n    def bar(self) -&gt; int:\n        return super().bar() + 1  # \u4e0d\u8fc7\u8fd9\u6ca1\u5173\u7cfb\u3002\n</code></pre> <p>\u4e00\u4e2a\u7c7b\u53ef\u4ee5\u7ee7\u627f\u4efb\u610f\u6570\u91cf\u7684\u7c7b\uff0c\u5305\u62ec\u62bd\u8c61\u7c7b\u548c\u5177\u4f53\u7c7b\u3002 \u4e0e\u666e\u901a\u91cd\u5199\u4e00\u6837\uff0c\u52a8\u6001\u7c7b\u578b\u65b9\u6cd5\u53ef\u4ee5\u91cd\u5199\u6216\u5b9e\u73b0\u4efb\u4f55\u57fa\u7c7b\u4e2d\u5b9a\u4e49\u7684\u9759\u6001\u7c7b\u578b\u65b9\u6cd5\uff0c\u5305\u62ec\u62bd\u8c61\u57fa\u7c7b\u4e2d\u5b9a\u4e49\u7684\u62bd\u8c61\u65b9\u6cd5\u3002</p> <p>\u60a8\u53ef\u4ee5\u4f7f\u7528\u666e\u901a\u5c5e\u6027\u6216\u5b9e\u4f8b\u53d8\u91cf\u6765\u5b9e\u73b0\u62bd\u8c61\u5c5e\u6027\u3002</p> <p>Abstract base classes and multiple inheritance</p> <p>Mypy supports Python <code>abstract base classes</code> (ABCs). Abstract classes have at least one abstract method or property that must be implemented by any concrete (non-abstract) subclass. You can define abstract base classes using the <code>abc.ABCMeta</code> metaclass and the <code>@abc.abstractmethod</code> function decorator. Example:</p> <pre><code>from abc import ABCMeta, abstractmethod\n\nclass Animal(metaclass=ABCMeta):\n    @abstractmethod\n    def eat(self, food: str) -&gt; None: pass\n\n    @property\n    @abstractmethod\n    def can_walk(self) -&gt; bool: pass\n\nclass Cat(Animal):\n    def eat(self, food: str) -&gt; None:\n        ...  # Body omitted\n\n    @property\n    def can_walk(self) -&gt; bool:\n        return True\n\nx = Animal()  # Error: 'Animal' is abstract due to 'eat' and 'can_walk'\ny = Cat()     # OK\n</code></pre> <p>Note that mypy performs checking for unimplemented abstract methods even if you omit the <code>abc.ABCMeta</code> metaclass. This can be useful if the metaclass would cause runtime metaclass conflicts.</p> <p>Since you can't create instances of ABCs, they are most commonly used in type annotations. For example, this method accepts arbitrary iterables containing arbitrary animals (instances of concrete <code>Animal</code> subclasses):</p> <pre><code>def feed_all(animals: Iterable[Animal], food: str) -&gt; None:\n    for animal in animals:\n        animal.eat(food)\n</code></pre> <p>There is one important peculiarity about how ABCs work in Python -- whether a particular class is abstract or not is somewhat implicit. In the example below, <code>Derived</code> is treated as an abstract base class since <code>Derived</code> inherits an abstract <code>f</code> method from <code>Base</code> and doesn't explicitly implement it. The definition of <code>Derived</code> generates no errors from mypy, since it's a valid ABC:</p> <pre><code>from abc import ABCMeta, abstractmethod\n\nclass Base(metaclass=ABCMeta):\n    @abstractmethod\n    def f(self, x: int) -&gt; None: pass\n\nclass Derived(Base):  # No error -- Derived is implicitly abstract\n    def g(self) -&gt; None:\n        ...\n</code></pre> <p>Attempting to create an instance of <code>Derived</code> will be rejected, however:</p> <pre><code>d = Derived()  # Error: 'Derived' is abstract\n</code></pre> <p>Note</p> <p>It's a common error to forget to implement an abstract method. As shown above, the class definition will not generate an error in this case, but any attempt to construct an instance will be flagged as an error.</p> <p>Mypy allows you to omit the body for an abstract method, but if you do so, it is unsafe to call such method via <code>super()</code>. For example:</p> <pre><code>from abc import abstractmethod\nclass Base:\n    @abstractmethod\n    def foo(self) -&gt; int: pass\n    @abstractmethod\n    def bar(self) -&gt; int:\n        return 0\nclass Sub(Base):\n    def foo(self) -&gt; int:\n        return super().foo() + 1  # error: Call to abstract method \"foo\" of \"Base\"\n                                  # with trivial body via super() is unsafe\n    @abstractmethod\n    def bar(self) -&gt; int:\n        return super().bar() + 1  # This is OK however.\n</code></pre> <p>A class can inherit any number of classes, both abstract and concrete. As with normal overrides, a dynamically typed method can override or implement a statically typed method defined in any base class, including an abstract method defined in an abstract base class.</p> <p>You can implement an abstract property using either a normal property or an instance variable.</p>"},{"location":"mypy/class_basics/#slots","title":"Slots","text":"\u4e2d\u6587\u82f1\u6587 <p>\u5f53\u4e00\u4e2a\u7c7b\u663e\u5f0f\u5b9a\u4e49\u4e86 __slots__ \u65f6\uff0cmypy \u5c06\u68c0\u67e5\u5206\u914d\u7ed9\u7684\u6240\u6709\u5c5e\u6027\u662f\u5426\u90fd\u662f <code>__slots__</code> \u7684\u6210\u5458  \uff1a</p> <pre><code>class Album:\n    __slots__ = ('name', 'year')\n\n    def __init__(self, name: str, year: int) -&gt; None:\n       self.name = name\n       self.year = year\n       # Error: Trying to assign name \"released\" that is not in \"__slots__\" of type \"Album\"\n       self.released = True\n\nmy_album = Album('Songs about Python', 2021)\n</code></pre> <p>\u5f53\u6ee1\u8db3\u4ee5\u4e0b\u6761\u4ef6\u65f6\uff0cMypy \u5c06\u4ec5\u68c0\u67e5 <code>__slots__</code> \u7684\u5c5e\u6027\u5206\u914d\uff1a</p> <ol> <li>\u6240\u6709\u57fa\u7c7b\uff08\u5185\u7f6e\u57fa\u7c7b\u9664\u5916\uff09\u5fc5\u987b\u660e\u786e\u5b9a\u4e49 <code>__slots__</code>\uff08\u8fd9\u53cd\u6620\u4e86 Python \u8bed\u4e49\uff09\u3002</li> <li><code>__slots__</code> \u4e0d\u5305\u62ec <code>__dict__</code>\u3002 \u5982\u679c <code>__slots__</code> \u5305\u542b <code>__dict__</code> \uff0c\u5219\u53ef\u4ee5\u8bbe\u7f6e\u4efb\u610f\u5c5e\u6027\uff0c\u7c7b\u4f3c\u4e8e\u672a\u5b9a\u4e49 <code>__slots__</code> \u65f6\uff08\u8fd9\u53cd\u6620\u4e86 Python \u8bed\u4e49\uff09\u3002</li> <li><code>__slots__</code> \u4e2d\u7684\u6240\u6709\u503c\u90fd\u5fc5\u987b\u662f\u5b57\u7b26\u4e32\u6587\u5b57\u3002</li> </ol> <p>Slots</p> <p>When a class has explicitly defined __slots__, mypy will check that all attributes assigned to are members of <code>__slots__</code>:</p> <pre><code>class Album:\n    __slots__ = ('name', 'year')\n\n    def __init__(self, name: str, year: int) -&gt; None:\n       self.name = name\n       self.year = year\n       # Error: Trying to assign name \"released\" that is not in \"__slots__\" of type \"Album\"\n       self.released = True\n\nmy_album = Album('Songs about Python', 2021)\n</code></pre> <p>Mypy will only check attribute assignments against <code>__slots__</code> when the following conditions hold:</p> <ol> <li>All base classes (except builtin ones) must have explicit <code>__slots__</code> defined (this mirrors Python semantics).</li> <li><code>__slots__</code> does not include <code>__dict__</code>. If <code>__slots__</code> includes <code>__dict__</code>, arbitrary attributes can be set, similar to when <code>__slots__</code> is not defined (this mirrors Python semantics).</li> <li>All values in <code>__slots__</code> must be string literals.</li> </ol>"},{"location":"mypy/duck_type_compatibility/","title":"\u9e2d\u5b50\u7c7b\u578b\u517c\u5bb9\u6027","text":"\u4e2d\u6587\u82f1\u6587 <p>\u5728 Python \u4e2d\uff0c\u67d0\u4e9b\u7c7b\u578b\u662f\u517c\u5bb9\u7684\uff0c\u5373\u4f7f\u5b83\u4eec\u4e0d\u662f\u5f7c\u6b64\u7684\u5b50\u7c7b\u3002 \u4f8b\u5982\uff0c\u6bcf\u5f53\u9700\u8981 <code>float</code> \u5bf9\u8c61\u65f6\uff0c<code>int</code>\u5bf9\u8c61\u90fd\u662f\u6709\u6548\u7684\u3002 Mypy \u901a\u8fc7 duck \u7c7b\u578b\u517c\u5bb9\u6027 \u652f\u6301\u8fd9\u79cd\u4e60\u60ef\u7528\u6cd5\u3002 \u4e00\u5c0f\u7ec4\u5185\u7f6e\u7c7b\u578b\u652f\u6301\u8fd9\u4e00\u70b9\uff1a</p> <ul> <li><code>int</code> \u662f\u4e0e <code>float</code> \u548c <code>complex</code> \u517c\u5bb9\u7684\u9e2d\u5b50\u7c7b\u578b\u3002</li> <li><code>float</code> \u662f\u4e0e <code>complex</code> \u517c\u5bb9\u7684\u9e2d\u5b50\u7c7b\u578b\u3002</li> <li><code>bytearray</code> \u548c <code>memoryview</code> \u662f\u4e0e <code>bytes</code> \u517c\u5bb9\u7684\u9e2d\u5b50\u7c7b\u578b\u3002</li> </ul> <p>\u4f8b\u5982\uff0c\u53ea\u8981\u9700\u8981 <code>float</code> \u5bf9\u8c61\uff0cmypy \u5c31\u4f1a\u8ba4\u4e3a <code>int</code> \u5bf9\u8c61\u6709\u6548\u3002 \u56e0\u6b64\uff0c\u8fd9\u6837\u7684\u4ee3\u7801\u5e72\u51c0\u6574\u6d01\uff0c\u5e76\u4e14\u884c\u4e3a\u4e5f\u7b26\u5408\u9884\u671f\uff1a</p> <pre><code>import math\n\ndef degrees_to_radians(degrees: float) -&gt; float:\n    return math.pi * degrees / 180\n\nn = 90  # \u63a8\u65ad\u7c7b\u578b\u201cint\u201d\nprint(degrees_to_radians(n))  # Okay!\n</code></pre> <p>\u60a8\u8fd8\u53ef\u4ee5\u7ecf\u5e38\u4f7f\u7528\u534f\u8bae\u548c\u7ed3\u6784\u5b50\u7c7b\u578b\u4ee5\u66f4\u6709\u539f\u5219\u548c\u53ef\u6269\u5c55\u7684\u65b9\u5f0f\u5b9e\u73b0\u7c7b\u4f3c\u7684\u6548\u679c\u3002 \u534f\u8bae\u4e0d\u9002\u7528\u4e8e\u50cf<code>int</code>\u4e0e<code>float</code>\u517c\u5bb9\u7684\u60c5\u51b5\uff0c\u56e0\u4e3a<code>float</code>\u4e0d\u662f\u4e00\u4e2a\u534f\u8bae\u7c7b\uff0c\u800c\u662f\u4e00\u4e2a\u5e38\u89c4\u7684\u5177\u4f53\u7c7b\uff0c\u5e76\u4e14\u8bb8\u591a\u6807\u51c6\u5e93\u51fd\u6570\u671f\u671b<code>float</code>\uff08\u6216<code>int</code>\uff09\u7684\u5177\u4f53\u5b9e\u4f8b `\uff09\u3002</p> <p>Duck type compatibility</p> <p>In Python, certain types are compatible even though they aren't subclasses of each other. For example, <code>int</code> objects are valid whenever <code>float</code> objects are expected. Mypy supports this idiom via duck type compatibility. This is supported for a small set of built-in types:</p> <ul> <li><code>int</code> is duck type compatible with <code>float</code> and <code>complex</code>.</li> <li><code>float</code> is duck type compatible with <code>complex</code>.</li> <li><code>bytearray</code> and <code>memoryview</code> are duck type compatible with <code>bytes</code>.</li> </ul> <p>For example, mypy considers an <code>int</code> object to be valid whenever a <code>float</code> object is expected.  Thus code like this is nice and clean and also behaves as expected:</p> <pre><code>import math\n\ndef degrees_to_radians(degrees: float) -&gt; float:\n    return math.pi * degrees / 180\n\nn = 90  # Inferred type 'int'\nprint(degrees_to_radians(n))  # Okay!\n</code></pre> <p>You can also often use <code>protocol-types</code> to achieve a similar effect in a more principled and extensible fashion. Protocols don't apply to cases like <code>int</code> being compatible with <code>float</code>, since <code>float</code> is not a protocol class but a regular, concrete class, and many standard library functions expect concrete instances of <code>float</code> (or <code>int</code>).</p>"},{"location":"mypy/dynamic_typing/","title":"\u52a8\u6001\u7c7b\u578b\u7684\u4ee3\u7801","text":"\u4e2d\u6587\u82f1\u6587 <p>\u5728 getting-started-dynamic-vs-static \u4e2d\uff0c\u6211\u4eec\u8ba8\u8bba\u4e86\u51fd\u6570\u4f53\u5982\u4f55 \u5728\u5176\u51fd\u6570\u4e2d\u6ca1\u6709\u4efb\u4f55\u663e\u5f0f\u7c7b\u578b\u6ce8\u91ca\u7684\u51fd\u6570\u662f<code>\u52a8\u6001\u7c7b\u578b\u7684</code>\uff0c\u5e76\u4e14 mypy \u4e0d\u4f1a\u68c0\u67e5\u5b83\u4eec\u3002 \u5728\u672c\u8282\u4e2d\uff0c\u6211\u4eec\u5c06\u8be6\u7ec6\u8ba8\u8bba\u8fd9\u610f\u5473\u7740\u4ec0\u4e48\u4ee5\u53ca\u5982\u4f55\u5728\u66f4\u7ec6\u7c92\u5ea6\u7684\u57fa\u7840\u4e0a\u542f\u7528\u52a8\u6001\u7c7b\u578b\u3002</p> <p>\u5982\u679c\u60a8\u7684\u4ee3\u7801\u5bf9\u4e8e mypy \u6765\u8bf4\u592a\u795e\u5947\u800c\u65e0\u6cd5\u7406\u89e3\uff0c\u60a8\u53ef\u4ee5\u901a\u8fc7\u663e\u5f0f\u8d4b\u4e88\u53d8\u91cf\u6216\u53c2\u6570<code>Any</code>\u7c7b\u578b\u6765\u4f7f\u5176\u52a8\u6001\u7c7b\u578b\u5316\u3002 Mypy \u57fa\u672c\u4e0a\u53ef\u4ee5\u8ba9\u60a8\u4f7f\u7528<code>Any</code>\u7c7b\u578b\u7684\u503c\u6267\u884c\u4efb\u4f55\u64cd\u4f5c\uff0c\u5305\u62ec\u5c06<code>Any</code>\u7c7b\u578b\u7684\u503c\u5206\u914d\u7ed9\u4efb\u4f55\u7c7b\u578b\u7684\u53d8\u91cf\uff08\u53cd\u4e4b\u4ea6\u7136\uff09\u3002</p> <pre><code>from typing import Any\n\nnum = 1         # \u9759\u6001\u7c7b\u578b\uff08\u63a8\u65ad\u4e3a int\uff09\nnum = 'x'       # error: Incompatible types in assignment (expression has type \"str\", variable has type \"int\")\n\ndyn: Any = 1    # \u52a8\u6001\u7c7b\u578b\uff08\u7c7b\u578b Any\uff09\ndyn = 'x'       # OK\n\nnum = dyn       # \u6ca1\u6709\u9519\u8bef\uff0cmypy \u4f1a\u8ba9\u4f60\u5c06 Any \u7c7b\u578b\u7684\u503c\u8d4b\u7ed9\u4efb\u4f55\u53d8\u91cf\nnum += 1        # Oops, mypy \u4ecd\u7136\u8ba4\u4e3a num \u662f int\n</code></pre> <p>\u60a8\u53ef\u4ee5\u5c06 <code>Any</code> \u89c6\u4e3a\u672c\u5730\u7981\u7528\u7c7b\u578b\u68c0\u67e5\u7684\u4e00\u79cd\u65b9\u6cd5\u3002 \u8bf7\u53c2\u9605 silencing-type-errors \u6765\u4e86\u89e3\u5173\u95ed\u7c7b\u578b\u68c0\u67e5\u5668\u7684\u5176\u4ed6\u65b9\u6cd5\u3002</p> <p>Dynamically typed code</p> <p>In <code>getting-started-dynamic-vs-static</code>, we discussed how bodies of functions that don't have any explicit type annotations in their function are \"dynamically typed\" and that mypy will not check them. In this section, we'll talk a little bit more about what that means and how you can enable dynamic typing on a more fine grained basis.</p> <p>In cases where your code is too magical for mypy to understand, you can make a variable or parameter dynamically typed by explicitly giving it the type <code>Any</code>. Mypy will let you do basically anything with a value of type <code>Any</code>, including assigning a value of type <code>Any</code> to a variable of any type (or vice versa).</p> <pre><code>from typing import Any\n\nnum = 1         # Statically typed (inferred to be int)\nnum = 'x'       # error: Incompatible types in assignment (expression has type \"str\", variable has type \"int\")\n\ndyn: Any = 1    # Dynamically typed (type Any)\ndyn = 'x'       # OK\n\nnum = dyn       # No error, mypy will let you assign a value of type Any to any variable\nnum += 1        # Oops, mypy still thinks num is an int\n</code></pre> <p>You can think of <code>Any</code> as a way to locally disable type checking. See <code>silencing-type-errors</code> for other ways you can shut up the type checker.</p>"},{"location":"mypy/dynamic_typing/#\u5bf9\u4efb\u610f\u503c\u7684\u64cd\u4f5c","title":"\u5bf9\u4efb\u610f\u503c\u7684\u64cd\u4f5c","text":"<p>Operations on Any values</p> \u4e2d\u6587\u82f1\u6587 <p>\u60a8\u53ef\u4ee5\u4f7f\u7528\u7c7b\u578b\u4e3a<code>Any</code>\u7684\u503c\u6267\u884c\u4efb\u4f55\u64cd\u4f5c\uff0c\u5e76\u4e14\u7c7b\u578b\u68c0\u67e5\u5668\u4e0d\u4f1a\u62b1\u6028\uff1a</p> <pre><code>def f(x: Any) -&gt; int:\n    # \u8fd9\u4e9b\u90fd\u662f\u6709\u6548\u7684\uff01\n    x.foobar(1, y=2)\n    print(x[3] + 'f')\n    if x:\n        x.z = x(2)\n    open(x).read()\n    return x\n</code></pre> <p>\u4ece<code>Any</code>\u503c\u6d3e\u751f\u7684\u503c\u901a\u5e38\u4e5f\u9690\u5f0f\u5177\u6709<code>Any</code>\u7c7b\u578b\uff0c\u56e0\u4e3a mypy \u65e0\u6cd5\u63a8\u65ad\u51fa\u66f4\u7cbe\u786e\u7684\u7ed3\u679c\u7c7b\u578b\u3002 \u4f8b\u5982\uff0c\u5982\u679c\u60a8\u83b7\u53d6<code>Any</code>\u503c\u7684\u5c5e\u6027\u6216\u8c03\u7528<code>Any</code>\u503c\uff0c\u5219\u7ed3\u679c\u4e3a<code>Any</code>\uff1a</p> <pre><code>def f(x: Any) -&gt; None:\n    y = x.foo()\n    reveal_type(y)  # \u63ed\u793a\u7684\u7c7b\u578b\u662f \"Any\"\n    z = y.bar(\"mypy will let you do anything to y\")\n    reveal_type(z)  # \u63ed\u793a\u7684\u7c7b\u578b\u662f \"Any\"\n</code></pre> <p>\u9664\u975e\u60a8\u5c0f\u5fc3\uff0c\u5426\u5219<code>Any</code>\u7c7b\u578b\u90fd\u53ef\u80fd\u5728\u60a8\u7684\u7a0b\u5e8f\u4e2d\u4f20\u64ad\uff0c\u4ece\u800c\u964d\u4f4e\u7c7b\u578b\u68c0\u67e5\u7684\u6548\u7387\u3002</p> <p>\u6ca1\u6709\u6ce8\u91ca\u7684\u51fd\u6570\u53c2\u6570\u4e5f\u9690\u5f0f\u4e3a\u201cAny\u201d\uff1a</p> <pre><code>def f(x) -&gt; None:\n    reveal_type(x)  # \u63ed\u793a\u7684\u7c7b\u578b\u662f \"Any\"\n    x.can.do[\"anything\", x](\"wants\", 2)\n</code></pre> <p>\u60a8\u53ef\u4ee5\u4f7f\u7528 <code>--disallow-untyped-defs</code> \u8ba9 mypy \u8b66\u544a\u60a8\u6709\u5173\u65e0\u7c7b\u578b\u51fd\u6570\u53c2\u6570\u7684\u4fe1\u606f\u6807\u5fd7\u3002</p> <p>\u7f3a\u5c11\u7c7b\u578b\u53c2\u6570\u7684\u6cdb\u578b\u7c7b\u578b\u4f1a\u5c06\u8fd9\u4e9b\u53c2\u6570\u9690\u5f0f\u89c6\u4e3a<code>Any</code>\uff1a</p> <pre><code>from typing import List\n\ndef f(x: List) -&gt; None:\n    reveal_type(x)        # \u63ed\u793a\u7684\u7c7b\u578b\u662f \"builtins.list[Any]\"\n    reveal_type(x[0])     # \u63ed\u793a\u7684\u7c7b\u578b\u662f \"Any\"\n    x[0].anything_goes()  # OK\n</code></pre> <p>\u60a8\u53ef\u4ee5\u4f7f\u7528 <code>--disallow-any-generics</code>\u8ba9 mypy \u8b66\u544a\u60a8\u6709\u5173\u975e\u7c7b\u578b\u5316\u51fd\u6570\u53c2\u6570\u7684\u4fe1\u606f\u6807\u5fd7\u3002</p> <p>\u6700\u540e\uff0c<code>Any</code>\u7c7b\u578b\u6cc4\u6f0f\u5230\u7a0b\u5e8f\u4e2d\u7684\u53e6\u4e00\u4e2a\u4e3b\u8981\u6765\u6e90\u662f\u6765\u81ea mypy \u4e0d\u77e5\u9053\u7684\u7b2c\u4e09\u65b9\u5e93\u3002 \u4f7f\u7528 <code>--ignore-missing-imports</code> \u6807\u5fd7\u65f6\u5c24\u5176\u5982\u6b64\u3002 \u6709\u5173\u6b64\u5185\u5bb9\u7684\u66f4\u591a\u4fe1\u606f\uff0c\u8bf7\u53c2\u9605 <code>fix-missing-imports</code>\u3002</p> <p>You can do anything using a value with type <code>Any</code>, and the type checker will not complain:</p> <pre><code>def f(x: Any) -&gt; int:\n    # All of these are valid!\n    x.foobar(1, y=2)\n    print(x[3] + 'f')\n    if x:\n        x.z = x(2)\n    open(x).read()\n    return x\n</code></pre> <p>Values derived from an <code>Any</code> value also usually have the type <code>Any</code> implicitly, as mypy can't infer a more precise result type. For example, if you get the attribute of an <code>Any</code> value or call a <code>Any</code> value the result is <code>Any</code>:</p> <pre><code>def f(x: Any) -&gt; None:\n    y = x.foo()\n    reveal_type(y)  # \u63ed\u793a\u7684\u7c7b\u578b\u662f \"Any\"\n    z = y.bar(\"mypy will let you do anything to y\")\n    reveal_type(z)  # \u63ed\u793a\u7684\u7c7b\u578b\u662f \"Any\"\n</code></pre> <p><code>Any</code> types may propagate through your program, making type checking less effective, unless you are careful.</p> <p>Function parameters without annotations are also implicitly <code>Any</code>:</p> <pre><code>def f(x) -&gt; None:\n    reveal_type(x)  # \u63ed\u793a\u7684\u7c7b\u578b\u662f \"Any\"\n    x.can.do[\"anything\", x](\"wants\", 2)\n</code></pre> <p>You can make mypy warn you about untyped function parameters using the <code>--disallow-untyped-defs</code> flag.</p> <p>Generic types missing type parameters will have those parameters implicitly treated as <code>Any</code>:</p> <pre><code>from typing import List\n\ndef f(x: List) -&gt; None:\n    reveal_type(x)        # \u63ed\u793a\u7684\u7c7b\u578b\u662f \"builtins.list[Any]\"\n    reveal_type(x[0])     # \u63ed\u793a\u7684\u7c7b\u578b\u662f \"Any\"\n    x[0].anything_goes()  # OK\n</code></pre> <p>You can make mypy warn you about untyped function parameters using the <code>--disallow-any-generics</code> flag.</p> <p>Finally, another major source of <code>Any</code> types leaking into your program is from third party libraries that mypy does not know about. This is particularly the case when using the <code>--ignore-missing-imports</code> flag. See <code>fix-missing-imports</code> for more information about this.</p>"},{"location":"mypy/dynamic_typing/#any-\u548c-object","title":"Any \u548c object","text":"<p>Any vs. object</p> \u4e2d\u6587\u82f1\u6587 <p>\u7c7b\u578b <code>object</code> \u662f\u53e6\u4e00\u79cd\u53ef\u4ee5\u5c06\u4efb\u610f\u7c7b\u578b\u7684\u5b9e\u4f8b\u4f5c\u4e3a\u503c\u7684\u7c7b\u578b\u3002 \u4e0e <code>Any</code> \u4e0d\u540c\uff0c<code>object</code> \u662f\u4e00\u4e2a\u666e\u901a\u7684\u9759\u6001\u7c7b\u578b\uff08\u7c7b\u4f3c\u4e8e Java \u4e2d\u7684 <code>Object</code>\uff09\uff0c\u5e76\u4e14\u4ec5 <code>object</code> \u503c\u63a5\u53d7\u5bf9\u6240\u6709\u7c7b\u578b\u6709\u6548\u7684\u64cd\u4f5c\u3002 \u8fd9\u4e9b\u90fd\u662f\u6709\u6548\u7684\uff1a</p> <pre><code>def f(o: object) -&gt; None:\n    if o:\n        print(o)\n    print(isinstance(o, int))\n    o = 2\n    o = 'foo'\n</code></pre> <p>\u7136\u800c\uff0c\u8fd9\u4e9b\u88ab\u6807\u8bb0\u4e3a\u9519\u8bef\uff0c\u56e0\u4e3a\u5e76\u975e\u6240\u6709\u5bf9\u8c61\u90fd\u652f\u6301\u8fd9\u4e9b\u64cd\u4f5c\uff1a</p> <pre><code>def f(o: object) -&gt; None:\n    o.foo()       # Error!\n    o + 2         # Error!\n    open(o)       # Error!\n    n: int = 1\n    n = o         # Error!\n</code></pre> <p>\u5982\u679c\u60a8\u4e0d\u786e\u5b9a\u662f\u5426\u9700\u8981\u4f7f\u7528<code>object</code>\u6216<code>Any</code>\uff0c\u8bf7\u4f7f\u7528<code>object</code>\u2014\u2014\u4ec5\u5f53\u60a8\u6536\u5230\u7c7b\u578b\u68c0\u67e5\u5668\u6295\u8bc9\u65f6\u624d\u5207\u6362\u5230\u4f7f\u7528<code>Any</code>\u3002</p> <p>\u60a8\u53ef\u4ee5\u4f7f\u7528\u4e0d\u540c\u7684<code>\u7c7b\u578b\u6536\u7f29</code>\u6280\u672f\u6765\u7f29\u5c0f<code>\u5bf9\u8c61</code> \u8f6c\u6362\u4e3a\u66f4\u5177\u4f53\u7684\u7c7b\u578b\uff08\u5b50\u7c7b\u578b\uff09\uff0c\u4f8b\u5982 <code>int</code>\u3002 \u52a8\u6001\u7c7b\u578b\u503c\uff08\u7c7b\u578b\u4e3a<code>Any</code>\u7684\u503c\uff09\u4e0d\u9700\u8981\u7c7b\u578b\u7f29\u5c0f\u3002</p> <p>The type <code>object</code> is another type that can have an instance of arbitrary type as a value. Unlike <code>Any</code>, <code>object</code> is an ordinary static type (it is similar to <code>Object</code> in Java), and only operations valid for all types are accepted for <code>object</code> values. These are all valid:</p> <pre><code>def f(o: object) -&gt; None:\n    if o:\n        print(o)\n    print(isinstance(o, int))\n    o = 2\n    o = 'foo'\n</code></pre> <p>These are, however, flagged as errors, since not all objects support these operations:</p> <pre><code>def f(o: object) -&gt; None:\n    o.foo()       # Error!\n    o + 2         # Error!\n    open(o)       # Error!\n    n: int = 1\n    n = o         # Error!\n</code></pre> <p>If you're not sure whether you need to use <code>object</code> or <code>Any</code>, use <code>object</code> -- only switch to using <code>Any</code> if you get a type checker complaint.</p> <p>You can use different <code>type narrowing</code> techniques to narrow <code>object</code> to a more specific type (subtype) such as <code>int</code>. Type narrowing is not needed with dynamically typed values (values with type <code>Any</code>).</p>"},{"location":"mypy/existing_code/","title":"\u5c06 mypy \u4e0e\u73b0\u6709\u4ee3\u7801\u5e93\u7ed3\u5408\u4f7f\u7528","text":"<p>Using mypy with an existing codebase</p> \u4e2d\u6587\u82f1\u6587 <p>\u672c\u8282\u89e3\u91ca\u4e86\u5982\u4f55\u5728\u4e00\u4e2a\u73b0\u6709\u7684\u3001\u89c4\u6a21\u8f83\u5927\u7684\u4ee3\u7801\u5e93\u4e2d\u4f7f\u7528 mypy\uff0c\u800c\u8be5\u4ee3\u7801\u5e93\u51e0\u4e4e\u6ca1\u6709\u6216\u5b8c\u5168\u6ca1\u6709\u7c7b\u578b\u6ce8\u89e3\u3002\u5982\u679c\u4f60\u662f\u521d\u5b66\u8005\uff0c\u53ef\u4ee5\u8df3\u8fc7\u672c\u8282\u3002</p> <p>This section explains how to get started using mypy with an existing, significant codebase that has little or no type annotations. If you are a beginner, you can skip this section.</p>"},{"location":"mypy/existing_code/#\u4ece\u5c0f\u4e8b\u505a\u8d77","title":"\u4ece\u5c0f\u4e8b\u505a\u8d77","text":"<p>Start small</p> \u4e2d\u6587\u82f1\u6587 <p>\u5982\u679c\u4f60\u7684\u4ee3\u7801\u5e93\u5f88\u5927\uff0c\u5efa\u8bae\u5148\u9009\u62e9\u4e00\u4e2a\u5b50\u96c6\uff08\u4f8b\u5982 5,000 \u5230 50,000 \u884c\u4ee3\u7801\uff09\uff0c\u5e76\u8ba9 mypy \u9996\u5148\u6210\u529f\u8fd0\u884c\u5728\u8fd9\u4e2a\u5b50\u96c6\u4e0a\uff0c\u5728\u6dfb\u52a0\u6ce8\u89e3\u4e4b\u524d\u3002\u8fd9\u5e94\u8be5\u5728\u4e00\u4e24\u5929\u5185\u5c31\u80fd\u5b8c\u6210\u3002\u8d8a\u65e9\u8ba9 mypy \u5728\u4f60\u7684\u4ee3\u7801\u5e93\u4e0a\u8fd0\u884c\u901a\u8fc7\uff0c\u4f60\u5c31\u80fd\u8d8a\u65e9\u4ece\u4e2d\u53d7\u76ca\u3002</p> <p>\u4f60\u53ef\u80fd\u9700\u8981\u4fee\u590d\u4e00\u4e9b mypy \u62a5\u544a\u7684\u9519\u8bef\uff0c\u65b9\u6cd5\u662f\u63d2\u5165 mypy \u8981\u6c42\u7684\u6ce8\u89e3\uff0c\u6216\u8005\u901a\u8fc7\u6dfb\u52a0 <code># type: ignore</code> \u6ce8\u91ca\u6765\u5ffd\u7565\u4f60\u73b0\u5728\u4e0d\u60f3\u4fee\u590d\u7684\u9519\u8bef\u3002</p> <p>\u6211\u4eec\u5c06\u5728\u4e0b\u9762\u7684\u5404\u4e2a\u90e8\u5206\u4e2d\u63d0\u5230\u4e00\u4e9b\u8ba9 mypy \u901a\u8fc7\u4ee3\u7801\u5e93\u7684\u6280\u5de7\u3002</p> <p>If your codebase is large, pick a subset of your codebase (say, 5,000 to 50,000 lines) and get mypy to run successfully only on this subset at first, before adding annotations. This should be doable in a day or two. The sooner you get some form of mypy passing on your codebase, the sooner you benefit.</p> <p>You\u2019ll likely need to fix some mypy errors, either by inserting annotations requested by mypy or by adding <code># type: ignore</code> comments to silence errors you don\u2019t want to fix now.</p> <p>We\u2019ll mention some tips for getting mypy passing on your codebase in various sections below.</p>"},{"location":"mypy/existing_code/#\u6301\u7eed\u8fd0\u884c-mypy-\u5e76\u9632\u6b62\u56de\u5f52","title":"\u6301\u7eed\u8fd0\u884c mypy \u5e76\u9632\u6b62\u56de\u5f52","text":"<p>Run mypy consistently and prevent regressions</p> \u4e2d\u6587\u82f1\u6587 <p>\u786e\u4fdd\u4f60\u4ee3\u7801\u5e93\u4e2d\u7684\u6240\u6709\u5f00\u53d1\u4eba\u5458\u4ee5\u76f8\u540c\u7684\u65b9\u5f0f\u8fd0\u884c mypy\u3002\u6709\u4e00\u79cd\u65b9\u6cd5\u662f\u5c06 mypy \u7684\u8c03\u7528\u547d\u4ee4\u6dfb\u52a0\u5230\u4ee3\u7801\u5e93\u4e2d\u7684\u4e00\u4e2a\u5c0f\u811a\u672c\u4e2d\uff0c\u6216\u8005\u5c06 mypy \u7684\u8c03\u7528\u547d\u4ee4\u6dfb\u52a0\u5230\u4f60\u7528\u6765\u8fd0\u884c\u6d4b\u8bd5\u7684\u73b0\u6709\u5de5\u5177\u4e2d\uff0c\u4f8b\u5982 tox\u3002</p> <ul> <li> <p>\u786e\u4fdd\u6240\u6709\u4eba\u90fd\u4f7f\u7528\u76f8\u540c\u7684\u9009\u9879\u8fd0\u884c mypy\u3002\u5c06 mypy \u7684\u914d\u7f6e\u6587\u4ef6\u68c0\u67e5\u5230\u4ee3\u7801\u5e93\u4e2d\u662f\u6700\u7b80\u5355\u7684\u505a\u6cd5\u3002</p> </li> <li> <p>\u786e\u4fdd\u6240\u6709\u4eba\u68c0\u67e5\u76f8\u540c\u7684\u6587\u4ef6\u96c6\u3002\u6709\u5173\u8be6\u7ec6\u4fe1\u606f\uff0c\u8bf7\u53c2\u9605\u201c\u6307\u5b9a\u8981\u68c0\u67e5\u7684\u4ee3\u7801\u201d\u3002</p> </li> <li> <p>\u786e\u4fdd\u6240\u6709\u4eba\u4f7f\u7528\u76f8\u540c\u7248\u672c\u7684 mypy\uff0c\u4f8b\u5982\u5c06 mypy \u4e0e\u5176\u4ed6\u5f00\u53d1\u9700\u6c42\u4e00\u8d77\u56fa\u5b9a\u7248\u672c\u3002</p> </li> </ul> <p>\u7279\u522b\u662f\uff0c\u4f60\u9700\u8981\u786e\u4fdd\u5c3d\u65e9\u5c06 mypy \u96c6\u6210\u5230\u4f60\u7684\u6301\u7eed\u96c6\u6210\uff08CI\uff09\u7cfb\u7edf\u4e2d\u3002\u8fd9\u5c06\u9632\u6b62\u65b0\u7684\u7c7b\u578b\u9519\u8bef\u88ab\u5f15\u5165\u5230\u4ee3\u7801\u5e93\u4e2d\u3002</p> <p>\u4e00\u4e2a\u7b80\u5355\u7684 CI \u811a\u672c\u53ef\u80fd\u5982\u4e0b\u6240\u793a\uff1a</p> <pre><code>python3 -m pip install mypy==1.8\n# \u8fd0\u884c\u6807\u51c6\u5316\u7684 mypy \u8c03\u7528\u547d\u4ee4\uff0c\u4f8b\u5982\uff1a\nmypy my_project\n# \u8fd9\u4e5f\u53ef\u80fd\u7c7b\u4f3c\u4e8e `scripts/run_mypy.sh`\u3001`tox run -e mypy`\u3001`make mypy` \u7b49\n</code></pre> <p>Make sure all developers on your codebase run mypy the same way. One way to ensure this is adding a small script with your mypy invocation to your codebase, or adding your mypy invocation to existing tools you use to run tests, like tox.</p> <ul> <li> <p>Make sure everyone runs mypy with the same options. Checking a mypy configuration file into your codebase is the easiest way to do this.</p> </li> <li> <p>Make sure everyone type checks the same set of files. See Specifying code to be checked for details.</p> </li> <li> <p>Make sure everyone runs mypy with the same version of mypy, for instance by pinning mypy with the rest of your dev requirements.</p> </li> </ul> <p>In particular, you\u2019ll want to make sure to run mypy as part of your Continuous Integration (CI) system as soon as possible. This will prevent new type errors from being introduced into your codebase.</p> <p>A simple CI script could look something like this:</p> <pre><code>python3 -m pip install mypy==1.8\n# Run your standardised mypy invocation, e.g.\nmypy my_project\n# This could also look like `scripts/run_mypy.sh`, `tox run -e mypy`, `make mypy`, etc\n</code></pre>"},{"location":"mypy/existing_code/#\u5ffd\u7565\u67d0\u4e9b\u6a21\u5757\u7684\u9519\u8bef","title":"\u5ffd\u7565\u67d0\u4e9b\u6a21\u5757\u7684\u9519\u8bef","text":"<p>Ignoring errors from certain modules</p> \u4e2d\u6587\u82f1\u6587 <p>\u9ed8\u8ba4\u60c5\u51b5\u4e0b\uff0cmypy \u4f1a\u8ddf\u968f\u4ee3\u7801\u4e2d\u7684\u5bfc\u5165\u5e76\u5c1d\u8bd5\u68c0\u67e5\u6240\u6709\u5185\u5bb9\u3002\u8fd9\u610f\u5473\u7740\u5373\u4f7f\u4f60\u53ea\u4f20\u5165\u51e0\u4e2a\u6587\u4ef6\uff0cmypy \u4ecd\u53ef\u80fd\u5904\u7406\u5927\u91cf\u5bfc\u5165\u7684\u6587\u4ef6\uff0c\u4ece\u800c\u53ef\u80fd\u5bfc\u81f4\u8bb8\u591a\u4f60\u5f53\u524d\u4e0d\u60f3\u5904\u7406\u7684\u9519\u8bef\u3002</p> <p>\u4e00\u79cd\u5904\u7406\u8fd9\u79cd\u60c5\u51b5\u7684\u65b9\u6cd5\u662f\u5ffd\u7565\u90a3\u4e9b\u4f60\u8fd8\u6ca1\u51c6\u5907\u597d\u8fdb\u884c\u7c7b\u578b\u68c0\u67e5\u7684\u6a21\u5757\u4e2d\u7684\u9519\u8bef\u3002\u5bf9\u4e8e\u8fd9\u79cd\u60c5\u51b5\uff0cignore_errors \u9009\u9879\u975e\u5e38\u6709\u7528\u3002\u4f8b\u5982\uff0c\u5982\u679c\u4f60\u8fd8\u4e0d\u51c6\u5907\u5904\u7406\u6765\u81ea <code>package_to_fix_later</code> \u6a21\u5757\u7684\u9519\u8bef\uff1a</p> <pre><code>[mypy-package_to_fix_later.*]\nignore_errors = True\n</code></pre> <p>\u4f60\u751a\u81f3\u53ef\u4ee5\u53cd\u8fc7\u6765\u64cd\u4f5c\uff0c\u5728\u5168\u5c40\u914d\u7f6e\u4e2d\u8bbe\u7f6e <code>ignore_errors = True</code>\uff0c\u7136\u540e\u53ea\u5bf9\u4f60\u51c6\u5907\u597d\u8fdb\u884c\u7c7b\u578b\u68c0\u67e5\u7684\u6a21\u5757\u542f\u7528\u9519\u8bef\u62a5\u544a\uff0c\u5373\u8bbe\u7f6e <code>ignore_errors = False</code>\u3002</p> <p>mypy \u7684\u914d\u7f6e\u6587\u4ef6\u5141\u8bb8\u7684\u6309\u6a21\u5757\u914d\u7f6e\u975e\u5e38\u6709\u7528\u3002\u8bb8\u591a\u914d\u7f6e\u9009\u9879\u90fd\u53ef\u4ee5\u4ec5\u9488\u5bf9\u7279\u5b9a\u6a21\u5757\u542f\u7528\u6216\u7981\u7528\u3002\u7279\u522b\u662f\uff0c\u4f60\u8fd8\u53ef\u4ee5\u6309\u6a21\u5757\u542f\u7528\u6216\u7981\u7528\u5404\u79cd\u9519\u8bef\u4ee3\u7801\uff0c\u8be6\u60c5\u8bf7\u53c2\u9605 Error codes\u3002</p> <p>By default mypy will follow imports in your code and try to check everything. This means even if you only pass in a few files to mypy, it may still process a large number of imported files. This could potentially result in lots of errors you don\u2019t want to deal with at the moment.</p> <p>One way to deal with this is to ignore errors in modules you aren\u2019t yet ready to type check. The ignore_errors option is useful for this, for instance, if you aren\u2019t yet ready to deal with errors from <code>package_to_fix_later</code>:</p> <pre><code>[mypy-package_to_fix_later.*]\nignore_errors = True\n</code></pre> <p>You could even invert this, by setting <code>ignore_errors = True</code> in your global config section and only enabling error reporting with <code>ignore_errors = False</code> for the set of modules you are ready to type check.</p> <p>The per-module configuration that mypy\u2019s configuration file allows can be extremely useful. Many configuration options can be enabled or disabled only for specific modules. In particular, you can also enable or disable various error codes on a per-module basis, see Error codes.</p>"},{"location":"mypy/existing_code/#\u4fee\u590d\u4e0e\u5bfc\u5165\u76f8\u5173\u7684\u9519\u8bef","title":"\u4fee\u590d\u4e0e\u5bfc\u5165\u76f8\u5173\u7684\u9519\u8bef","text":"<p>Fixing errors related to imports</p> \u4e2d\u6587\u82f1\u6587 <p>\u4f60\u53ef\u80fd\u4f1a\u9047\u5230\u7684\u4e00\u7c7b\u5e38\u89c1\u9519\u8bef\u662f mypy \u5173\u4e8e\u627e\u4e0d\u5230\u6a21\u5757\u3001\u6a21\u5757\u6ca1\u6709\u7c7b\u578b\u6216\u6ca1\u6709\u5b58\u6839\u6587\u4ef6\u7684\u9519\u8bef\uff1a</p> <pre><code>core/config.py:7: error: Cannot find implementation or library stub for module named 'frobnicate'\ncore/model.py:9: error: Cannot find implementation or library stub for module named 'acme'\n...\n</code></pre> <p>\u6709\u65f6\uff0c\u8fd9\u4e9b\u95ee\u9898\u53ef\u4ee5\u901a\u8fc7\u5728\u8fd0\u884c <code>mypy</code> \u7684\u73af\u5883\u4e2d\u5b89\u88c5\u76f8\u5173\u7684\u5305\u6216\u5b58\u6839\u5e93\u6765\u89e3\u51b3\u3002</p> <p>\u6709\u5173\u8fd9\u4e9b\u9519\u8bef\u4ee5\u53ca\u4fee\u590d\u65b9\u6cd5\u7684\u5b8c\u6574\u53c2\u8003\uff0c\u8bf7\u53c2\u9605 Missing imports\u3002</p> <p>\u4f60\u53ef\u80fd\u4f1a\u53d1\u73b0\u9700\u8981\u6291\u5236\u6240\u6709\u6765\u81ea\u6ca1\u6709\u7c7b\u578b\u7684\u6a21\u5757\u7684\u5bfc\u5165\u9519\u8bef\u3002\u5982\u679c\u4f60\u53ea\u5728\u4e00\u4e24\u4e2a\u5730\u65b9\u5bfc\u5165\u4e86\u8be5\u6a21\u5757\uff0c\u53ef\u4ee5\u4f7f\u7528 <code># type: ignore</code> \u6ce8\u91ca\u3002\u4f8b\u5982\uff0c\u5728\u8fd9\u91cc\uff0c\u6211\u4eec\u5ffd\u7565\u4e86\u4e00\u4e2a\u5173\u4e8e\u6ca1\u6709\u5b58\u6839\u7684\u7b2c\u4e09\u65b9\u6a21\u5757 <code>frobnicate</code> \u7684\u9519\u8bef\uff0c\u4f7f\u7528\u4e86 <code># type: ignore</code>\uff1a</p> <pre><code>import frobnicate  # type: ignore\n...\nfrobnicate.initialize()  # OK (\u4f46\u4e0d\u4f1a\u88ab\u68c0\u67e5)\n</code></pre> <p>\u4f46\u5982\u679c\u4f60\u5728\u591a\u4e2a\u5730\u65b9\u5bfc\u5165\u8be5\u6a21\u5757\uff0c\u8fd9\u79cd\u65b9\u6cd5\u5c31\u663e\u5f97\u7b28\u62d9\u4e86\u3002\u5728\u8fd9\u79cd\u60c5\u51b5\u4e0b\uff0c\u6211\u4eec\u5efa\u8bae\u4f7f\u7528\u914d\u7f6e\u6587\u4ef6\u3002\u4f8b\u5982\uff0c\u8981\u5728\u6574\u4e2a\u4ee3\u7801\u5e93\u4e2d\u7981\u7528\u5173\u4e8e\u5bfc\u5165 <code>frobnicate</code> \u548c <code>acme</code> \u7684\u9519\u8bef\uff0c\u53ef\u4ee5\u4f7f\u7528\u5982\u4e0b\u914d\u7f6e\uff1a</p> <pre><code>[mypy-frobnicate.*]\nignore_missing_imports = True\n\n[mypy-acme.*]\nignore_missing_imports = True\n</code></pre> <p>\u5982\u679c\u4f60\u9047\u5230\u5927\u91cf\u9519\u8bef\uff0c\u53ef\u80fd\u4f1a\u60f3\u8981\u5ffd\u7565\u6240\u6709\u5173\u4e8e\u7f3a\u5c11\u5bfc\u5165\u7684\u9519\u8bef\uff0c\u4f8b\u5982\u901a\u8fc7\u8bbe\u7f6e --disable-error-code=import-untyped \u6216\u5168\u5c40\u8bbe\u7f6e ignore_missing_imports \u4e3a true\u3002 \u8fd9\u53ef\u80fd\u4f1a\u9690\u85cf\u540e\u7eed\u7684\u9519\u8bef\uff0c\u56e0\u6b64\u5982\u679c\u53ef\u80fd\uff0c\u6211\u4eec\u5efa\u8bae\u907f\u514d\u8fd9\u6837\u505a\u3002</p> <p>\u6700\u540e\uff0cmypy \u5141\u8bb8\u5bf9\u7279\u5b9a\u5bfc\u5165\u884c\u4e3a\u8fdb\u884c\u7cbe\u7ec6\u63a7\u5236\u3002\u5f53\u4f60\u5c1d\u8bd5\u8c03\u6574\u8fd9\u4e9b\u8bbe\u7f6e\u65f6\uff0c\u5f88\u5bb9\u6613\u5728\u4e0d\u77e5\u4e0d\u89c9\u4e2d\u51fa\u9519\uff0c\u56e0\u6b64\u8fd9\u5e94\u8be5\u662f\u6700\u540e\u7684\u9009\u62e9\u3002\u66f4\u591a\u8be6\u60c5\uff0c\u8bf7\u53c2\u8003\u6b64\u5904\u3002</p> <p>A common class of error you will encounter is errors from mypy about modules that it can\u2019t find, that don\u2019t have types, or don\u2019t have stub files:</p> <pre><code>core/config.py:7: error: Cannot find implementation or library stub for module named 'frobnicate'\ncore/model.py:9: error: Cannot find implementation or library stub for module named 'acme'\n...\n</code></pre> <p>Sometimes these can be fixed by installing the relevant packages or stub libraries in the environment you\u2019re running <code>mypy</code> in.</p> <p>See Missing imports for a complete reference on these errors and the ways in which you can fix them.</p> <p>You\u2019ll likely find that you want to suppress all errors from importing a given module that doesn\u2019t have types. If you only import that module in one or two places, you can use <code># type: ignore</code> comments. For example, here we ignore an error about a third-party module <code>frobnicate</code> that doesn\u2019t have stubs using <code># type: ignore</code>:</p> <pre><code>import frobnicate  # type: ignore\n...\nfrobnicate.initialize()  # OK (but not checked)\n</code></pre> <p>But if you import the module in many places, this becomes unwieldy. In this case, we recommend using a configuration file. For example, to disable errors about importing frobnicate and acme everywhere in your codebase, use a config like this:</p> <pre><code>[mypy-frobnicate.*]\nignore_missing_imports = True\n\n[mypy-acme.*]\nignore_missing_imports = True\n</code></pre> <p>If you get a large number of errors, you may want to ignore all errors about missing imports, for instance by setting --disable-error-code=import-untyped. or setting ignore_missing_imports to true globally. This can hide errors later on, so we recommend avoiding this if possible.</p> <p>Finally, mypy allows fine-grained control over specific import following behaviour. It\u2019s very easy to silently shoot yourself in the foot when playing around with these, so this should be a last resort. For more details, look here.</p>"},{"location":"mypy/existing_code/#\u4f18\u5148\u6ce8\u91ca\u5e7f\u6cdb\u5bfc\u5165\u7684\u6a21\u5757","title":"\u4f18\u5148\u6ce8\u91ca\u5e7f\u6cdb\u5bfc\u5165\u7684\u6a21\u5757","text":"<p>Prioritise annotating widely imported modules</p> \u4e2d\u6587\u82f1\u6587 <p>\u5927\u591a\u6570\u9879\u76ee\u90fd\u6709\u4e00\u4e9b\u5e7f\u6cdb\u5bfc\u5165\u7684\u6a21\u5757\uff0c\u6bd4\u5982\u5de5\u5177\u7c7b\u6216\u6a21\u578b\u7c7b\u3002\u5c3d\u65e9\u5bf9\u8fd9\u4e9b\u6a21\u5757\u8fdb\u884c\u6ce8\u91ca\u662f\u4e2a\u4e0d\u9519\u7684\u4e3b\u610f\uff0c\u56e0\u4e3a\u8fd9\u80fd\u8ba9\u4f7f\u7528\u8fd9\u4e9b\u6a21\u5757\u7684\u4ee3\u7801\u66f4\u6709\u6548\u5730\u8fdb\u884c\u7c7b\u578b\u68c0\u67e5\u3002</p> <p>Mypy \u65e8\u5728\u652f\u6301\u6e10\u8fdb\u5f0f\u7c7b\u578b\u68c0\u67e5\uff0c\u4e5f\u5c31\u662f\u8bf4\uff0c\u4f60\u53ef\u4ee5\u6309\u7167\u81ea\u5df1\u7684\u8282\u594f\u9010\u6b65\u6dfb\u52a0\u6ce8\u91ca\uff0c\u56e0\u6b64\u53ef\u4ee5\u653e\u5fc3\u5730\u5c06\u67d0\u4e9b\u6a21\u5757\u6682\u65f6\u4e0d\u505a\u6ce8\u91ca\u3002\u6ce8\u91ca\u5f97\u8d8a\u591a\uff0cmypy \u7684\u4f5c\u7528\u5c31\u8d8a\u5927\uff0c\u4f46\u5373\u4f7f\u53ea\u6709\u5c11\u91cf\u6ce8\u91ca\u8986\u76d6\u4e5f\u4f1a\u6709\u5e2e\u52a9\u3002</p> <p>Most projects have some widely imported modules, such as utilities or model classes. It\u2019s a good idea to annotate these pretty early on, since this allows code using these modules to be type checked more effectively.</p> <p>Mypy is designed to support gradual typing, i.e. letting you add annotations at your own pace, so it\u2019s okay to leave some of these modules unannotated. The more you annotate, the more useful mypy will be, but even a little annotation coverage is useful.</p>"},{"location":"mypy/existing_code/#\u968f\u65f6\u5199\u6ce8\u89e3","title":"\u968f\u65f6\u5199\u6ce8\u89e3","text":"<p>Write annotations as you go</p> \u4e2d\u6587\u82f1\u6587 <p>\u53ef\u4ee5\u8003\u8651\u5c06\u4ee5\u4e0b\u5185\u5bb9\u52a0\u5165\u5230\u4f60\u7684\u4ee3\u7801\u98ce\u683c\u89c4\u8303\u4e2d\uff1a</p> <ol> <li> <p>\u5f00\u53d1\u4eba\u5458\u5e94\u4e3a\u4efb\u4f55\u65b0\u4ee3\u7801\u6dfb\u52a0\u7c7b\u578b\u6ce8\u91ca\u3002</p> </li> <li> <p>\u4fee\u6539\u73b0\u6709\u4ee3\u7801\u65f6\uff0c\u4e5f\u9f13\u52b1\u6dfb\u52a0\u7c7b\u578b\u6ce8\u91ca\u3002</p> </li> </ol> <p>\u901a\u8fc7\u8fd9\u79cd\u65b9\u5f0f\uff0c\u4f60\u53ef\u4ee5\u5728\u4e0d\u8d39\u592a\u591a\u529b\u6c14\u7684\u60c5\u51b5\u4e0b\u9010\u6b65\u589e\u52a0\u4ee3\u7801\u5e93\u4e2d\u7684\u7c7b\u578b\u6ce8\u91ca\u8986\u76d6\u7387\u3002</p> <p>Consider adding something like these in your code style conventions:</p> <ol> <li> <p>Developers should add annotations for any new code.</p> </li> <li> <p>It\u2019s also encouraged to write annotations when you modify existing code.</p> </li> </ol> <p>This way you\u2019ll gradually increase annotation coverage in your codebase without much effort.</p>"},{"location":"mypy/existing_code/#\u81ea\u52a8\u6ce8\u89e3\u9057\u7559\u4ee3\u7801","title":"\u81ea\u52a8\u6ce8\u89e3\u9057\u7559\u4ee3\u7801","text":"<p>Automate annotation of legacy code</p> \u4e2d\u6587\u82f1\u6587 <p>\u6709\u4e00\u4e9b\u5de5\u5177\u53ef\u4ee5\u57fa\u4e8e\u7b80\u5355\u7684\u9759\u6001\u5206\u6790\u6216\u5728\u8fd0\u884c\u65f6\u6536\u96c6\u7684\u7c7b\u578b\u4fe1\u606f\u81ea\u52a8\u6dfb\u52a0\u521d\u6b65\u7684\u7c7b\u578b\u6ce8\u91ca\u3002\u8fd9\u4e9b\u5de5\u5177\u5305\u62ec MonkeyType\u3001autotyping \u548c PyAnnotate\u3002</p> <p>\u4e00\u79cd\u7b80\u5355\u7684\u65b9\u6cd5\u662f\u901a\u8fc7\u6d4b\u8bd5\u8fd0\u884c\u6765\u6536\u96c6\u7c7b\u578b\u4fe1\u606f\u3002\u5982\u679c\u4f60\u7684\u6d4b\u8bd5\u8986\u76d6\u7387\u8f83\u597d\uff08\u4e14\u6d4b\u8bd5\u901f\u5ea6\u4e0d\u592a\u6162\uff09\uff0c\u8fd9\u79cd\u65b9\u6cd5\u53ef\u80fd\u6548\u679c\u4e0d\u9519\u3002</p> <p>\u53e6\u4e00\u79cd\u65b9\u6cd5\u662f\u4e3a\u4e00\u5c0f\u90e8\u5206\u968f\u673a\u9009\u62e9\u7684\u751f\u4ea7\u7f51\u7edc\u8bf7\u6c42\u542f\u7528\u7c7b\u578b\u4fe1\u606f\u6536\u96c6\u3002\u8fd9\u663e\u7136\u9700\u8981\u66f4\u52a0\u8c28\u614e\uff0c\u56e0\u4e3a\u7c7b\u578b\u6536\u96c6\u53ef\u80fd\u4f1a\u5f71\u54cd\u670d\u52a1\u7684\u53ef\u9760\u6027\u6216\u6027\u80fd\u3002</p> <p>There are tools for automatically adding draft annotations based on simple static analysis or on type profiles collected at runtime. Tools include MonkeyType, autotyping and PyAnnotate.</p> <p>A simple approach is to collect types from test runs. This may work well if your test coverage is good (and if your tests aren\u2019t very slow).</p> <p>Another approach is to enable type collection for a small, random fraction of production network requests. This clearly requires more care, as type collection could impact the reliability or the performance of your service.</p>"},{"location":"mypy/existing_code/#\u5f15\u5165\u66f4\u4e25\u683c\u7684\u9009\u9879","title":"\u5f15\u5165\u66f4\u4e25\u683c\u7684\u9009\u9879","text":"<p>Introduce stricter options</p> \u4e2d\u6587\u82f1\u6587 <p>Mypy \u662f\u9ad8\u5ea6\u53ef\u914d\u7f6e\u7684\u3002\u4e00\u65e6\u4f60\u5f00\u59cb\u4f7f\u7528\u9759\u6001\u7c7b\u578b\u68c0\u67e5\uff0c\u53ef\u80fd\u4f1a\u5e0c\u671b\u63a2\u7d22 mypy \u63d0\u4f9b\u7684\u5404\u79cd\u4e25\u683c\u6027\u9009\u9879\uff0c\u4ee5\u6355\u6349\u66f4\u591a\u7684\u9519\u8bef\u3002\u4f8b\u5982\uff0c\u4f60\u53ef\u4ee5\u8981\u6c42 mypy \u5bf9\u67d0\u4e9b\u6a21\u5757\u7684\u6240\u6709\u51fd\u6570\u8fdb\u884c\u7c7b\u578b\u6ce8\u91ca\uff0c\u4ee5\u907f\u514d\u65e0\u610f\u4e2d\u5f15\u5165\u4e0d\u4f1a\u88ab\u7c7b\u578b\u68c0\u67e5\u7684\u4ee3\u7801\uff0c\u53ef\u4ee5\u4f7f\u7528 disallow_untyped_defs \u5b9e\u73b0\u8fd9\u4e00\u70b9\u3002\u6709\u5173\u8be6\u7ec6\u4fe1\u606f\uff0c\u8bf7\u53c2\u9605 Mypy \u914d\u7f6e\u6587\u4ef6\u3002</p> <p>\u4e00\u4e2a\u4f18\u79c0\u7684\u76ee\u6807\u662f\u8ba9\u4f60\u7684\u4ee3\u7801\u5e93\u5728\u8fd0\u884c <code>mypy --strict</code> \u65f6\u80fd\u901a\u8fc7\u68c0\u67e5\u3002\u8fd9\u6837\u57fa\u672c\u4e0a\u53ef\u4ee5\u786e\u4fdd\u4f60\u4e0d\u4f1a\u6709\u4efb\u4f55\u4e0e\u7c7b\u578b\u76f8\u5173\u7684\u9519\u8bef\uff0c\u9664\u975e\u6709\u660e\u786e\u7684\u89c4\u907f\uff08\u4f8b\u5982 <code># type: ignore</code> \u6ce8\u91ca\uff09\u3002</p> <p>\u4ee5\u4e0b\u914d\u7f6e\u7b49\u6548\u4e8e <code>--strict</code>\uff08\u57fa\u4e8e mypy 1.0 \u7248\u672c\uff09\uff1a</p> <pre><code># \u5148\u4ece\u8fd9\u4e9b\u5f00\u59cb\nwarn_unused_configs = True\nwarn_redundant_casts = True\nwarn_unused_ignores = True\n\n# \u8fd9\u4e9b\u9009\u9879\u901a\u5e38\u5bb9\u6613\u901a\u8fc7\nstrict_equality = True\nstrict_concatenate = True\n\n# \u5f3a\u70c8\u5efa\u8bae\u5c3d\u65e9\u542f\u7528\u6b64\u9009\u9879\ncheck_untyped_defs = True\n\n# \u8fd9\u4e9b\u9009\u9879\u4e0d\u7b97\u592a\u590d\u6742\uff0c\u4f46\u5982\u679c\u4f7f\u7528\u4e86\u5927\u91cf\u65e0\u7c7b\u578b\u6ce8\u91ca\u7684\u5e93\uff0c\u53ef\u80fd\u4f1a\u6bd4\u8f83\u68d8\u624b\ndisallow_subclassing_any = True\ndisallow_untyped_decorators = True\ndisallow_any_generics = True\n\n# \u4ee5\u4e0b\u51e0\u9879\u662f\u5404\u79cd\u5f3a\u5236\u4f7f\u7528\u7c7b\u578b\u6ce8\u91ca\u7684\u65b9\u5f0f\ndisallow_untyped_calls = True\ndisallow_incomplete_defs = True\ndisallow_untyped_defs = True\n\n# \u8fd9\u4e00\u9879\u4e0d\u96be\u901a\u8fc7\uff0c\u4f46\u6295\u8d44\u56de\u62a5\u7387\u8f83\u4f4e\nno_implicit_reexport = True\n\n# \u5982\u679c\u4f7f\u7528\u4e86\u5927\u91cf\u65e0\u7c7b\u578b\u6ce8\u91ca\u7684\u5e93\uff0c\u8fd9\u4e00\u9879\u53ef\u80fd\u6bd4\u8f83\u68d8\u624b\nwarn_return_any = True\n</code></pre> <p>\u6ce8\u610f\uff0c\u4f60\u4e5f\u53ef\u4ee5\u4ece <code>--strict</code> \u5f00\u59cb\uff0c\u5e76\u6839\u636e\u9700\u8981\u51cf\u53bb\u67d0\u4e9b\u9009\u9879\uff0c\u4f8b\u5982\uff1a</p> <pre><code>strict = True\nwarn_return_any = False\n</code></pre> <p>\u8bb0\u4f4f\uff0c\u8bb8\u591a\u8fd9\u4e9b\u9009\u9879\u53ef\u4ee5\u6309\u6a21\u5757\u542f\u7528\u3002\u4f8b\u5982\uff0c\u4f60\u53ef\u80fd\u5e0c\u671b\u5bf9\u5df2\u7ecf\u5b8c\u6210\u7c7b\u578b\u6ce8\u91ca\u7684\u6a21\u5757\u542f\u7528 <code>disallow_untyped_defs</code>\uff0c\u4ee5\u9632\u6b62\u65b0\u4ee3\u7801\u5728\u6ca1\u6709\u6ce8\u91ca\u7684\u60c5\u51b5\u4e0b\u88ab\u6dfb\u52a0\u3002</p> <p>\u6b64\u5916\uff0c\u5982\u679c\u4f60\u613f\u610f\uff0c\u4e25\u683c\u6027\u9009\u9879\u4e0d\u6b62\u4e8e <code>--strict</code>\u3002Mypy \u8fd8\u6709\u4e00\u4e9b\u4e0d\u5728 <code>--strict</code> \u8303\u56f4\u5185\u4f46\u4f9d\u7136\u6709\u7528\u7684\u68c0\u67e5\u3002\u8bf7\u53c2\u9605\u5b8c\u6574\u7684 Mypy \u547d\u4ee4\u884c\u53c2\u8003\u548c \u53ef\u9009\u68c0\u67e5\u7684\u9519\u8bef\u4ee3\u7801\u3002</p> <p>Mypy is very configurable. Once you get started with static typing, you may want to explore the various strictness options mypy provides to catch more bugs. For example, you can ask mypy to require annotations for all functions in certain modules to avoid accidentally introducing code that won\u2019t be type checked using disallow_untyped_defs. Refer to The mypy configuration file for the details.</p> <p>An excellent goal to aim for is to have your codebase pass when run against <code>mypy --strict</code>. This basically ensures that you will never have a type related error without an explicit circumvention somewhere (such as a <code># type: ignore</code> comment).</p> <p>The following config is equivalent to <code>--strict</code> (as of mypy 1.0):</p> <pre><code># Start off with these\nwarn_unused_configs = True\nwarn_redundant_casts = True\nwarn_unused_ignores = True\n\n# Getting these passing should be easy\nstrict_equality = True\nstrict_concatenate = True\n\n# Strongly recommend enabling this one as soon as you can\ncheck_untyped_defs = True\n\n# These shouldn't be too much additional work, but may be tricky to\n# get passing if you use a lot of untyped libraries\ndisallow_subclassing_any = True\ndisallow_untyped_decorators = True\ndisallow_any_generics = True\n\n# These next few are various gradations of forcing use of type annotations\ndisallow_untyped_calls = True\ndisallow_incomplete_defs = True\ndisallow_untyped_defs = True\n\n# This one isn't too hard to get passing, but return on investment is lower\nno_implicit_reexport = True\n\n# This one can be tricky to get passing if you use a lot of untyped libraries\nwarn_return_any = True\n</code></pre> <p>Note that you can also start with --strict and subtract, for instance:</p> <pre><code>strict = True\nwarn_return_any = False\n</code></pre> <p>Remember that many of these options can be enabled on a per-module basis. For instance, you may want to enable <code>disallow_untyped_defs</code> for modules which you\u2019ve completed annotations for, in order to prevent new code from being added without annotations.</p> <p>And if you want, it doesn\u2019t stop at <code>--strict</code>. Mypy has additional checks that are not part of <code>--strict</code> that can be useful. See the complete The mypy command line reference and Error codes for optional checks.</p>"},{"location":"mypy/existing_code/#\u52a0\u901f-mypy-\u8fd0\u884c","title":"\u52a0\u901f mypy \u8fd0\u884c","text":"<p>Speed up mypy runs</p> \u4e2d\u6587\u82f1\u6587 <p>\u4f60\u53ef\u4ee5\u4f7f\u7528 mypy daemon \u6765\u5b9e\u73b0\u66f4\u5feb\u7684\u589e\u91cf\u5f0f mypy \u8fd0\u884c\u3002\u9879\u76ee\u8d8a\u5927\uff0c\u8fd9\u4e2a\u5de5\u5177\u5c31\u8d8a\u6709\u7528\u3002\u5982\u679c\u4f60\u7684\u9879\u76ee\u81f3\u5c11\u6709 100,000 \u884c\u4ee3\u7801\uff0c\u4f60\u53ef\u80fd\u8fd8\u60f3\u8bbe\u7f6e \u8fdc\u7a0b\u7f13\u5b58 \u4ee5\u8fdb\u4e00\u6b65\u52a0\u5feb\u901f\u5ea6\u3002</p> <p>You can use mypy daemon to get much faster incremental mypy runs. The larger your project is, the more useful this will be. If your project has at least 100,000 lines of code or so, you may also want to set up remote caching for further speedups.</p>"},{"location":"mypy/final_names_methods_classes/","title":"\u6700\u7ec8\u7684\u547d\u540d\u3001\u65b9\u6cd5\u3001\u7c7b","text":"\u4e2d\u6587\u82f1\u6587 <p>\u672c\u8282\u4ecb\u7ecd\u8fd9\u4e9b\u76f8\u5173\u529f\u80fd\uff1a</p> <ol> <li>\u6700\u7ec8\u540d\u79f0 \u662f\u521d\u59cb\u5316\u540e\u4e0d\u5e94\u91cd\u65b0\u5206\u914d\u7684\u53d8\u91cf\u6216\u5c5e\u6027\u3002 \u5b83\u4eec\u5bf9\u4e8e\u58f0\u660e\u5e38\u91cf\u5f88\u6709\u7528\u3002</li> <li>\u6700\u7ec8\u65b9\u6cd5 \u4e0d\u5e94\u5728\u5b50\u7c7b\u4e2d\u91cd\u5199\u3002</li> <li>\u6700\u7ec8\u7c7b \u4e0d\u5e94\u8be5\u88ab\u5b50\u7c7b\u5316\u3002</li> </ol> <p>\u6240\u6709\u8fd9\u4e9b\u4ec5\u7531 mypy \u5f3a\u5236\u6267\u884c\uff0c\u5e76\u4e14\u4ec5\u5728\u5e26\u6ce8\u91ca\u7684\u4ee3\u7801\u4e2d\u6267\u884c\u3002 Python \u8fd0\u884c\u65f6\u4e0d\u6267\u884c\u4efb\u4f55\u8fd0\u884c\u65f6\u5f3a\u5236\u63aa\u65bd\u3002</p> <p>Note</p> <p>\u672c\u9875\u4e2d\u7684\u793a\u4f8b\u4ece <code>typing</code> \u6a21\u5757\u5bfc\u5165 <code>Final</code> \u548c <code>final</code> \u3002 \u8fd9\u4e9b\u7c7b\u578b\u5df2\u6dfb\u52a0\u5230 Python 3.8 \u4e2d\u7684 <code>typing</code> \u4e2d\uff0c\u4f46\u4e5f\u53ef\u4ee5\u901a\u8fc7 <code>typing_extensions</code> \u5305\u5728 Python 3.4 - 3.7 \u4e2d\u4f7f\u7528\u3002</p> <p>Final names, methods and classes</p> <p>This section introduces these related features:</p> <ol> <li>Final names are variables or attributes that should not be reassigned after initialization. They are useful for declaring constants.</li> <li>Final methods should not be overridden in a subclass.</li> <li>Final classes should not be subclassed.</li> </ol> <p>All of these are only enforced by mypy, and only in annotated code. There is no runtime enforcement by the Python runtime.</p> <p>Note</p> <p>The examples in this page import <code>Final</code> and <code>final</code> from the <code>typing</code> module. These types were added to <code>typing</code> in Python 3.8, but are also available for use in Python 3.4 - 3.7 via the <code>typing_extensions</code> package.</p>"},{"location":"mypy/final_names_methods_classes/#\u6700\u7ec8\u540d\u79f0","title":"\u6700\u7ec8\u540d\u79f0","text":"<p>Final names</p> \u4e2d\u6587\u82f1\u6587 <p>\u60a8\u53ef\u4ee5\u4f7f\u7528<code>typing.Final</code>\u9650\u5b9a\u7b26\u6765\u6307\u793a\u4e0d\u5e94\u91cd\u65b0\u5206\u914d\u3001\u91cd\u65b0\u5b9a\u4e49\u6216\u8986\u76d6\u540d\u79f0\u6216\u5c5e\u6027\u3002 \u8fd9\u5bf9\u4e8e\u6a21\u5757\u548c\u7c7b\u7ea7\u522b\u5e38\u91cf\u901a\u5e38\u5f88\u6709\u7528\uff0c\u53ef\u4ee5\u4f5c\u4e3a\u9632\u6b62\u610f\u5916\u4fee\u6539\u7684\u65b9\u6cd5\u3002 Mypy \u5c06\u963b\u6b62\u5728\u7c7b\u578b\u68c0\u67e5\u4ee3\u7801\u4e2d\u8fdb\u4e00\u6b65\u5206\u914d\u6700\u7ec8\u540d\u79f0\uff1a</p> <pre><code>from typing import Final\n\nRATE: Final = 3_000\n\nclass Base:\n    DEFAULT_ID: Final = 0\n\nRATE = 300  # Error: can't assign to final attribute\nBase.DEFAULT_ID = 1  # Error: can't override a final attribute\n</code></pre> <p>\u6700\u7ec8\u5c5e\u6027\u7684\u53e6\u4e00\u4e2a\u7528\u4f8b\u662f\u4fdd\u62a4\u67d0\u4e9b\u5c5e\u6027\u4e0d\u88ab\u5b50\u7c7b\u4e2d\u8986\u76d6\uff1a</p> <pre><code>from typing import Final\n\nclass Window:\n    BORDER_WIDTH: Final = 2.5\n    ...\n\nclass ListView(Window):\n    BORDER_WIDTH = 3  # Error: can't override a final attribute\n</code></pre> <p>\u60a8\u53ef\u4ee5\u4f7f\u7528 <code>@property</code> \u5c06\u5c5e\u6027\u8bbe\u7f6e\u4e3a\u53ea\u8bfb\uff0c\u4f46\u4e0e <code>Final</code> \u4e0d\u540c\uff0c\u5b83\u4e0d\u9002\u7528\u4e8e\u6a21\u5757\u5c5e\u6027\uff0c\u5e76\u4e14\u5b83\u4e0d\u4f1a\u963b\u6b62\u5b50\u7c7b\u4e2d\u7684\u91cd\u5199\u3002</p> <p>You can use the <code>typing.Final</code> qualifier to indicate that a name or attribute should not be reassigned, redefined, or overridden.  This is often useful for module and class level constants as a way to prevent unintended modification.  Mypy will prevent further assignments to final names in type-checked code:</p> <pre><code>from typing import Final\n\nRATE: Final = 3_000\n\nclass Base:\n    DEFAULT_ID: Final = 0\n\nRATE = 300  # Error: can't assign to final attribute\nBase.DEFAULT_ID = 1  # Error: can't override a final attribute\n</code></pre> <p>Another use case for final attributes is to protect certain attributes from being overridden in a subclass:</p> <pre><code>from typing import Final\n\nclass Window:\n    BORDER_WIDTH: Final = 2.5\n    ...\n\nclass ListView(Window):\n    BORDER_WIDTH = 3  # Error: can't override a final attribute\n</code></pre> <p>You can use <code>@property</code> to make an attribute read-only, but unlike <code>Final</code>, it doesn't work with module attributes, and it doesn't prevent overriding in subclasses.</p>"},{"location":"mypy/final_names_methods_classes/#\u8bed\u6cd5\u53d8\u4f53","title":"\u8bed\u6cd5\u53d8\u4f53","text":"<p>Syntax variants</p> \u4e2d\u6587\u82f1\u6587 <p>\u60a8\u53ef\u4ee5\u4ee5\u4e0b\u5217\u5f62\u5f0f\u4e4b\u4e00\u4f7f\u7528<code>Final</code>\uff1a</p> <ul> <li>\u60a8\u53ef\u4ee5\u4f7f\u7528\u8bed\u6cd5<code>Final[&lt;type&gt;]</code>\u63d0\u4f9b\u663e\u5f0f\u7c7b\u578b\u3002 \u4f8b\u5b50\uff1a</li> </ul> <pre><code>ID: Final[int] = 1\n</code></pre> <p>\u8fd9\u91cc mypy \u4f1a\u63a8\u65ad\u51fa\u201cID\u201d\u7684\u7c7b\u578b\u4e3a\u201cint\u201d\u3002</p> <ul> <li>\u60a8\u53ef\u4ee5\u7701\u7565\u7c7b\u578b\uff1a</li> </ul> <pre><code>ID: Final = 1\n</code></pre> <p>\u8fd9\u91cc mypy \u4f1a\u63a8\u65ad\u51fa <code>ID</code> \u7684\u7c7b\u578b\u4e3a <code>Literal[1]</code>\u3002 \u8bf7\u6ce8\u610f\uff0c\u4e0e\u6cdb\u578b\u7c7b\u4e0d\u540c\uff0c\u8fd9\u4e0e\u201cFinal[Any]\u201d\u4e0d\u540c\u3002</p> <ul> <li> <p>\u5728\u7c7b\u4f53\u548c\u5b58\u6839\u6587\u4ef6\u4e2d\uff0c\u60a8\u53ef\u4ee5\u7701\u7565\u53f3\u4fa7\uff0c\u53ea\u5199<code>ID: Final[int]</code>\u3002</p> </li> <li> <p>\u6700\u540e\uff0c\u60a8\u53ef\u4ee5\u7f16\u5199<code>self.id: Final = 1</code>\uff08\u4e5f\u53ef\u4ee5\u9009\u62e9\u4f7f\u7528\u65b9\u62ec\u53f7\u4e2d\u7684\u7c7b\u578b\uff09\u3002 \u4ec5\u5728 <code>__init__</code> \u65b9\u6cd5\u4e2d\u5141\u8bb8\u8fd9\u6837\u505a\uff0c\u4ee5\u4fbf\u6700\u7ec8\u5b9e\u4f8b\u5c5e\u6027\u4ec5\u5728\u5b9e\u4f8b\u65f6\u5206\u914d\u4e00\u6b21 \u88ab\u5efa\u9020\u3002</p> </li> </ul> <p>You can use <code>Final</code> in one of these forms:</p> <ul> <li>You can provide an explicit type using the syntax <code>Final[&lt;type&gt;]</code>. Example:</li> </ul> <pre><code>ID: Final[int] = 1\n</code></pre> <p>Here mypy will infer type <code>int</code> for <code>ID</code>.</p> <ul> <li>You can omit the type:</li> </ul> <pre><code>ID: Final = 1\n</code></pre> <p>Here mypy will infer type <code>Literal[1]</code> for <code>ID</code>. Note that unlike for generic classes this is not the same as <code>Final[Any]</code>.</p> <ul> <li> <p>In class bodies and stub files you can omit the right hand side and just write   <code>ID: Final[int]</code>.</p> </li> <li> <p>Finally, you can write <code>self.id: Final = 1</code> (also optionally with a type in square brackets). This is allowed only in <code>__init__</code> methods, so that the final instance attribute is assigned only once when an instance is created.</p> </li> </ul>"},{"location":"mypy/final_names_methods_classes/#\u4f7f\u7528final\u7684\u8be6\u60c5","title":"\u4f7f\u7528<code>Final</code>\u7684\u8be6\u60c5","text":"<p>Details of using <code>Final</code></p> \u4e2d\u6587\u82f1\u6587 <p>\u8fd9\u662f\u5b9a\u4e49\u6700\u7ec8\u540d\u79f0\u7684\u4e24\u4e2a\u4e3b\u8981\u89c4\u5219\uff1a</p> <ul> <li>\u5bf9\u4e8e\u7ed9\u5b9a\u7684\u5c5e\u6027\uff0c\u6bcf\u4e2a\u6a21\u5757\u6216\u7c7b\u6700\u591a\u53ef\u4ee5\u6709\u4e00\u4e2a\u6700\u7ec8\u58f0\u660e\u3002 \u4e0d\u80fd\u5b58\u5728\u5177\u6709\u76f8\u540c\u540d\u79f0\u7684\u5355\u72ec\u7684\u7c7b\u7ea7\u548c\u5b9e\u4f8b\u7ea7\u5e38\u91cf\u3002</li> <li>\u5fc5\u987b\u6709\u201c\u6070\u597d\u4e00\u4e2a\u201d\u5206\u914d\u7ed9\u6700\u7ec8\u540d\u79f0\u3002</li> </ul> <p>\u5728\u6ca1\u6709\u521d\u59cb\u5316\u7a0b\u5e8f\u7684\u7c7b\u4e3b\u4f53\u4e2d\u58f0\u660e\u7684\u6700\u7ec8\u5c5e\u6027\u5fc5\u987b\u5728 <code>__init__</code> \u65b9\u6cd5\u4e2d\u521d\u59cb\u5316\uff08\u60a8\u53ef\u4ee5\u8df3\u8fc7\u5b58\u6839\u6587\u4ef6\u4e2d\u7684\u521d\u59cb\u5316\u7a0b\u5e8f\uff09\uff1a</p> <pre><code>class ImmutablePoint:\n    x: Final[int]\n    y: Final[int]  # Error: final attribute without an initializer\n\n    def __init__(self) -&gt; None:\n        self.x = 1  # Good\n</code></pre> <p><code>Final</code> \u53ea\u80fd\u7528\u4f5c\u8d4b\u503c\u6216\u53d8\u91cf\u6ce8\u91ca\u4e2d\u7684\u6700\u5916\u5c42\u7c7b\u578b\u3002 \u5728\u4efb\u4f55\u5176\u4ed6\u4f4d\u7f6e\u4f7f\u7528\u5b83\u90fd\u662f\u9519\u8bef\u7684\u3002 \u7279\u522b\u662f\uff0c<code>Final</code>\u4e0d\u80fd\u5728\u51fd\u6570\u53c2\u6570\u7684\u6ce8\u91ca\u4e2d\u4f7f\u7528\uff1a</p> <pre><code>x: list[Final[int]] = []  # Error!\n\ndef fun(x: Final[list[int]]) -&gt;  None:  # Error!\n    ...\n</code></pre> <p><code>Final</code> \u548c <code>typing.ClassVar</code> \u4e0d\u5e94\u4e00\u8d77\u4f7f\u7528\u3002 Mypy \u5c06\u81ea\u52a8\u63a8\u65ad\u6700\u7ec8\u58f0\u660e\u7684\u8303\u56f4\uff0c\u5177\u4f53\u53d6\u51b3\u4e8e\u5b83\u662f\u5728\u7c7b\u4e3b\u4f53\u4e2d\u8fd8\u662f\u5728 <code>__init__</code> \u4e2d\u521d\u59cb\u5316 \u3002</p> <p>\u6700\u7ec8\u5c5e\u6027\u4e0d\u80fd\u88ab\u5b50\u7c7b\u8986\u76d6\uff08\u5373\u4f7f\u6709\u53e6\u4e00\u4e2a\u663e\u5f0f\u6700\u7ec8\u58f0\u660e\uff09\u3002 \u4f46\u8bf7\u6ce8\u610f\uff0c\u6700\u7ec8\u5c5e\u6027\u53ef\u4ee5\u8986\u76d6\u53ea\u8bfb\u5c5e\u6027\uff1a</p> <pre><code>class Base:\n    @property\n    def ID(self) -&gt; int: ...\n\nclass Derived(Base):\n    ID: Final = 1  # OK\n</code></pre> <p>\u5c06\u540d\u79f0\u58f0\u660e\u4e3a\u6700\u7ec8\u540d\u79f0\u53ea\u80fd\u4fdd\u8bc1\u8be5\u540d\u79f0\u4e0d\u4f1a\u91cd\u65b0\u7ed1\u5b9a\u5230\u53e6\u4e00\u4e2a\u503c\u3002 \u5b83\u5e76\u4e0d\u4f7f\u503c\u53d8\u5f97\u4e0d\u53ef\u53d8\u3002 \u60a8\u53ef\u4ee5\u4f7f\u7528\u4e0d\u53ef\u53d8\u7684 ABC \u548c\u5bb9\u5668\u6765\u9632\u6b62\u66f4\u6539\u6b64\u7c7b\u503c\uff1a</p> <pre><code>x: Final = ['a', 'b']\nx.append('c')  # OK\n\ny: Final[Sequence[str]] = ['a', 'b']\ny.append('x')  # Error: Sequence is immutable\nz: Final = ('a', 'b')  # Also an option\n</code></pre> <p>These are the two main rules for defining a final name:</p> <ul> <li>There can be at most one final declaration per module or class for a given attribute. There can't be separate class-level and instance-level constants with the same name.</li> <li>There must be exactly one assignment to a final name.</li> </ul> <p>A final attribute declared in a class body without an initializer must be initialized in the <code>__init__</code> method (you can skip the initializer in stub files):</p> <pre><code>class ImmutablePoint:\n    x: Final[int]\n    y: Final[int]  # Error: final attribute without an initializer\n\n    def __init__(self) -&gt; None:\n        self.x = 1  # Good\n</code></pre> <p><code>Final</code> can only be used as the outermost type in assignments or variable annotations. Using it in any other position is an error. In particular, <code>Final</code> can't be used in annotations for function arguments:</p> <pre><code>x: list[Final[int]] = []  # Error!\n\ndef fun(x: Final[list[int]]) -&gt;  None:  # Error!\n    ...\n</code></pre> <p><code>Final</code> and {py:data}<code>~typing.ClassVar</code> should not be used together. Mypy will infer the scope of a final declaration automatically depending on whether it was initialized in the class body or in {py:meth}<code>__init__ &lt;object.__init__&gt;</code>.</p> <p>A final attribute can't be overridden by a subclass (even with another explicit final declaration). Note however that a final attribute can override a read-only property:</p> <pre><code>class Base:\n    @property\n    def ID(self) -&gt; int: ...\n\nclass Derived(Base):\n    ID: Final = 1  # OK\n</code></pre> <p>Declaring a name as final only guarantees that the name will not be re-bound to another value. It doesn't make the value immutable. You can use immutable ABCs and containers to prevent mutating such values:</p> <pre><code>x: Final = ['a', 'b']\nx.append('c')  # OK\n\ny: Final[Sequence[str]] = ['a', 'b']\ny.append('x')  # Error: Sequence is immutable\nz: Final = ('a', 'b')  # Also an option\n</code></pre>"},{"location":"mypy/final_names_methods_classes/#\u6700\u7ec8\u65b9\u6cd5","title":"\u6700\u7ec8\u65b9\u6cd5","text":"<p>Final methods</p> \u4e2d\u6587\u82f1\u6587 <p>\u4e0e\u5c5e\u6027\u4e00\u6837\uff0c\u6709\u65f6\u4fdd\u62a4\u65b9\u6cd5\u514d\u906d\u91cd\u5199\u5f88\u6709\u7528\u3002 \u60a8\u53ef\u4ee5\u4f7f\u7528 <code>typing.final</code> \u88c5\u9970\u5668\u6765\u5b9e\u73b0\u6b64\u76ee\u7684\uff1a</p> <pre><code>from typing import final\n\nclass Base:\n    @final\n    def common_name(self) -&gt; None:\n        ...\n\nclass Derived(Base):\n    def common_name(self) -&gt; None:  # Error: cannot override a final method\n        ...\n</code></pre> <p>\u8fd9\u4e2a<code>@final</code>\u88c5\u9970\u5668\u53ef\u4ee5\u4e0e\u5b9e\u4f8b\u65b9\u6cd5\u3001\u7c7b\u65b9\u6cd5\u3001\u9759\u6001\u65b9\u6cd5\u548c\u5c5e\u6027\u4e00\u8d77\u4f7f\u7528\u3002</p> <p>\u5bf9\u4e8e\u91cd\u8f7d\u65b9\u6cd5\uff0c\u60a8\u5e94\u8be5\u5728\u5b9e\u73b0\u4e0a\u6dfb\u52a0<code>@final</code>\u4ee5\u4f7f\u5176\u6700\u7ec8\uff08\u6216\u5728\u5b58\u6839\u4e2d\u7684\u7b2c\u4e00\u4e2a\u91cd\u8f7d\u4e0a\uff09\uff1a</p> <pre><code>from typing import Any, overload\n\nclass Base:\n    @overload\n    def method(self) -&gt; None: ...\n    @overload\n    def method(self, arg: int) -&gt; int: ...\n    @final\n    def method(self, x=None):\n        ...\n</code></pre> <p>Like with attributes, sometimes it is useful to protect a method from overriding. You can use the <code>typing.final</code> decorator for this purpose:</p> <pre><code>from typing import final\n\nclass Base:\n    @final\n    def common_name(self) -&gt; None:\n        ...\n\nclass Derived(Base):\n    def common_name(self) -&gt; None:  # Error: cannot override a final method\n        ...\n</code></pre> <p>This <code>@final</code> decorator can be used with instance methods, class methods, static methods, and properties.</p> <p>For overloaded methods you should add <code>@final</code> on the implementation to make it final (or on the first overload in stubs):</p> <pre><code>from typing import Any, overload\n\nclass Base:\n    @overload\n    def method(self) -&gt; None: ...\n    @overload\n    def method(self, arg: int) -&gt; int: ...\n    @final\n    def method(self, x=None):\n        ...\n</code></pre>"},{"location":"mypy/final_names_methods_classes/#\u6700\u7ec8\u7c7b","title":"\u6700\u7ec8\u7c7b","text":"<p>Final classes</p> \u4e2d\u6587\u82f1\u6587 <p>\u60a8\u53ef\u4ee5\u5c06 <code>typing.final</code> \u88c5\u9970\u5668\u5e94\u7528\u4e8e\u4e00\u4e2a\u7c7b\uff0c\u4ee5\u6307\u793a mypy \u5b83\u4e0d\u5e94\u88ab\u5b50\u7c7b\u5316\uff1a</p> <pre><code>from typing import final\n\n@final\nclass Leaf:\n    ...\n\nclass MyLeaf(Leaf):  # Error: Leaf can't be subclassed\n    ...\n</code></pre> <p>\u88c5\u9970\u5668\u5145\u5f53 mypy \u7684\u58f0\u660e\uff08\u4ee5\u53ca\u4eba\u7c7b\u7684\u6587\u6863\uff09\uff0c\u4f46\u5b83\u5b9e\u9645\u4e0a\u5e76\u4e0d\u80fd\u963b\u6b62\u8fd0\u884c\u65f6\u7684\u5b50\u7c7b\u5316\u3002</p> <p>\u4ee5\u4e0b\u662f\u4f7f\u7528 Final \u7c7b\u53ef\u80fd\u6709\u7528\u7684\u4e00\u4e9b\u60c5\u51b5\uff1a</p> <ul> <li>\u7c7b\u5e76\u4e0d\u662f\u8bbe\u8ba1\u6765\u8fdb\u884c\u5b50\u7c7b\u5316\u7684\u3002 \u4e5f\u8bb8\u5b50\u7c7b\u5316\u4e0d\u4f1a\u6309\u9884\u671f\u5de5\u4f5c\uff0c\u6216\u8005\u5b50\u7c7b\u5316\u5f88\u5bb9\u6613\u51fa\u9519\u3002</li> <li>\u5b50\u7c7b\u5316\u4f1a\u4f7f\u4ee3\u7801\u66f4\u96be\u7406\u89e3\u6216\u7ef4\u62a4\u3002 \u4f8b\u5982\uff0c\u60a8\u53ef\u80fd\u5e0c\u671b\u9632\u6b62\u57fa\u7c7b\u548c\u5b50\u7c7b\u4e4b\u95f4\u4e0d\u5fc5\u8981\u7684\u7d27\u5bc6\u8026\u5408\u3002</li> <li>\u60a8\u5e0c\u671b\u4fdd\u7559\u5c06\u6765\u4efb\u610f\u66f4\u6539\u7c7b\u5b9e\u73b0\u7684\u81ea\u7531\uff0c\u800c\u8fd9\u4e9b\u66f4\u6539\u53ef\u80fd\u4f1a\u7834\u574f\u5b50\u7c7b\u3002</li> </ul> <p>\u5b9a\u4e49\u81f3\u5c11\u4e00\u4e2a\u62bd\u8c61\u65b9\u6cd5\u6216\u5c5e\u6027\u5e76\u5177\u6709 <code>@final</code> \u88c5\u9970\u5668\u7684\u62bd\u8c61\u7c7b\u5c06\u4ece mypy \u4e2d\u751f\u6210\u9519\u8bef\uff0c\u56e0\u4e3a\u8fd9\u4e9b\u5c5e\u6027\u6c38\u8fdc\u65e0\u6cd5\u5b9e\u73b0\u3002</p> <pre><code>from abc import ABCMeta, abstractmethod\nfrom typing import final\n\n@final\nclass A(metaclass=ABCMeta):  # error: Final class A has abstract attributes \"f\"\n    @abstractmethod\n    def f(self, x: int) -&gt; None: pass\n</code></pre> <p>You can apply the <code>typing.final</code> decorator to a class to indicate to mypy that it should not be subclassed:</p> <pre><code>from typing import final\n\n@final\nclass Leaf:\n    ...\n\nclass MyLeaf(Leaf):  # Error: Leaf can't be subclassed\n    ...\n</code></pre> <p>The decorator acts as a declaration for mypy (and as documentation for humans), but it doesn't actually prevent subclassing at runtime.</p> <p>Here are some situations where using a final class may be useful:</p> <ul> <li>A class wasn't designed to be subclassed. Perhaps subclassing would not work as expected, or subclassing would be error-prone.</li> <li>Subclassing would make code harder to understand or maintain. For example, you may want to prevent unnecessarily tight coupling between base classes and subclasses.</li> <li>You want to retain the freedom to arbitrarily change the class implementation in the future, and these changes might break subclasses.</li> </ul> <p>An abstract class that defines at least one abstract method or property and has <code>@final</code> decorator will generate an error from mypy, since those attributes could never be implemented.</p> <pre><code>from abc import ABCMeta, abstractmethod\nfrom typing import final\n\n@final\nclass A(metaclass=ABCMeta):  # error: Final class A has abstract attributes \"f\"\n    @abstractmethod\n    def f(self, x: int) -&gt; None: pass\n</code></pre>"},{"location":"mypy/generics/","title":"\u6cdb\u578b","text":"\u4e2d\u6587\u82f1\u6587 <p>\u672c\u8282\u4ecb\u7ecd\u5982\u4f55\u5b9a\u4e49\u81ea\u5df1\u7684\u6cdb\u578b\u7c7b\uff0c\u8be5\u6cdb\u578b\u7c7b\u91c7\u7528\u4e00\u4e2a\u6216\u591a\u4e2a\u7c7b\u578b\u53c2\u6570\uff0c\u7c7b\u4f3c\u4e8e <code>list[X]</code> \u7b49\u5185\u7f6e\u7c7b\u578b\u3002 \u7528\u6237\u5b9a\u4e49\u7684\u6cdb\u578b\u662f\u4e00\u4e2a\u76f8\u5f53\u9ad8\u7ea7\u7684\u529f\u80fd\uff0c\u60a8\u53ef\u4ee5\u5728\u4e0d\u4f7f\u7528\u5b83\u4eec\u7684\u60c5\u51b5\u4e0b\u8d70\u5f97\u5f88\u8fdc\u2014\u2014\u8bf7\u968f\u610f\u8df3\u8fc7\u672c\u8282\u5e76\u7a0d\u540e\u518d\u56de\u6765\u3002</p> <p>Generics</p> <p>This section explains how you can define your own generic classes that take one or more type parameters, similar to built-in types such as <code>list[X]</code>. User-defined generics are a moderately advanced feature and you can get far without ever using them -- feel free to skip this section and come back later.</p>"},{"location":"mypy/generics/#\u5b9a\u4e49\u6cdb\u578b\u7c7b","title":"\u5b9a\u4e49\u6cdb\u578b\u7c7b","text":"<p>Defining generic classes</p> \u4e2d\u6587\u82f1\u6587 <p>\u5185\u7f6e\u96c6\u5408\u7c7b\u662f\u6cdb\u578b\u7c7b\u3002 \u6cdb\u578b\u7c7b\u578b\u6709\u4e00\u4e2a\u6216\u591a\u4e2a\u7c7b\u578b\u53c2\u6570\uff0c\u53ef\u4ee5\u662f\u4efb\u610f\u7c7b\u578b\u3002 \u4f8b\u5982\uff0c<code>dict[int, str]</code> \u5177\u6709\u7c7b\u578b\u53c2\u6570 \u201cint\u201d \u548c \u201cstr\u201d \uff0c\u201clist[int]\u201d \u5177\u6709\u7c7b\u578b\u53c2\u6570 \u201cint\u201d \u3002</p> <p>\u7a0b\u5e8f\u8fd8\u53ef\u4ee5\u5b9a\u4e49\u65b0\u7684\u6cdb\u578b\u7c7b\u3002 \u8fd9\u662f\u4e00\u4e2a\u975e\u5e38\u7b80\u5355\u7684\u6cdb\u578b\u7c7b\uff0c\u8868\u793a\u5806\u6808\uff1a</p> <pre><code>from typing import TypeVar, Generic\n\nT = TypeVar('T')\n\nclass Stack(Generic[T]):\n    def __init__(self) -&gt; None:\n        # Create an empty list with items of type T\n        self.items: list[T] = []\n\n    def push(self, item: T) -&gt; None:\n        self.items.append(item)\n\n    def pop(self) -&gt; T:\n        return self.items.pop()\n\n    def empty(self) -&gt; bool:\n        return not self.items\n</code></pre> <p>Stack \u7c7b\u53ef\u7528\u4e8e\u8868\u793a\u4efb\u4f55\u7c7b\u578b\u7684\u5806\u6808\uff1a<code>Stack[int]</code>\u3001<code>Stack[tuple[int, str]]</code> \u7b49\u3002</p> <p>\u4f7f\u7528 <code>Stack</code> \u4e0e\u5185\u7f6e\u5bb9\u5668\u7c7b\u578b\u7c7b\u4f3c\uff1a</p> <pre><code># \u6784\u9020\u4e00\u4e2a\u7a7a\u7684 Stack[int] \u5b9e\u4f8b\nstack = Stack[int]()\nstack.push(2)\nstack.pop()\nstack.push('x')  # error: Argument 1 to \"push\" of \"Stack\" has incompatible type \"str\"; expected \"int\"\n</code></pre> <p>\u6cdb\u578b\u7c7b\u578b\u5b9e\u4f8b\u7684\u6784\u9020\u7ecf\u8fc7\u7c7b\u578b\u68c0\u67e5\uff1a</p> <pre><code>class Box(Generic[T]):\n    def __init__(self, content: T) -&gt; None:\n        self.content = content\n\nBox(1)       # OK, inferred type is Box[int]\nBox[int](1)  # Also OK\nBox[int]('some string')  # error: Argument 1 to \"Box\" has incompatible type \"str\"; expected \"int\"\n</code></pre> <p>The built-in collection classes are generic classes. Generic types have one or more type parameters, which can be arbitrary types. For example, <code>dict[int, str]</code> has the type parameters <code>int</code> and <code>str</code>, and <code>list[int]</code> has a type parameter <code>int</code>.</p> <p>Programs can also define new generic classes. Here is a very simple generic class that represents a stack:</p> <pre><code>from typing import TypeVar, Generic\n\nT = TypeVar('T')\n\nclass Stack(Generic[T]):\n    def __init__(self) -&gt; None:\n        # Create an empty list with items of type T\n        self.items: list[T] = []\n\n    def push(self, item: T) -&gt; None:\n        self.items.append(item)\n\n    def pop(self) -&gt; T:\n        return self.items.pop()\n\n    def empty(self) -&gt; bool:\n        return not self.items\n</code></pre> <p>The <code>Stack</code> class can be used to represent a stack of any type: <code>Stack[int]</code>, <code>Stack[tuple[int, str]]</code>, etc.</p> <p>Using <code>Stack</code> is similar to built-in container types:</p> <pre><code># Construct an empty Stack[int] instance\nstack = Stack[int]()\nstack.push(2)\nstack.pop()\nstack.push('x')  # error: Argument 1 to \"push\" of \"Stack\" has incompatible type \"str\"; expected \"int\"\n</code></pre> <p>Construction of instances of generic types is type checked:</p> <pre><code>class Box(Generic[T]):\n    def __init__(self, content: T) -&gt; None:\n        self.content = content\n\nBox(1)       # OK, inferred type is Box[int]\nBox[int](1)  # Also OK\nBox[int]('some string')  # error: Argument 1 to \"Box\" has incompatible type \"str\"; expected \"int\"\n</code></pre>"},{"location":"mypy/generics/#\u5b9a\u4e49\u6cdb\u578b\u7c7b\u7684\u5b50\u7c7b","title":"\u5b9a\u4e49\u6cdb\u578b\u7c7b\u7684\u5b50\u7c7b","text":"<p>Defining subclasses of generic classes</p> \u4e2d\u6587\u82f1\u6587 <p>\u7528\u6237\u5b9a\u4e49\u7684\u6cdb\u578b\u7c7b\u548c <code>typing</code> \u4e2d\u5b9a\u4e49\u7684\u6cdb\u578b\u7c7b\u53ef\u4ee5\u7528\u4f5c\u53e6\u4e00\u4e2a\u7c7b\u7684\u57fa\u7c7b\uff08\u6cdb\u578b \u6216\u975e\u6cdb\u578b\uff09\u3002 \u4f8b\u5982\uff1a</p> <pre><code>from typing import Generic, TypeVar, Mapping, Iterator\n\nKT = TypeVar('KT')\nVT = TypeVar('VT')\n\n# \u8fd9\u662f Mapping \u7684\u901a\u7528\u5b50\u7c7b\nclass MyMap(Mapping[KT, VT]):\n    def __getitem__(self, k: KT) -&gt; VT: ...\n    def __iter__(self) -&gt; Iterator[KT]: ...\n    def __len__(self) -&gt; int: ...\n\nitems: MyMap[str, int]  # OK\n\n# \u8fd9\u662f dict \u7684\u975e\u6cdb\u578b\u5b50\u7c7b\nclass StrDict(dict[str, str]):\n    def __str__(self) -&gt; str:\n        return f'StrDict({super().__str__()})'\n\n\ndata: StrDict[int, int]  # Error! StrDict is not generic\ndata2: StrDict  # OK\n\n#\u8fd9\u662f\u4e00\u4e2a\u7528\u6237\u5b9a\u4e49\u7684\u6cdb\u578b\u7c7b\nclass Receiver(Generic[T]):\n    def accept(self, value: T) -&gt; None: ...\n\n# \u8fd9\u662f Receiver \u7684\u901a\u7528\u5b50\u7c7b\nclass AdvancedReceiver(Receiver[T]): ...\n</code></pre> <p>Note</p> <p>\u5982\u679c\u60a8\u5e0c\u671b mypy \u5c06\u7528\u6237\u5b9a\u4e49\u7684\u7c7b\u89c6\u4e3a\u6620\u5c04\uff08\u4ee5\u53ca\u5e8f\u5217\u7684 <code>Sequence</code> \u7b49\uff09\uff0c\u5219\u5fc5\u987b\u6dfb\u52a0\u663e\u5f0f\u7684 <code>Mapping</code> \u57fa\u7c7b\u3002 \u8fd9\u662f\u56e0\u4e3a mypy \u4e0d\u4e3a\u8fd9\u4e9b ABC \u4f7f\u7528\u201c\u7ed3\u6784\u5b50\u7c7b\u578b\u201d\uff0c\u4e0d\u50cf <code>Iterable</code> \u7b49\u66f4\u7b80\u5355\u7684\u534f\u8bae\uff0c\u5b83\u4f7f\u7528 <code>\u7ed3\u6784\u5b50\u7c7b\u578b</code></p> <p>\u5982\u679c\u8fd8\u6709\u5176\u4ed6\u5305\u542b\u7c7b\u578b\u53d8\u91cf\u7684\u57fa\u7c7b\uff0c\u4f8b\u5982\u4e0a\u4f8b\u4e2d\u7684 <code>Mapping[KT, VT]</code>\uff0c\u5219\u53ef\u4ee5\u4ece\u57fa\u7c7b\u4e2d\u7701\u7565 <code>Generic</code>\u3002 \u5982\u679c\u60a8\u5728\u57fa\u6570\u4e2d\u5305\u542b\u201cGeneric[...]\u201d\uff0c\u90a3\u4e48\u5b83\u5e94\u8be5\u5217\u51fa\u5176\u4ed6\u57fa\u6570\u4e2d\u5b58\u5728\u7684\u6240\u6709\u7c7b\u578b\u53d8\u91cf\uff08\u6216\u66f4\u591a\uff0c\u5982\u679c\u9700\u8981\uff09\u3002 \u7c7b\u578b\u53d8\u91cf\u7684\u987a\u5e8f\u7531\u4ee5\u4e0b\u89c4\u5219\u5b9a\u4e49\uff1a</p> <ul> <li>\u5982\u679c\u5b58\u5728\u201cGeneric[...]\u201d\uff0c\u5219\u53d8\u91cf\u7684\u987a\u5e8f\u59cb\u7ec8\u7531\u5b83\u4eec\u5728\u201cGeneric[...]\u201d\u4e2d\u7684\u987a\u5e8f\u786e\u5b9a\u3002</li> <li>\u5982\u679c\u57fa\u6570\u4e2d\u6ca1\u6709\u201cGeneric[...]\u201d\uff0c\u5219\u6240\u6709\u7c7b\u578b\u53d8\u91cf\u90fd\u6309\u5b57\u5178\u987a\u5e8f\u6536\u96c6\uff08\u5373\u6309\u9996\u6b21\u51fa\u73b0\uff09\u3002</li> </ul> <p>For example:</p> <pre><code>from typing import Generic, TypeVar, Any\n\nT = TypeVar('T')\nS = TypeVar('S')\nU = TypeVar('U')\n\nclass One(Generic[T]): ...\nclass Another(Generic[T]): ...\n\nclass First(One[T], Another[S]): ...\nclass Second(One[T], Another[S], Generic[S, U, T]): ...\n\nx: First[int, str]        # Here T is bound to int, S is bound to str\ny: Second[int, str, Any]  # Here T is Any, S is int, and U is str\n</code></pre> <p>User-defined generic classes and generic classes defined in <code>typing</code> can be used as a base class for another class (generic or non-generic). For example:</p> <pre><code>from typing import Generic, TypeVar, Mapping, Iterator\n\nKT = TypeVar('KT')\nVT = TypeVar('VT')\n\n# This is a generic subclass of Mapping\nclass MyMap(Mapping[KT, VT]):\n    def __getitem__(self, k: KT) -&gt; VT: ...\n    def __iter__(self) -&gt; Iterator[KT]: ...\n    def __len__(self) -&gt; int: ...\n\nitems: MyMap[str, int]  # OK\n\n# This is a non-generic subclass of dict\nclass StrDict(dict[str, str]):\n    def __str__(self) -&gt; str:\n        return f'StrDict({super().__str__()})'\n\n\ndata: StrDict[int, int]  # Error! StrDict is not generic\ndata2: StrDict  # OK\n\n# This is a user-defined generic class\nclass Receiver(Generic[T]):\n    def accept(self, value: T) -&gt; None: ...\n\n# This is a generic subclass of Receiver\nclass AdvancedReceiver(Receiver[T]): ...\n</code></pre> <p>Note</p> <p>You have to add an explicit <code>Mapping</code> base class if you want mypy to consider a user-defined class as a mapping (and <code>Sequence</code> for sequences, etc.). This is because mypy doesn't use structural subtyping for these ABCs, unlike simpler protocols like <code>Iterable</code>, which use <code>structural subtyping</code>.</p> <p><code>Generic</code> can be omitted from bases if there are other base classes that include type variables, such as <code>Mapping[KT, VT]</code> in the above example. If you include <code>Generic[...]</code> in bases, then it should list all type variables present in other bases (or more, if needed). The order of type variables is defined by the following rules:</p> <ul> <li>If <code>Generic[...]</code> is present, then the order of variables is always determined by their order in <code>Generic[...]</code>.</li> <li>If there are no <code>Generic[...]</code> in bases, then all type variables are collected in the lexicographic order (i.e. by first appearance).</li> </ul> <p>For example:</p> <pre><code>from typing import Generic, TypeVar, Any\n\nT = TypeVar('T')\nS = TypeVar('S')\nU = TypeVar('U')\n\nclass One(Generic[T]): ...\nclass Another(Generic[T]): ...\n\nclass First(One[T], Another[S]): ...\nclass Second(One[T], Another[S], Generic[S, U, T]): ...\n\nx: First[int, str]        # Here T is bound to int, S is bound to str\ny: Second[int, str, Any]  # Here T is Any, S is int, and U is str\n</code></pre>"},{"location":"mypy/generics/#\u6cdb\u578b\u51fd\u6570","title":"\u6cdb\u578b\u51fd\u6570","text":"<p>Generic functions</p> \u4e2d\u6587\u82f1\u6587 <p>\u7c7b\u578b\u53d8\u91cf\u53ef\u7528\u4e8e\u5b9a\u4e49\u6cdb\u578b\u51fd\u6570\uff1a</p> <pre><code>from typing import TypeVar, Sequence\n\nT = TypeVar('T')\n\n# A generic function!\ndef first(seq: Sequence[T]) -&gt; T:\n    return seq[0]\n</code></pre> <p>\u4e0e\u6cdb\u578b\u7c7b\u4e00\u6837\uff0c\u7c7b\u578b\u53d8\u91cf\u53ef\u4ee5\u66ff\u6362\u4e3a\u4efb\u4f55\u7c7b\u578b\u3002 \u8fd9\u610f\u5473\u7740\u201cfirst\u201d\u53ef\u4ee5\u4e0e\u4efb\u4f55\u5e8f\u5217\u7c7b\u578b\u4e00\u8d77\u4f7f\u7528\uff0c\u5e76\u4e14\u8fd4\u56de\u7c7b\u578b\u6d3e\u751f\u81ea\u5e8f\u5217\u9879\u7c7b\u578b\u3002 \u4f8b\u5982\uff1a</p> <pre><code>reveal_type(first([1, 2, 3]))   # Revealed type is \"builtins.int\"\nreveal_type(first(['a', 'b']))  # Revealed type is \"builtins.str\"\n</code></pre> <p>\u53e6\u8bf7\u6ce8\u610f\uff0c\u7c7b\u578b\u53d8\u91cf\u7684\u5355\u4e2a\u5b9a\u4e49\uff08\u4f8b\u5982\u4e0a\u9762\u7684\u201cT\u201d\uff09\u53ef\u4ee5\u5728\u591a\u4e2a\u6cdb\u578b\u51fd\u6570\u6216\u7c7b\u4e2d\u4f7f\u7528\u3002 \u5728\u6b64\u793a\u4f8b\u4e2d\uff0c\u6211\u4eec\u5728\u4e24\u4e2a\u6cdb\u578b\u51fd\u6570\u4e2d\u4f7f\u7528\u76f8\u540c\u7684\u7c7b\u578b\u53d8\u91cf\uff1a</p> <pre><code>from typing import TypeVar, Sequence\n\nT = TypeVar('T')      # \u58f0\u660e\u7c7b\u578b\u53d8\u91cf\n\ndef first(seq: Sequence[T]) -&gt; T:\n    return seq[0]\n\ndef last(seq: Sequence[T]) -&gt; T:\n    return seq[-1]\n</code></pre> <p>\u53d8\u91cf\u7684\u7c7b\u578b\u4e2d\u4e0d\u80fd\u5305\u542b\u7c7b\u578b\u53d8\u91cf\uff0c\u9664\u975e\u8be5\u7c7b\u578b\u53d8\u91cf\u7ed1\u5b9a\u5728\u5305\u542b\u6cdb\u578b\u7c7b\u6216\u51fd\u6570\u4e2d\u3002</p> <p>Type variables can be used to define generic functions:</p> <pre><code>from typing import TypeVar, Sequence\n\nT = TypeVar('T')\n\n# A generic function!\ndef first(seq: Sequence[T]) -&gt; T:\n    return seq[0]\n</code></pre> <p>As with generic classes, the type variable can be replaced with any type. That means <code>first</code> can be used with any sequence type, and the return type is derived from the sequence item type. For example:</p> <pre><code>reveal_type(first([1, 2, 3]))   # Revealed type is \"builtins.int\"\nreveal_type(first(['a', 'b']))  # Revealed type is \"builtins.str\"\n</code></pre> <p>Note also that a single definition of a type variable (such as <code>T</code> above) can be used in multiple generic functions or classes. In this example we use the same type variable in two generic functions:</p> <pre><code>from typing import TypeVar, Sequence\n\nT = TypeVar('T')      # Declare type variable\n\ndef first(seq: Sequence[T]) -&gt; T:\n    return seq[0]\n\ndef last(seq: Sequence[T]) -&gt; T:\n    return seq[-1]\n</code></pre> <p>A variable cannot have a type variable in its type unless the type variable is bound in a containing generic class or function.</p>"},{"location":"mypy/generics/#\u6cdb\u578b\u65b9\u6cd5\u548c\u81ea\u8eab\u6cdb\u578b","title":"\u6cdb\u578b\u65b9\u6cd5\u548c\u81ea\u8eab\u6cdb\u578b","text":"<p>Generic methods and generic self</p> \u4e2d\u6587\u82f1\u6587 <p>\u60a8\u8fd8\u53ef\u4ee5\u5b9a\u4e49\u6cdb\u578b\u65b9\u6cd5 - \u53ea\u9700\u5728\u65b9\u6cd5\u7b7e\u540d\u4e2d\u4f7f\u7528\u4e0e\u7c7b\u7c7b\u578b\u53d8\u91cf\u4e0d\u540c\u7684\u7c7b\u578b\u53d8\u91cf\u3002 \u7279\u522b\u662f\uff0c\u201cself\u201d \u53c2\u6570\u4e5f\u53ef\u4ee5\u662f\u901a\u7528\u7684\uff0c\u5141\u8bb8\u65b9\u6cd5\u8fd4\u56de\u8bbf\u95ee\u70b9\u5df2\u77e5\u7684\u6700\u7cbe\u786e\u7684\u7c7b\u578b\u3002 \u4f8b\u5982\uff0c\u60a8\u53ef\u4ee5\u901a\u8fc7\u8fd9\u79cd\u65b9\u5f0f\u68c0\u67e5\u4e00\u7cfb\u5217 setter \u65b9\u6cd5\uff1a</p> <pre><code>from typing import TypeVar\n\nT = TypeVar('T', bound='Shape')\n\nclass Shape:\n    def set_scale(self: T, scale: float) -&gt; T:\n        self.scale = scale\n        return self\n\nclass Circle(Shape):\n    def set_radius(self, r: float) -&gt; 'Circle':\n        self.radius = r\n        return self\n\nclass Square(Shape):\n    def set_width(self, w: float) -&gt; 'Square':\n        self.width = w\n        return self\n\ncircle: Circle = Circle().set_scale(0.5).set_radius(2.7)\nsquare: Square = Square().set_scale(0.5).set_width(3.2)\n</code></pre> <p>\u5982\u679c\u4e0d\u4f7f\u7528\u901a\u7528\u7684 \u201cself\u201d \uff0c\u6700\u540e\u4e24\u884c\u5c06\u65e0\u6cd5\u6b63\u786e\u8fdb\u884c\u7c7b\u578b\u68c0\u67e5\uff0c\u56e0\u4e3a \u201cset_scale\u201d \u7684\u8fd4\u56de\u7c7b\u578b\u5c06\u662f \u201cShape\u201d \uff0c\u800c\u5b83\u6ca1\u6709\u5b9a\u4e49 \u201cset_radius\u201d \u6216 \u201cset_width\u201d \u3002</p> <p>\u5176\u4ed6\u7528\u9014\u662f\u5de5\u5382\u65b9\u6cd5\uff0c\u4f8b\u5982\u590d\u5236\u548c\u53cd\u5e8f\u5217\u5316\u3002 \u5bf9\u4e8e\u7c7b\u65b9\u6cd5\uff0c\u60a8\u8fd8\u53ef\u4ee5\u4f7f\u7528 <code>Type[T]</code> \u5b9a\u4e49\u901a\u7528 <code>cls</code></p> <pre><code>from typing import TypeVar, Type\n\nT = TypeVar('T', bound='Friend')\n\nclass Friend:\n    other: \"Friend\" = None\n\n    @classmethod\n    def make_pair(cls: Type[T]) -&gt; tuple[T, T]:\n        a, b = cls(), cls()\n        a.other = b\n        b.other = a\n        return a, b\n\nclass SuperFriend(Friend):\n    pass\n\na, b = SuperFriend.make_pair()\n</code></pre> <p>\u8bf7\u6ce8\u610f\uff0c\u5f53\u4f7f\u7528\u901a\u7528\u201cself\u201d\u91cd\u5199\u65b9\u6cd5\u65f6\uff0c\u60a8\u4e5f\u5fc5\u987b\u8fd4\u56de\u901a\u7528\u201cself\u201d\uff0c\u6216\u8005\u8fd4\u56de\u5f53\u524d\u7c7b\u7684\u5b9e\u4f8b\u3002 \u5728\u540e\u4e00\u79cd\u60c5\u51b5\u4e0b\uff0c\u60a8\u5fc5\u987b\u5728\u6240\u6709\u672a\u6765\u7684\u5b50\u7c7b\u4e2d\u5b9e\u73b0\u6b64\u65b9\u6cd5\u3002</p> <p>\u53e6\u8bf7\u6ce8\u610f\uff0cmypy \u65e0\u6cd5\u59cb\u7ec8\u9a8c\u8bc1\u526f\u672c\u6216\u53cd\u5e8f\u5217\u5316\u65b9\u6cd5\u7684\u5b9e\u73b0\u662f\u5426\u8fd4\u56de self \u7684\u5b9e\u9645\u7c7b\u578b\u3002 \u56e0\u6b64\uff0c\u60a8\u53ef\u80fd\u9700\u8981\u5728\u8fd9\u4e9b\u65b9\u6cd5\u5185\uff08\u4f46\u4e0d\u662f\u5728\u8c03\u7528\u7ad9\u70b9\uff09\u9759\u9ed8 mypy\uff0c\u53ef\u80fd\u901a\u8fc7\u4f7f\u7528 \u201cAny\u201d \u7c7b\u578b\u6216 \u201c# type:ignore\u201d \u6ce8\u91ca\u3002</p> <p>\u8bf7\u6ce8\u610f\uff0cmypy \u5141\u8bb8\u60a8\u4ee5\u67d0\u4e9b\u4e0d\u5b89\u5168\u7684\u65b9\u5f0f\u4f7f\u7528\u901a\u7528\u81ea\u8eab\u7c7b\u578b\uff0c\u4ee5\u652f\u6301\u5e38\u89c1\u7684\u4e60\u60ef\u7528\u6cd5\u3002 \u4f8b\u5982\uff0c\u5728\u53c2\u6570\u7c7b\u578b\u4e2d\u4f7f\u7528\u901a\u7528\u81ea\u7c7b\u578b\u662f\u53ef\u4ee5\u63a5\u53d7\u7684\uff0c\u5373\u4f7f\u5b83\u4e0d\u5b89\u5168\uff1a</p> <pre><code>from typing import TypeVar\n\nT = TypeVar(\"T\")\n\nclass Base:\n    def compare(self: T, other: T) -&gt; bool:\n        return False\n\nclass Sub(Base):\n    def __init__(self, x: int) -&gt; None:\n        self.x = x\n\n    # \u8fd9\u662f\u4e0d\u5b89\u5168\u7684\uff08\u89c1\u4e0b\u6587\uff09\uff0c\u4f46\u5141\u8bb8\uff0c\u56e0\u4e3a\u8fd9\u662f\u4e00\u79cd\u5e38\u89c1\u6a21\u5f0f\uff0c\u5e76\u4e14\u5728\u5b9e\u8df5\u4e2d\u5f88\u5c11\u5f15\u8d77\u95ee\u9898\u3002\n    def compare(self, other: Sub) -&gt; bool:\n        return self.x &gt; other.x\n\nb: Base = Sub(42)\nb.compare(Base())  # \u8fd9\u91cc\u8fd0\u884c\u65f6\u9519\u8bef: 'Base' object has no attribute 'x'\n</code></pre> <p>\u6709\u5173 self \u7c7b\u578b\u7684\u4e00\u4e9b\u9ad8\u7ea7\u7528\u6cd5\uff0c\u8bf7\u53c2\u9605 <code>additional examples</code>.</p> <p>You can also define generic methods \u2014 just use a type variable in the method signature that is different from class type variables. In particular, the <code>self</code> argument may also be generic, allowing a method to return the most precise type known at the point of access. In this way, for example, you can type check a chain of setter methods:</p> <pre><code>from typing import TypeVar\n\nT = TypeVar('T', bound='Shape')\n\nclass Shape:\n    def set_scale(self: T, scale: float) -&gt; T:\n        self.scale = scale\n        return self\n\nclass Circle(Shape):\n    def set_radius(self, r: float) -&gt; 'Circle':\n        self.radius = r\n        return self\n\nclass Square(Shape):\n    def set_width(self, w: float) -&gt; 'Square':\n        self.width = w\n        return self\n\ncircle: Circle = Circle().set_scale(0.5).set_radius(2.7)\nsquare: Square = Square().set_scale(0.5).set_width(3.2)\n</code></pre> <p>Without using generic <code>self</code>, the last two lines could not be type checked properly, since the return type of <code>set_scale</code> would be <code>Shape</code>, which doesn't define <code>set_radius</code> or <code>set_width</code>.</p> <p>Other uses are factory methods, such as copy and deserialization. For class methods, you can also define generic <code>cls</code>, using <code>Type[T]</code>:</p> <pre><code>from typing import TypeVar, Type\n\nT = TypeVar('T', bound='Friend')\n\nclass Friend:\n    other: \"Friend\" = None\n\n    @classmethod\n    def make_pair(cls: Type[T]) -&gt; tuple[T, T]:\n        a, b = cls(), cls()\n        a.other = b\n        b.other = a\n        return a, b\n\nclass SuperFriend(Friend):\n    pass\n\na, b = SuperFriend.make_pair()\n</code></pre> <p>Note that when overriding a method with generic <code>self</code>, you must either return a generic <code>self</code> too, or return an instance of the current class. In the latter case, you must implement this method in all future subclasses.</p> <p>Note also that mypy cannot always verify that the implementation of a copy or a deserialization method returns the actual type of self. Therefore you may need to silence mypy inside these methods (but not at the call site), possibly by making use of the <code>Any</code> type or a <code># type: ignore</code> comment.</p> <p>Note that mypy lets you use generic self types in certain unsafe ways in order to support common idioms. For example, using a generic self type in an argument type is accepted even though it's unsafe:</p> <pre><code>from typing import TypeVar\n\nT = TypeVar(\"T\")\n\nclass Base:\n    def compare(self: T, other: T) -&gt; bool:\n        return False\n\nclass Sub(Base):\n    def __init__(self, x: int) -&gt; None:\n        self.x = x\n\n    # This is unsafe (see below) but allowed because it's\n    # a common pattern and rarely causes issues in practice.\n    def compare(self, other: Sub) -&gt; bool:\n        return self.x &gt; other.x\n\nb: Base = Sub(42)\nb.compare(Base())  # Runtime error here: 'Base' object has no attribute 'x'\n</code></pre> <p>For some advanced uses of self types, see <code>additional examples</code>.</p>"},{"location":"mypy/generics/#\u4f7f\u7528-typingself-\u81ea\u52a8\u6807\u6ce8self\u7c7b\u578b","title":"\u4f7f\u7528 Typing.Self \u81ea\u52a8\u6807\u6ce8self\u7c7b\u578b","text":"<p>Automatic self types using typing.Self</p> \u4e2d\u6587\u82f1\u6587 <p>\u7531\u4e8e\u4e0a\u8ff0\u6a21\u5f0f\u975e\u5e38\u5e38\u89c1\uff0c\u56e0\u6b64 mypy \u652f\u6301 <code>PEP-673</code> \u4e2d\u5f15\u5165\u7684\u66f4\u7b80\u5355\u7684\u8bed\u6cd5\uff0c\u4ee5\u4f7f\u5b83\u4eec\u66f4\u6613\u4e8e\u4f7f\u7528\u3002 \u60a8\u53ef\u4ee5\u5bfc\u5165\u7279\u6b8a\u7c7b\u578b\u201ctyping.Self\u201d\uff0c\u800c\u4e0d\u662f\u5b9a\u4e49\u7c7b\u578b\u53d8\u91cf\u5e76\u4e3a\u201cself\u201d\u4f7f\u7528\u663e\u5f0f\u6ce8\u91ca\uff0c\u8be5\u7c7b\u578b\u4f1a\u81ea\u52a8\u8f6c\u6362\u4e3a\u4ee5\u5f53\u524d\u7c7b\u4e3a\u4e0a\u9650\u7684\u7c7b\u578b\u53d8\u91cf\uff0c\u5e76\u4e14\u4e0d\u9700\u8981 \u201cself\u201d\uff08\u6216\u7c7b\u65b9\u6cd5\u4e2d\u7684\u201ccls\u201d\uff09\u7684\u6ce8\u91ca\u3002 \u4f7f\u7528 <code>Self</code> \u53ef\u4ee5\u4f7f\u4e0a\u4e00\u8282\u7684\u793a\u4f8b\u53d8\u5f97\u66f4\u7b80\u5355\uff1a</p> <pre><code>from typing import Self\n\nclass Friend:\n    other: Self | None = None\n\n    @classmethod\n    def make_pair(cls) -&gt; tuple[Self, Self]:\n        a, b = cls(), cls()\n        a.other = b\n        b.other = a\n        return a, b\n\nclass SuperFriend(Friend):\n    pass\n\na, b = SuperFriend.make_pair()\n</code></pre> <p>\u8fd9\u6bd4\u4f7f\u7528\u663e\u5f0f\u7c7b\u578b\u53d8\u91cf\u66f4\u7d27\u51d1\u3002 \u6b64\u5916\uff0c\u9664\u4e86\u65b9\u6cd5\u4e4b\u5916\uff0c\u60a8\u8fd8\u53ef\u4ee5\u5728\u5c5e\u6027\u6ce8\u91ca\u4e2d\u4f7f\u7528\u201cSelf\u201d\u3002</p> <p>Note</p> <p>\u8981\u5728\u65e9\u4e8e 3.11 \u7684 Python \u7248\u672c\u4e0a\u4f7f\u7528\u6b64\u529f\u80fd\uff0c\u60a8\u9700\u8981\u4ece <code>typing_extensions</code>\uff08\u7248\u672c 4.0 \u6216\u66f4\u9ad8\u7248\u672c\uff09\u5bfc\u5165 <code>Self</code>\u3002</p> <p>Since the patterns described above are quite common, mypy supports a simpler syntax, introduced in <code>PEP-673</code>, to make them easier to use. Instead of defining a type variable and using an explicit annotation for <code>self</code>, you can import the special type <code>typing.Self</code> that is automatically transformed into a type variable with the current class as the upper bound, and you don't need an annotation for <code>self</code> (or <code>cls</code> in class methods). The example from the previous section can be made simpler by using <code>Self</code>:</p> <pre><code>from typing import Self\n\nclass Friend:\n    other: Self | None = None\n\n    @classmethod\n    def make_pair(cls) -&gt; tuple[Self, Self]:\n        a, b = cls(), cls()\n        a.other = b\n        b.other = a\n        return a, b\n\nclass SuperFriend(Friend):\n    pass\n\na, b = SuperFriend.make_pair()\n</code></pre> <p>This is more compact than using explicit type variables. Also, you can use <code>Self</code> in attribute annotations in addition to methods.</p> <p>Note</p> <p>To use this feature on Python versions earlier than 3.11, you will need to import <code>Self</code> from <code>typing_extensions</code> (version 4.0 or newer).</p>"},{"location":"mypy/generics/#\u6cdb\u578b\u7c7b\u578b\u7684\u53d8\u4f53","title":"\u6cdb\u578b\u7c7b\u578b\u7684\u53d8\u4f53","text":"<p>Variance of generic types</p> \u4e2d\u6587\u82f1\u6587 <p>\u5c31\u6cdb\u578b\u7c7b\u578b\u4e4b\u95f4\u7684\u5b50\u7c7b\u578b\u5173\u7cfb\u800c\u8a00\uff0c\u6cdb\u578b\u7c7b\u578b\u4e3b\u8981\u5206\u4e3a\u4e09\u79cd\uff1a\u4e0d\u53d8\u3001\u534f\u53d8\u548c\u9006\u53d8\u3002 \u5047\u8bbe\u6211\u4eec\u6709\u4e00\u5bf9\u7c7b\u578b\u201cA\u201d\u548c\u201cB\u201d\uff0c\u5e76\u4e14\u201cB\u201d\u662f\u201cA\u201d\u7684\u5b50\u7c7b\u578b\uff0c\u5b83\u4eec\u7684\u5b9a\u4e49\u5982\u4e0b\uff1a</p> <ul> <li>\u5982\u679c <code>MyCovGen[B]</code> \u59cb\u7ec8\u662f <code>MyCovGen[A]</code> \u7684\u5b50\u7c7b\u578b\uff0c\u5219\u6cdb\u578b\u7c7b <code>MyCovGen[T]</code> \u4e2d\u7684\u7c7b\u578b\u53d8\u91cf <code>T</code> \u79f0\u4e3a\u534f\u53d8\u3002</li> <li>\u5982\u679c <code>MyContraGen[A]</code> \u59cb\u7ec8\u662f <code>MyContraGen[B]</code> \u7684\u5b50\u7c7b\u578b\uff0c\u5219\u6cdb\u578b\u7c7b <code>MyContraGen[T]</code> \u4e2d\u7684\u7c7b\u578b\u53d8\u91cf <code>T</code> \u79f0\u4e3a\u9006\u53d8\u3002</li> <li>\u5982\u679c\u4e0a\u8ff0\u4e24\u4e2a\u6761\u4ef6\u90fd\u4e0d\u6210\u7acb\uff0c\u5219\u6cdb\u578b\u7c7b \u201cMyInvGen[T]\u201d \u4e2d\u7684 \u201cT\u201d \u79f0\u4e3a\u4e0d\u53d8\u5f0f\u3002</li> </ul> <p>\u8ba9\u6211\u4eec\u901a\u8fc7\u51e0\u4e2a\u7b80\u5355\u7684\u4f8b\u5b50\u6765\u8bf4\u660e\u8fd9\u4e00\u70b9\uff1a</p> <pre><code># \u6211\u4eec\u5c06\u5728\u4e0b\u9762\u7684\u793a\u4f8b\u4e2d\u4f7f\u7528\u8fd9\u4e9b\u7c7b\nclass Shape: ...\nclass Triangle(Shape): ...\nclass Square(Shape): ...\n</code></pre> <ul> <li>\u5927\u591a\u6570\u4e0d\u53ef\u53d8\u5bb9\u5668\uff0c\u4f8b\u5982 <code>Sequence</code> \u548c <code>FrozenSet</code> \u662f\u534f\u53d8\u7684. <code>Union</code> \u5728\u6240\u6709\u53d8\u91cf\u4e2d\u4e5f\u662f\u534f\u53d8\u7684\uff1a <code>Union[Triangle, int]</code> \u662f <code>Union[Shape, int]</code> \u7684\u5b50\u7c7b\u578b\u3002</li> </ul> <pre><code>def count_lines(shapes: Sequence[Shape]) -&gt; int:\n    return sum(shape.num_sides for shape in shapes)\n\ntriangles: Sequence[Triangle]\ncount_lines(triangles)  # OK\n\ndef foo(triangle: Triangle, num: int):\n    shape_or_number: Union[Shape, int]\n    # \u4e09\u89d2\u5f62\u662f\u5f62\u72b6\uff0c\u5f62\u72b6\u662f\u6709\u6548\u7684 Union[Shape, int]\n    shape_or_number = triangle\n</code></pre> <p>\u534f\u53d8\u5e94\u8be5\u76f8\u5bf9\u76f4\u89c2\uff0c\u4f46\u9006\u53d8\u548c\u4e0d\u53d8\u53ef\u80fd\u66f4\u96be\u63a8\u7406\u3002</p> <ul> <li><code>Callable</code> \u662f\u5728\u53c2\u6570\u7c7b\u578b\u4e2d\u8868\u73b0\u9006\u53d8\u7684\u7c7b\u578b\u793a\u4f8b\u3002 \u4e5f\u5c31\u662f\u8bf4\uff0c\u5c3d\u7ba1\u201cShape\u201d\u662f\u201cTriangle\u201d\u7684\u8d85\u7c7b\u578b\uff0c\u4f46 \u201cCallable[[Shape], int]\u201d \u662f \u201cCallable[[Triangle], int]\u201d \u7684\u5b50\u7c7b\u578b\u3002 \u8981\u7406\u89e3\u8fd9\u4e00\u70b9\uff0c\u8bf7\u8003\u8651\uff1a</li> </ul> <pre><code>def cost_of_paint_required(\n    triangle: Triangle,\n    area_calculator: Callable[[Triangle], float]\n) -&gt; float:\n    return area_calculator(triangle) * DOLLAR_PER_SQ_FT\n\n# \u8fd9\u76f4\u63a5\u6709\u6548\ndef area_of_triangle(triangle: Triangle) -&gt; float: ...\ncost_of_paint_required(triangle, area_of_triangle)  # OK\n\n# \u4f46\u8fd9\u4e5f\u6709\u6548\uff01\ndef area_of_any_shape(shape: Shape) -&gt; float: ...\ncost_of_paint_required(triangle, area_of_any_shape)  # OK\n</code></pre> <p><code>cost_of_paint_required</code> \u9700\u8981\u4e00\u4e2a\u53ef\u4ee5\u8ba1\u7b97\u4e09\u89d2\u5f62\u9762\u79ef\u7684\u53ef\u8c03\u7528\u51fd\u6570\u3002 \u5982\u679c\u6211\u4eec\u7ed9\u5b83\u4e00\u4e2a\u53ef\u4ee5\u8ba1\u7b97\u4efb\u610f\u5f62\u72b6\uff08\u4e0d\u4ec5\u4ec5\u662f\u4e09\u89d2\u5f62\uff09\u9762\u79ef\u7684\u53ef\u8c03\u7528\u51fd\u6570\uff0c\u4e00\u5207\u4ecd\u7136\u6709\u6548\u3002</p> <ul> <li><code>List</code> \u662f\u4e0d\u53d8\u7684\u6cdb\u578b\u7c7b\u578b\u3002 \u5929\u771f\u7684\u4eba\u4f1a\u8ba4\u4e3a\u5b83\u662f\u534f\u53d8\u7684\uff0c\u5c31\u50cf\u4e0a\u9762\u7684 <code>Sequence</code> \u4e00\u6837\uff0c\u4f46\u8bf7\u8003\u8651\u4ee5\u4e0b\u4ee3\u7801\uff1a</li> </ul> <pre><code>class Circle(Shape):\n    # \u65cb\u8f6c\u65b9\u6cd5\u4ec5\u5728 Circle \u4e0a\u5b9a\u4e49\uff0c\u5728 Shape \u4e0a\u6ca1\u6709\u5b9a\u4e49\n    def rotate(self): ...\n\ndef add_one(things: list[Shape]) -&gt; None:\n    things.append(Shape())\n\nmy_circles: list[Circle] = []\nadd_one(my_circles)     # \u8fd9\u53ef\u80fd\u770b\u8d77\u6765\u5f88\u5b89\u5168\uff0c\u4f46\u662f......\nmy_circles[-1].rotate()  # ...\u8fd9\u5c06\u4f1a\u5931\u8d25\uff0c\u56e0\u4e3a my_circles[0] \u73b0\u5728\u662f\u4e00\u4e2a Shape\uff0c\u800c\u4e0d\u662f\u4e00\u4e2a Circle\n</code></pre> <p>\u4e0d\u53d8\u7c7b\u578b\u7684\u53e6\u4e00\u4e2a\u4f8b\u5b50\u662f <code>Dict</code>\u3002 \u5927\u591a\u6570\u53ef\u53d8\u5bb9\u5668\u662f\u4e0d\u53d8\u7684\u3002</p> <p>\u9ed8\u8ba4\u60c5\u51b5\u4e0b\uff0cmypy \u5047\u5b9a\u6240\u6709\u7528\u6237\u5b9a\u4e49\u7684\u6cdb\u578b\u90fd\u662f\u4e0d\u53d8\u7684\u3002 \u8981\u5c06\u7ed9\u5b9a\u7684\u6cdb\u578b\u7c7b\u58f0\u660e\u4e3a\u534f\u53d8\u6216\u9006\u53d8\uff0c\u8bf7\u4f7f\u7528\u4f7f\u7528\u7279\u6b8a\u5173\u952e\u5b57\u53c2\u6570 \u201ccovariant\u201d \u6216 \u201ccontravariant\u201d \u5b9a\u4e49\u7684\u7c7b\u578b\u53d8\u91cf\u3002 \u4f8b\u5982\uff1a</p> <pre><code>from typing import Generic, TypeVar\n\nT_co = TypeVar('T_co', covariant=True)\n\nclass Box(Generic[T_co]):  # \u8be5\u7c7b\u578b\u88ab\u58f0\u660e\u4e3a\u534f\u53d8\u7684\n    def __init__(self, content: T_co) -&gt; None:\n        self._content = content\n\n    def get_content(self) -&gt; T_co:\n        return self._content\n\ndef look_into(box: Box[Animal]): ...\n\nmy_box = Box(Cat())\nlook_into(my_box)  # \u597d\u7684\uff0c\u4f46\u662f mypy \u4f1a\u5728\u8fd9\u91cc\u62b1\u6028\u4e0d\u53d8\u7c7b\u578b\n</code></pre> <p>There are three main kinds of generic types with respect to subtype relations between them: invariant, covariant, and contravariant. Assuming that we have a pair of types <code>A</code> and <code>B</code>, and <code>B</code> is a subtype of <code>A</code>, these are defined as follows:</p> <ul> <li>A generic class <code>MyCovGen[T]</code> is called covariant in type variable <code>T</code> if <code>MyCovGen[B]</code> is always a subtype of <code>MyCovGen[A]</code>.</li> <li>A generic class <code>MyContraGen[T]</code> is called contravariant in type variable <code>T</code> if <code>MyContraGen[A]</code> is always a subtype of <code>MyContraGen[B]</code>.</li> <li>A generic class <code>MyInvGen[T]</code> is called invariant in <code>T</code> if neither of the above is true.</li> </ul> <p>Let us illustrate this by few simple examples:</p> <pre><code># We'll use these classes in the examples below\nclass Shape: ...\nclass Triangle(Shape): ...\nclass Square(Shape): ...\n</code></pre> <ul> <li>Most immutable containers, such as <code>Sequence</code> and <code>FrozenSet</code> are covariant. <code>Union</code> is also covariant in all variables: <code>Union[Triangle, int]</code> is a subtype of <code>Union[Shape, int]</code>.</li> </ul> <pre><code>def count_lines(shapes: Sequence[Shape]) -&gt; int:\n    return sum(shape.num_sides for shape in shapes)\n\ntriangles: Sequence[Triangle]\ncount_lines(triangles)  # OK\n\ndef foo(triangle: Triangle, num: int):\n    shape_or_number: Union[Shape, int]\n    # a Triangle is a Shape, and a Shape is a valid Union[Shape, int]\n    shape_or_number = triangle\n</code></pre> <p>Covariance should feel relatively intuitive, but contravariance and invariance can be harder to reason about.</p> <ul> <li><code>Callable</code> is an example of type that behaves contravariant in types of arguments. That is, <code>Callable[[Shape], int]</code> is a subtype of <code>Callable[[Triangle], int]</code>, despite <code>Shape</code> being a supertype of <code>Triangle</code>. To understand this, consider:</li> </ul> <pre><code>def cost_of_paint_required(\n    triangle: Triangle,\n    area_calculator: Callable[[Triangle], float]\n) -&gt; float:\n    return area_calculator(triangle) * DOLLAR_PER_SQ_FT\n\n# This straightforwardly works\ndef area_of_triangle(triangle: Triangle) -&gt; float: ...\ncost_of_paint_required(triangle, area_of_triangle)  # OK\n\n# But this works as well!\ndef area_of_any_shape(shape: Shape) -&gt; float: ...\ncost_of_paint_required(triangle, area_of_any_shape)  # OK\n</code></pre> <p><code>cost_of_paint_required</code> needs a callable that can calculate the area of a triangle. If we give it a callable that can calculate the area of an arbitrary shape (not just triangles), everything still works.</p> <ul> <li><code>List</code> is an invariant generic type. Naively, one would think that it is covariant, like <code>Sequence</code> above, but consider this code:</li> </ul> <pre><code>class Circle(Shape):\n    # The rotate method is only defined on Circle, not on Shape\n    def rotate(self): ...\n\ndef add_one(things: list[Shape]) -&gt; None:\n    things.append(Shape())\n\nmy_circles: list[Circle] = []\nadd_one(my_circles)     # This may appear safe, but...\nmy_circles[-1].rotate()  # ...this will fail, since my_circles[0] is now a Shape, not a Circle\n</code></pre> <p>Another example of invariant type is <code>Dict</code>. Most mutable containers are invariant.</p> <p>By default, mypy assumes that all user-defined generics are invariant. To declare a given generic class as covariant or contravariant use type variables defined with special keyword arguments <code>covariant</code> or <code>contravariant</code>. For example:</p> <pre><code>from typing import Generic, TypeVar\n\nT_co = TypeVar('T_co', covariant=True)\n\nclass Box(Generic[T_co]):  # this type is declared covariant\n    def __init__(self, content: T_co) -&gt; None:\n        self._content = content\n\n    def get_content(self) -&gt; T_co:\n        return self._content\n\ndef look_into(box: Box[Animal]): ...\n\nmy_box = Box(Cat())\nlook_into(my_box)  # OK, but mypy would complain here for an invariant type\n</code></pre>"},{"location":"mypy/generics/#\u5177\u6709\u7ed1\u5b9a\u7684\u7c7b\u578b\u53d8\u91cf","title":"\u5177\u6709\u7ed1\u5b9a\u7684\u7c7b\u578b\u53d8\u91cf","text":"<p>Type variables with upper bounds</p> \u4e2d\u6587\u82f1\u6587 <p>\u7c7b\u578b\u53d8\u91cf\u8fd8\u53ef\u4ee5\u88ab\u9650\u5236\u4e3a\u5177\u6709\u7279\u5b9a\u7c7b\u578b\u7684\u5b50\u7c7b\u578b\u7684\u503c\u3002 \u8be5\u7c7b\u578b\u79f0\u4e3a\u7c7b\u578b\u53d8\u91cf\u7684\u4e0a\u9650\uff0c\u5e76\u4f7f\u7528 <code>TypeVar</code> \u7684 <code>bound=...</code> \u5173\u952e\u5b57\u53c2\u6570\u6307\u5b9a</p> <pre><code>from typing import TypeVar, SupportsAbs\n\nT = TypeVar('T', bound=SupportsAbs[float])\n</code></pre> <p>\u5728\u4f7f\u7528\u6b64\u7c7b\u7c7b\u578b\u53d8\u91cf <code>T</code> \u7684\u6cdb\u578b\u51fd\u6570\u7684\u5b9a\u4e49\u4e2d\uff0c\u5047\u5b9a <code>T</code> \u8868\u793a\u7684\u7c7b\u578b\u662f\u5176\u4e0a\u9650\u7684\u5b50\u7c7b\u578b\uff0c\u56e0\u6b64\u8be5\u51fd\u6570\u53ef\u4ee5\u5bf9\u7c7b\u578b <code>T</code> \u7684\u503c\u4f7f\u7528\u4e0a\u9650\u7684\u65b9\u6cd5\u3002</p> <pre><code>def largest_in_absolute_value(*xs: T) -&gt; T:\n    return max(xs, key=abs)  # OK\uff0c\u56e0\u4e3a T \u662f SupportsAbs[float] \u7684\u5b50\u7c7b\u578b\u3002\n</code></pre> <p>\u5728\u8c03\u7528\u6b64\u7c7b\u51fd\u6570\u65f6\uff0c\u7c7b\u578b\u201cT\u201d\u5fc5\u987b\u66ff\u6362\u4e3a\u5176\u4e0a\u9650\u7684\u5b50\u7c7b\u578b\u3002 \u7ee7\u7eed\u4e0a\u9762\u7684\u4f8b\u5b50\uff1a</p> <pre><code>largest_in_absolute_value(-3.5, 2)   # Okay, \u5177\u6709 float \u7c7b\u578b\u3002\nlargest_in_absolute_value(5+6j, 7)   # Okay, \u5177\u6709\u590d\u6570\u7c7b\u578b\u3002\nlargest_in_absolute_value('a', 'b')  # Error: 'str' is not a subtype of SupportsAbs[float].\n</code></pre> <p>\u6cdb\u578b\u7c7b\u7684\u7c7b\u578b\u53c2\u6570\u4e5f\u53ef\u80fd\u6709\u4e0a\u9650\uff0c\u5b83\u4ee5\u76f8\u540c\u7684\u65b9\u5f0f\u9650\u5236\u7c7b\u578b\u53c2\u6570\u7684\u6709\u6548\u503c\u3002</p> <p>A type variable can also be restricted to having values that are subtypes of a specific type. This type is called the upper bound of the type variable, and is specified with the <code>bound=...</code> keyword argument to <code>TypeVar</code>.</p> <pre><code>from typing import TypeVar, SupportsAbs\n\nT = TypeVar('T', bound=SupportsAbs[float])\n</code></pre> <p>In the definition of a generic function that uses such a type variable <code>T</code>, the type represented by <code>T</code> is assumed to be a subtype of its upper bound, so the function can use methods of the upper bound on values of type <code>T</code>.</p> <pre><code>def largest_in_absolute_value(*xs: T) -&gt; T:\n    return max(xs, key=abs)  # Okay, because T is a subtype of SupportsAbs[float].\n</code></pre> <p>In a call to such a function, the type <code>T</code> must be replaced by a type that is a subtype of its upper bound. Continuing the example above:</p> <pre><code>largest_in_absolute_value(-3.5, 2)   # Okay, has type float.\nlargest_in_absolute_value(5+6j, 7)   # Okay, has type complex.\nlargest_in_absolute_value('a', 'b')  # Error: 'str' is not a subtype of SupportsAbs[float].\n</code></pre> <p>Type parameters of generic classes may also have upper bounds, which restrict the valid values for the type parameter in the same way.</p>"},{"location":"mypy/generics/#\u5177\u6709\u503c\u9650\u5236\u7684\u7c7b\u578b\u53d8\u91cf","title":"\u5177\u6709\u503c\u9650\u5236\u7684\u7c7b\u578b\u53d8\u91cf","text":"<p>Type variables with value restriction</p> \u4e2d\u6587\u82f1\u6587 <p>\u9ed8\u8ba4\u60c5\u51b5\u4e0b\uff0c\u7c7b\u578b\u53d8\u91cf\u53ef\u4ee5\u66ff\u6362\u4e3a\u4efb\u4f55\u7c7b\u578b\u3002 \u4f46\u662f\uff0c\u6709\u65f6\u4f7f\u7528\u53ea\u80fd\u5c06\u67d0\u4e9b\u7279\u5b9a\u7c7b\u578b\u4f5c\u4e3a\u5176\u503c\u7684\u7c7b\u578b\u53d8\u91cf\u5f88\u6709\u7528\u3002 \u4e00\u4e2a\u5178\u578b\u7684\u4f8b\u5b50\u662f\u7c7b\u578b\u53d8\u91cf\u53ea\u80fd\u6709\u503c \u201cstr\u201d \u548c \u201cbytes\u201d \uff1a</p> <pre><code>from typing import TypeVar\n\nAnyStr = TypeVar('AnyStr', str, bytes)\n</code></pre> <p>\u8fd9\u5b9e\u9645\u4e0a\u662f\u4e00\u4e2a\u5e38\u89c1\u7684\u7c7b\u578b\u53d8\u91cf\uff0c<code>AnyStr</code> \u5728 <code>typing</code>\u4e2d\uff0c\u6211\u4eec\u4e0d\u9700\u8981\u81ea\u5df1\u5b9a\u4e49\u5b83\u3002</p> <p>\u6211\u4eec\u53ef\u4ee5\u4f7f\u7528 <code>AnyStr</code> \u5b9a\u4e49\u4e00\u4e2a\u53ef\u4ee5\u8fde\u63a5\u4e24\u4e2a\u5b57\u7b26\u4e32\u6216\u5b57\u8282\u5bf9\u8c61\u7684\u51fd\u6570\uff0c\u4f46\u5b83\u4e0d\u80fd\u4f7f\u7528\u5176\u4ed6\u53c2\u6570\u7c7b\u578b\u8c03\u7528\uff1a</p> <pre><code>from typing import AnyStr\n\ndef concat(x: AnyStr, y: AnyStr) -&gt; AnyStr:\n    return x + y\n\nconcat('a', 'b')    # Okay\nconcat(b'a', b'b')  # Okay\nconcat(1, 2)        # Error!\n</code></pre> <p>\u91cd\u8981\u7684\u662f\uff0c\u8fd9\u4e0e\u8054\u5408\u7c7b\u578b\u4e0d\u540c\uff0c\u56e0\u4e3a\u4e0d\u63a5\u53d7\u201cstr\u201d\u548c\u201cbytes\u201d\u7684\u7ec4\u5408\uff1a</p> <pre><code>concat('string', b'bytes')   # Error!\n</code></pre> <p>\u5728\u8fd9\u79cd\u60c5\u51b5\u4e0b\uff0c\u8fd9\u6b63\u662f\u6211\u4eec\u60f3\u8981\u7684\uff0c\u56e0\u4e3a\u4e0d\u53ef\u80fd\u8fde\u63a5\u5b57\u7b26\u4e32\u548c\u5b57\u8282\u5bf9\u8c61\uff01 \u5982\u679c\u6211\u4eec\u5c1d\u8bd5\u4f7f\u7528 \u201cUnion\u201d \uff0c\u7c7b\u578b\u68c0\u67e5\u5668\u4f1a\u62b1\u6028\u8fd9\u79cd\u53ef\u80fd\u6027\uff1a</p> <pre><code>def union_concat(x: Union[str, bytes], y: Union[str, bytes]) -&gt; Union[str, bytes]:\n    return x + y  # Error: can't concatenate str and bytes\n</code></pre> <p>\u53e6\u4e00\u4e2a\u6709\u8da3\u7684\u7279\u6b8a\u60c5\u51b5\u662f\u4f7f\u7528 \u201cstr\u201d \u7684\u5b50\u7c7b\u578b\u8c03\u7528 \u201cconcat()\u201d \uff1a</p> <pre><code>class S(str): pass\n\nss = concat(S('foo'), S('bar'))\nreveal_type(ss)  # \u663e\u793a\u7684\u7c7b\u578b\u662f\u201cbuiltins.str\u201d\n</code></pre> <p>\u60a8\u53ef\u80fd\u8ba4\u4e3a\u201css\u201d\u7684\u7c7b\u578b\u662f\u201cS\u201d\uff0c\u4f46\u5b9e\u9645\u4e0a\u7c7b\u578b\u662f\u201cstr\u201d\uff1a\u5b50\u7c7b\u578b\u88ab\u63d0\u5347\u4e3a\u7c7b\u578b\u53d8\u91cf\u7684\u6709\u6548\u503c\u4e4b\u4e00\uff0c\u5728\u672c\u4f8b\u4e2d\u662f\u201cstr\u201d\u3002</p> <p>\u56e0\u6b64\uff0c\u8fd9\u4e0e Java \u7b49\u8bed\u8a00\u4e2d\u7684\u201c\u6709\u754c\u91cf\u5316\u201d \u7565\u6709\u4e0d\u540c\uff0c\u5176\u4e2d\u8fd4\u56de\u7c7b\u578b\u4e3a \u201cS\u201d\u3002 mypy \u5b9e\u73b0\u8fd9\u4e00\u70b9\u7684\u65b9\u5f0f\u5bf9\u4e8e <code>concat</code> \u6765\u8bf4\u662f\u6b63\u786e\u7684\uff0c\u56e0\u4e3a\u5728\u4e0a\u9762\u7684\u793a\u4f8b\u4e2d\uff0c<code>concat</code> \u5b9e\u9645\u4e0a\u8fd4\u56de\u4e86\u4e00\u4e2a <code>str</code> \u5b9e\u4f8b\uff1a</p> <pre><code>&gt;&gt;&gt; print(type(ss))\n&lt;class 'str'&gt;\n</code></pre> <p>\u5728\u5b9a\u4e49\u6cdb\u578b\u7c7b\u65f6\uff0c\u60a8\u8fd8\u53ef\u4ee5\u5c06 <code>TypeVar</code> \u4e0e\u4e00\u7ec4\u6709\u9650\u7684\u53ef\u80fd\u503c\u4e00\u8d77\u4f7f\u7528\u3002 \u4f8b\u5982\uff0cmypy \u4f7f\u7528\u7c7b\u578b <code>Pattern[AnyStr]</code> \u4f5c\u4e3a [<code>re.compile</code>] \u7684\u8fd4\u56de\u503c \uff08https://docs.python.org/3/library/re.html#re.compile\uff09\uff0c\u56e0\u4e3a\u6b63\u5219\u8868\u8fbe\u5f0f\u53ef\u4ee5\u57fa\u4e8e\u5b57\u7b26\u4e32\u6216\u5b57\u8282\u6a21\u5f0f\u3002</p> <p>\u7c7b\u578b\u53d8\u91cf\u4e0d\u80fd\u540c\u65f6\u5177\u6709\u503c\u9650\u5236\uff08\u8bf7\u53c2\u9605 <code>type-variable-upper-bound</code> \uff09\u548c\u4e0a\u9650\u3002</p> <p>By default, a type variable can be replaced with any type. However, sometimes it's useful to have a type variable that can only have some specific types as its value. A typical example is a type variable that can only have values <code>str</code> and <code>bytes</code>:</p> <pre><code>from typing import TypeVar\n\nAnyStr = TypeVar('AnyStr', str, bytes)\n</code></pre> <p>This is actually such a common type variable that <code>AnyStr</code> is defined in <code>typing</code> and we don't need to define it ourselves.</p> <p>We can use <code>AnyStr</code> to define a function that can concatenate two strings or bytes objects, but it can't be called with other argument types:</p> <pre><code>from typing import AnyStr\n\ndef concat(x: AnyStr, y: AnyStr) -&gt; AnyStr:\n    return x + y\n\nconcat('a', 'b')    # Okay\nconcat(b'a', b'b')  # Okay\nconcat(1, 2)        # Error!\n</code></pre> <p>Importantly, this is different from a union type, since combinations of <code>str</code> and <code>bytes</code> are not accepted:</p> <pre><code>concat('string', b'bytes')   # Error!\n</code></pre> <p>In this case, this is exactly what we want, since it's not possible to concatenate a string and a bytes object! If we tried to use <code>Union</code>, the type checker would complain about this possibility:</p> <pre><code>def union_concat(x: Union[str, bytes], y: Union[str, bytes]) -&gt; Union[str, bytes]:\n    return x + y  # Error: can't concatenate str and bytes\n</code></pre> <p>Another interesting special case is calling <code>concat()</code> with a subtype of <code>str</code>:</p> <pre><code>class S(str): pass\n\nss = concat(S('foo'), S('bar'))\nreveal_type(ss)  # Revealed type is \"builtins.str\"\n</code></pre> <p>You may expect that the type of <code>ss</code> is <code>S</code>, but the type is actually <code>str</code>: a subtype gets promoted to one of the valid values for the type variable, which in this case is <code>str</code>.</p> <p>This is thus subtly different from bounded quantification in languages such as Java, where the return type would be <code>S</code>. The way mypy implements this is correct for <code>concat</code>, since <code>concat</code> actually returns a <code>str</code> instance in the above example:</p> <pre><code>&gt;&gt;&gt; print(type(ss))\n&lt;class 'str'&gt;\n</code></pre> <p>You can also use a <code>TypeVar</code> with a restricted set of possible values when defining a generic class. For example, mypy uses the type <code>Pattern[AnyStr]</code> for the return value of <code>re.compile</code>, since regular expressions can be based on a string or a bytes pattern.</p> <p>A type variable may not have both a value restriction (see <code>type-variable-upper-bound</code>) and an upper bound.</p>"},{"location":"mypy/generics/#\u58f0\u660e\u88c5\u9970\u5668","title":"\u58f0\u660e\u88c5\u9970\u5668","text":"<p>Declaring decorators</p> \u4e2d\u6587\u82f1\u6587 <p>\u88c5\u9970\u5668\u901a\u5e38\u662f\u91c7\u7528\u4e00\u4e2a\u51fd\u6570\u4f5c\u4e3a\u53c2\u6570\u5e76\u8fd4\u56de\u53e6\u4e00\u4e2a\u51fd\u6570\u7684\u51fd\u6570\u3002 \u7528\u7c7b\u578b\u6765\u63cf\u8ff0\u8fd9\u79cd\u884c\u4e3a\u53ef\u80fd\u6709\u70b9\u68d8\u624b\u3002 \u6211\u4eec\u5c06\u5c55\u793a\u5982\u4f55\u4f7f\u7528 \u201cTypeVar\u201d \u548c\u4e00\u79cd\u79f0\u4e3a \u201c\u53c2\u6570\u89c4\u8303\u201d(parameter specification) \u7684\u7279\u6b8a\u7c7b\u578b\u53d8\u91cf\u6765\u6267\u884c\u6b64\u64cd\u4f5c\u3002</p> <p>\u5047\u8bbe\u6211\u4eec\u6709\u4ee5\u4e0b\u88c5\u9970\u5668\uff0c\u5c1a\u672a\u8fdb\u884c\u7c7b\u578b\u6ce8\u91ca\uff0c\u5b83\u4fdd\u7559\u539f\u59cb\u51fd\u6570\u7684\u7b7e\u540d\u5e76\u4ec5\u6253\u5370\u88c5\u9970\u51fd\u6570\u7684\u540d\u79f0\uff1a</p> <pre><code>def printing_decorator(func):\n    def wrapper(*args, **kwds):\n        print(\"Calling\", func)\n        return func(*args, **kwds)\n    return wrapper\n</code></pre> <p>\u6211\u4eec\u7528\u5b83\u6765\u88c5\u9970\u51fd\u6570 <code>add_forty_two</code>\uff1a</p> <pre><code># \u4e00\u4e2a\u88c5\u9970\u51fd\u6570\u3002\n@printing_decorator\ndef add_forty_two(value: int) -&gt; int:\n    return value + 42\n\na = add_forty_two(3)\n</code></pre> <p>\u7531\u4e8e \u201cprinting_decorator\u201d \u6ca1\u6709\u7c7b\u578b\u6ce8\u91ca\uff0c\u56e0\u6b64\u4ee5\u4e0b\u5185\u5bb9\u4e0d\u4f1a\u8fdb\u884c\u7c7b\u578b\u68c0\u67e5\uff1a</p> <pre><code>reveal_type(a)        # Revealed type is \"Any\"\nadd_forty_two('foo')  # \u65e0\u7c7b\u578b\u68c0\u67e5\u5668\u9519\u8bef :(\n</code></pre> <p>\u8fd9\u662f\u4ee4\u4eba\u9057\u61be\u7684\u4e8b\u6001\uff01 \u5982\u679c\u60a8\u4f7f\u7528 \u201c--strict\u201d \u8fd0\u884c\uff0cmypy \u751a\u81f3\u4f1a\u63d0\u9192\u60a8\u4ee5\u4e0b\u4e8b\u5b9e\uff1a\u201c\u65e0\u7c7b\u578b\u88c5\u9970\u5668\u4f7f\u51fd\u6570 \u201cadd_forty_two\u201d \u65e0\u7c7b\u578b</p> <p>\u8bf7\u6ce8\u610f\uff0c\u7c7b\u88c5\u9970\u5668\u7684\u5904\u7406\u65b9\u5f0f\u4e0e mypy \u4e2d\u7684\u51fd\u6570\u88c5\u9970\u5668\u4e0d\u540c\uff1a\u88c5\u9970\u7c7b\u4e0d\u4f1a\u5220\u9664\u5176\u7c7b\u578b\uff0c\u5373\u4f7f\u88c5\u9970\u5668\u5177\u6709\u4e0d\u5b8c\u6574\u7684\u7c7b\u578b\u6ce8\u89e3\u3002</p> <p>\u4ee5\u4e0b\u662f\u6ce8\u89e3\u88c5\u9970\u5668\u7684\u65b9\u6cd5\uff1a</p> <pre><code>from typing import Any, Callable, TypeVar, cast\n\nF = TypeVar('F', bound=Callable[..., Any])\n\n# \u4fdd\u7559\u7b7e\u540d\u7684\u88c5\u9970\u5668\u3002\ndef printing_decorator(func: F) -&gt; F:\n    def wrapper(*args, **kwds):\n        print(\"Calling\", func)\n        return func(*args, **kwds)\n    return cast(F, wrapper)\n\n@printing_decorator\ndef add_forty_two(value: int) -&gt; int:\n    return value + 42\n\na = add_forty_two(3)\nreveal_type(a)      # Revealed type is \"builtins.int\"\nadd_forty_two('x')  # Argument 1 to \"add_forty_two\" has incompatible type \"str\"; expected \"int\"\n</code></pre> <p>\u8fd9\u4ecd\u7136\u5b58\u5728\u4e00\u4e9b\u7f3a\u9677\u3002 \u9996\u5148\uff0c\u6211\u4eec\u9700\u8981\u4f7f\u7528\u4e0d\u5b89\u5168\u7684 <code>cast</code> \u6765\u8bf4\u670d mypy <code>wrapper()</code> \u4e0e <code>func</code> \u5177\u6709\u76f8\u540c\u7684\u7b7e\u540d\u3002 \u8bf7\u53c2\u9605 <code>casts</code>\u3002</p> <p>\u5176\u6b21\uff0c\u201cwrapper()\u201d\u51fd\u6570\u6ca1\u6709\u8fdb\u884c\u4e25\u683c\u7684\u7c7b\u578b\u68c0\u67e5\uff0c\u5c3d\u7ba1\u5305\u88c5\u51fd\u6570\u901a\u5e38\u8db3\u591f\u5c0f\uff0c\u8fd9\u4e0d\u662f\u4e00\u4e2a\u5927\u95ee\u9898\u3002 \u8fd9\u4e5f\u662f\u5728 <code>printing_decorator()</code> \u7684 <code>return</code> \u8bed\u53e5\u4e2d\u8c03\u7528 <code>cast</code> \u7684\u539f\u56e0\u3002</p> <p>\u4f46\u662f\uff0c\u6211\u4eec\u53ef\u4ee5\u4f7f\u7528\u53c2\u6570\u89c4\u8303\uff08<code>ParamSpec</code>\uff09\u6765\u83b7\u5f97\u66f4\u5fe0\u5b9e\u7684\u7c7b\u578b\u6ce8\u91ca\uff1a</p> <pre><code>from typing import Callable, TypeVar\nfrom typing_extensions import ParamSpec\n\nP = ParamSpec('P')\nT = TypeVar('T')\n\ndef printing_decorator(func: Callable[P, T]) -&gt; Callable[P, T]:\n    def wrapper(*args: P.args, **kwds: P.kwargs) -&gt; T:\n        print(\"Calling\", func)\n        return func(*args, **kwds)\n    return wrapper\n</code></pre> <p>\u53c2\u6570\u89c4\u8303\u8fd8\u5141\u8bb8\u60a8\u63cf\u8ff0\u6539\u53d8\u8f93\u5165\u51fd\u6570\u7b7e\u540d\u7684\u88c5\u9970\u5668\uff1a</p> <pre><code>from typing import Callable, TypeVar\nfrom typing_extensions import ParamSpec\n\nP = ParamSpec('P')\nT = TypeVar('T')\n\n# \u6211\u4eec\u5728\u8fd4\u56de\u7c7b\u578b\u4e2d\u91cd\u7528\u201cP\u201d\uff0c\u4f46\u5c06\u201cT\u201d\u66ff\u6362\u4e3a\u201cstr\u201d\ndef stringify(func: Callable[P, T]) -&gt; Callable[P, str]:\n    def wrapper(*args: P.args, **kwds: P.kwargs) -&gt; str:\n        return str(func(*args, **kwds))\n    return wrapper\n\n@stringify\ndef add_forty_two(value: int) -&gt; int:\n    return value + 42\n\na = add_forty_two(3)\nreveal_type(a)      # Revealed type is \"builtins.str\"\nadd_forty_two('x')  # error: Argument 1 to \"add_forty_two\" has incompatible type \"str\"; expected \"int\"\n</code></pre> <p>\u6216\u8005\u63d2\u5165\u4e00\u4e2a\u53c2\u6570\uff1a</p> <pre><code>from typing import Callable, TypeVar\nfrom typing_extensions import Concatenate, ParamSpec\n\nP = ParamSpec('P')\nT = TypeVar('T')\n\ndef printing_decorator(func: Callable[P, T]) -&gt; Callable[Concatenate[str, P], T]:\n    def wrapper(msg: str, /, *args: P.args, **kwds: P.kwargs) -&gt; T:\n        print(\"Calling\", func, \"with\", msg)\n        return func(*args, **kwds)\n    return wrapper\n\n@printing_decorator\ndef add_forty_two(value: int) -&gt; int:\n    return value + 42\n\na = add_forty_two('three', 3)\n</code></pre> <p>Decorators are typically functions that take a function as an argument and return another function. Describing this behaviour in terms of types can be a little tricky; we'll show how you can use <code>TypeVar</code> and a special kind of type variable called a parameter specification to do so.</p> <p>Suppose we have the following decorator, not type annotated yet, that preserves the original function's signature and merely prints the decorate function's name:</p> <pre><code>def printing_decorator(func):\n    def wrapper(*args, **kwds):\n        print(\"Calling\", func)\n        return func(*args, **kwds)\n    return wrapper\n</code></pre> <p>and we use it to decorate function <code>add_forty_two</code>:</p> <pre><code># A decorated function.\n@printing_decorator\ndef add_forty_two(value: int) -&gt; int:\n    return value + 42\n\na = add_forty_two(3)\n</code></pre> <p>Since <code>printing_decorator</code> is not type-annotated, the following won't get type checked:</p> <pre><code>reveal_type(a)        # Revealed type is \"Any\"\nadd_forty_two('foo')  # No type checker error :(\n</code></pre> <p>This is a sorry state of affairs! If you run with <code>--strict</code>, mypy will even alert you to this fact: <code>Untyped decorator makes function \"add_forty_two\" untyped</code></p> <p>Note that class decorators are handled differently than function decorators in mypy: decorating a class does not erase its type, even if the decorator has incomplete type annotations.</p> <p>Here's how one could annotate the decorator:</p> <pre><code>from typing import Any, Callable, TypeVar, cast\n\nF = TypeVar('F', bound=Callable[..., Any])\n\n# A decorator that preserves the signature.\ndef printing_decorator(func: F) -&gt; F:\n    def wrapper(*args, **kwds):\n        print(\"Calling\", func)\n        return func(*args, **kwds)\n    return cast(F, wrapper)\n\n@printing_decorator\ndef add_forty_two(value: int) -&gt; int:\n    return value + 42\n\na = add_forty_two(3)\nreveal_type(a)      # Revealed type is \"builtins.int\"\nadd_forty_two('x')  # Argument 1 to \"add_forty_two\" has incompatible type \"str\"; expected \"int\"\n</code></pre> <p>This still has some shortcomings. First, we need to use the unsafe <code>cast</code> to convince mypy that <code>wrapper()</code> has the same signature as <code>func</code>. See <code>casts</code>.</p> <p>Second, the <code>wrapper()</code> function is not tightly type checked, although wrapper functions are typically small enough that this is not a big problem. This is also the reason for the <code>cast</code> call in the <code>return</code> statement in <code>printing_decorator()</code>.</p> <p>However, we can use a parameter specification (<code>ParamSpec</code>), for a more faithful type annotation:</p> <pre><code>from typing import Callable, TypeVar\nfrom typing_extensions import ParamSpec\n\nP = ParamSpec('P')\nT = TypeVar('T')\n\ndef printing_decorator(func: Callable[P, T]) -&gt; Callable[P, T]:\n    def wrapper(*args: P.args, **kwds: P.kwargs) -&gt; T:\n        print(\"Calling\", func)\n        return func(*args, **kwds)\n    return wrapper\n</code></pre> <p>Parameter specifications also allow you to describe decorators that alter the signature of the input function:</p> <pre><code>from typing import Callable, TypeVar\nfrom typing_extensions import ParamSpec\n\nP = ParamSpec('P')\nT = TypeVar('T')\n\n# We reuse 'P' in the return type, but replace 'T' with 'str'\ndef stringify(func: Callable[P, T]) -&gt; Callable[P, str]:\n    def wrapper(*args: P.args, **kwds: P.kwargs) -&gt; str:\n        return str(func(*args, **kwds))\n    return wrapper\n\n@stringify\ndef add_forty_two(value: int) -&gt; int:\n    return value + 42\n\na = add_forty_two(3)\nreveal_type(a)      # Revealed type is \"builtins.str\"\nadd_forty_two('x')  # error: Argument 1 to \"add_forty_two\" has incompatible type \"str\"; expected \"int\"\n</code></pre> <p>Or insert an argument:</p> <pre><code>from typing import Callable, TypeVar\nfrom typing_extensions import Concatenate, ParamSpec\n\nP = ParamSpec('P')\nT = TypeVar('T')\n\ndef printing_decorator(func: Callable[P, T]) -&gt; Callable[Concatenate[str, P], T]:\n    def wrapper(msg: str, /, *args: P.args, **kwds: P.kwargs) -&gt; T:\n        print(\"Calling\", func, \"with\", msg)\n        return func(*args, **kwds)\n    return wrapper\n\n@printing_decorator\ndef add_forty_two(value: int) -&gt; int:\n    return value + 42\n\na = add_forty_two('three', 3)\n</code></pre>"},{"location":"mypy/generics/#\u88c5\u9970\u5668\u5de5\u5382","title":"\u88c5\u9970\u5668\u5de5\u5382","text":"<p>Decorator factories</p> \u4e2d\u6587\u82f1\u6587 <p>\u63a5\u53d7\u53c2\u6570\u5e76\u8fd4\u56de\u88c5\u9970\u5668\uff08\u4e5f\u79f0\u4e3a\u4e8c\u9636\u88c5\u9970\u5668\uff09\u7684\u51fd\u6570\u540c\u6837\u901a\u8fc7\u6cdb\u578b\u83b7\u5f97\u652f\u6301\uff1a</p> <pre><code>from typing import Any, Callable, TypeVar\n\nF = TypeVar('F', bound=Callable[..., Any])\n\ndef route(url: str) -&gt; Callable[[F], F]:\n    ...\n\n@route(url='/')\ndef index(request: Any) -&gt; str:\n    return 'Hello world'\n</code></pre> <p>\u6709\u65f6\uff0c\u540c\u4e00\u4e2a\u88c5\u9970\u5668\u540c\u65f6\u652f\u6301\u88f8\u8c03\u7528\u548c\u5e26\u53c2\u6570\u7684\u8c03\u7528\u3002 \u8fd9\u53ef\u4ee5\u901a\u8fc7\u4e0e <code>@overload</code> \u7ed3\u5408\u6765\u5b9e\u73b0\uff1a</p> <pre><code>from typing import Any, Callable, Optional, TypeVar, overload\n\nF = TypeVar('F', bound=Callable[..., Any])\n\n# \u88f8\u88c5\u9970\u5668\u7684\u4f7f\u7528\n@overload\ndef atomic(__func: F) -&gt; F: ...\n# \u5e26\u53c2\u6570\u7684\u88c5\u9970\u5668\n@overload\ndef atomic(*, savepoint: bool = True) -&gt; Callable[[F], F]: ...\n\n# \u5b9e\u73b0\ndef atomic(__func: Optional[Callable[..., Any]] = None, *, savepoint: bool = True):\n    def decorator(func: Callable[..., Any]):\n        ...  # \u4ee3\u7801\u653e\u5728\u8fd9\u91cc\n    if __func is not None:\n        return decorator(__func)\n    else:\n        return decorator\n\n# \u7528\u6cd5\n@atomic\ndef func1() -&gt; None: ...\n\n@atomic(savepoint=False)\ndef func2() -&gt; None: ...\n</code></pre> <p>Functions that take arguments and return a decorator (also called second-order decorators), are similarly supported via generics:</p> <pre><code>from typing import Any, Callable, TypeVar\n\nF = TypeVar('F', bound=Callable[..., Any])\n\ndef route(url: str) -&gt; Callable[[F], F]:\n    ...\n\n@route(url='/')\ndef index(request: Any) -&gt; str:\n    return 'Hello world'\n</code></pre> <p>Sometimes the same decorator supports both bare calls and calls with arguments. This can be achieved by combining with <code>@overload</code>:</p> <pre><code>from typing import Any, Callable, Optional, TypeVar, overload\n\nF = TypeVar('F', bound=Callable[..., Any])\n\n# Bare decorator usage\n@overload\ndef atomic(__func: F) -&gt; F: ...\n# Decorator with arguments\n@overload\ndef atomic(*, savepoint: bool = True) -&gt; Callable[[F], F]: ...\n\n# Implementation\ndef atomic(__func: Optional[Callable[..., Any]] = None, *, savepoint: bool = True):\n    def decorator(func: Callable[..., Any]):\n        ...  # Code goes here\n    if __func is not None:\n        return decorator(__func)\n    else:\n        return decorator\n\n# Usage\n@atomic\ndef func1() -&gt; None: ...\n\n@atomic(savepoint=False)\ndef func2() -&gt; None: ...\n</code></pre>"},{"location":"mypy/generics/#\u6cdb\u578b\u534f\u8bae","title":"\u6cdb\u578b\u534f\u8bae","text":"<p>Generic protocols</p> \u4e2d\u6587\u82f1\u6587 <p>Mypy \u652f\u6301\u901a\u7528\u534f\u8bae\uff08\u53e6\u8bf7\u53c2\u9605 <code>protocol-types</code>\uff09\u3002 \u4e00\u4e9b<code>\u9884\u5b9a\u4e49\u534f\u8bae</code>\u662f\u901a\u7528\u7684\uff0c\u4f8b\u5982<code>Iterable[T]</code>\uff0c\u5e76\u4e14\u60a8\u53ef\u4ee5\u5b9a\u4e49\u5176\u4ed6\u901a\u7528\u534f\u8bae\u3002 \u6cdb\u578b\u534f\u8bae\u5927\u591a\u9075\u5faa\u6cdb\u578b\u7c7b\u7684\u6b63\u5e38\u89c4\u5219\u3002 \u4f8b\u5b50\uff1a</p> <pre><code>from typing import TypeVar\nfrom typing_extensions import Protocol\n\nT = TypeVar('T')\n\nclass Box(Protocol[T]):\n    content: T\n\ndef do_stuff(one: Box[str], other: Box[bytes]) -&gt; None:\n    ...\n\nclass StringWrapper:\n    def __init__(self, content: str) -&gt; None:\n        self.content = content\n\nclass BytesWrapper:\n    def __init__(self, content: bytes) -&gt; None:\n        self.content = content\n\ndo_stuff(StringWrapper('one'), BytesWrapper(b'other'))  # OK\n\nx: Box[float] = ...\ny: Box[int] = ...\nx = y  # Error -- Box is invariant\n</code></pre> <p>\u8bf7\u6ce8\u610f\uff0c\u6839\u636e <code>PEP 544\uff1a\u6cdb\u578b\u534f\u8bae</code>\uff0c\u5141\u8bb8\u4f7f\u7528 <code>class ClassName(Protocol[T])</code> \u4f5c\u4e3a <code>class ClassName(Protocol, Generic[T])</code> \u7684\u7b80\u5199\uff0c</p> <p>\u6cdb\u578b\u534f\u8bae\u548c\u666e\u901a\u6cdb\u578b\u7c7b\u4e4b\u95f4\u7684\u4e3b\u8981\u533a\u522b\u5728\u4e8e\uff0cmypy \u68c0\u67e5\u534f\u8bae\u4e2d\u6cdb\u578b\u7c7b\u578b\u53d8\u91cf\u7684\u58f0\u660e\u5dee\u5f02\u662f\u5426\u4e0e\u5b83\u4eec\u5728\u534f\u8bae\u5b9a\u4e49\u4e2d\u7684\u4f7f\u7528\u65b9\u5f0f\u76f8\u5339\u914d\u3002 \u6b64\u793a\u4f8b\u4e2d\u7684\u534f\u8bae\u88ab\u62d2\u7edd\uff0c\u56e0\u4e3a\u7c7b\u578b\u53d8\u91cf\u201cT\u201d\u88ab\u534f\u53d8\u5730\u7528\u4f5c\u8fd4\u56de\u7c7b\u578b\uff0c\u4f46\u7c7b\u578b\u53d8\u91cf\u662f\u4e0d\u53d8\u7684\uff1a</p> <pre><code>from typing import Protocol, TypeVar\n\nT = TypeVar('T')\n\nclass ReadOnlyBox(Protocol[T]):  # error: \u5728\u9700\u8981\u534f\u53d8\u7684\u534f\u8bae\u4e2d\u4f7f\u7528\u4e0d\u53d8\u7c7b\u578b\u53d8\u91cf\u201cT\u201d\n    def content(self) -&gt; T: ...\n</code></pre> <p>\u6b64\u793a\u4f8b\u6b63\u786e\u4f7f\u7528\u534f\u53d8\u7c7b\u578b\u53d8\u91cf\uff1a</p> <pre><code>from typing import Protocol, TypeVar\n\nT_co = TypeVar('T_co', covariant=True)\n\nclass ReadOnlyBox(Protocol[T_co]):  # OK\n    def content(self) -&gt; T_co: ...\n\nax: ReadOnlyBox[float] = ...\nay: ReadOnlyBox[int] = ...\nax = ay  # OK -- ReadOnlyBox is covariant\n</code></pre> <p>\u6709\u5173\u53d8\u4f53\u7684\u66f4\u591a\u4fe1\u606f\uff0c\u8bf7\u53c2\u9605<code>\u6cdb\u578b\u53d8\u4f53</code>\u3002</p> <p>\u6cdb\u578b\u534f\u8bae\u4e5f\u53ef\u4ee5\u662f\u9012\u5f52\u7684\u3002 \u4f8b\u5b50\uff1a</p> <pre><code>T = TypeVar('T')\n\nclass Linked(Protocol[T]):\n    val: T\n    def next(self) -&gt; 'Linked[T]': ...\n\nclass L:\n    val: int\n    def next(self) -&gt; 'L': ...\n\ndef last(seq: Linked[T]) -&gt; T: ...\n\nresult = last(L())\nreveal_type(result)  # Revealed type is \"builtins.int\"\n</code></pre> <p>Mypy supports generic protocols (see also <code>protocol-types</code>). Several <code>predefined protocols</code> are generic, such as <code>Iterable[T]</code>, and you can define additional generi protocols. Generic protocols mostly follow the normal rules for generic classes. Example:</p> <pre><code>from typing import TypeVar\nfrom typing_extensions import Protocol\n\nT = TypeVar('T')\n\nclass Box(Protocol[T]):\n    content: T\n\ndef do_stuff(one: Box[str], other: Box[bytes]) -&gt; None:\n    ...\n\nclass StringWrapper:\n    def __init__(self, content: str) -&gt; None:\n        self.content = content\n\nclass BytesWrapper:\n    def __init__(self, content: bytes) -&gt; None:\n        self.content = content\n\ndo_stuff(StringWrapper('one'), BytesWrapper(b'other'))  # OK\n\nx: Box[float] = ...\ny: Box[int] = ...\nx = y  # Error -- Box is invariant\n</code></pre> <p>Note that <code>class ClassName(Protocol[T])</code> is allowed as a shorthand for <code>class ClassName(Protocol, Generic[T])</code>, as per <code>PEP 544: Generic protocols</code>,</p> <p>The main difference between generic protocols and ordinary generic classes is that mypy checks that the declared variances of generic type variables in a protocol match how they are used in the protocol definition.  The protocol in this example is rejected, since the type variable <code>T</code> is used covariantly as a return type, but the type variable is invariant:</p> <pre><code>from typing import Protocol, TypeVar\n\nT = TypeVar('T')\n\nclass ReadOnlyBox(Protocol[T]):  # error: Invariant type variable \"T\" used in protocol where covariant one is expected\n    def content(self) -&gt; T: ...\n</code></pre> <p>This example correctly uses a covariant type variable:</p> <pre><code>from typing import Protocol, TypeVar\n\nT_co = TypeVar('T_co', covariant=True)\n\nclass ReadOnlyBox(Protocol[T_co]):  # OK\n    def content(self) -&gt; T_co: ...\n\nax: ReadOnlyBox[float] = ...\nay: ReadOnlyBox[int] = ...\nax = ay  # OK -- ReadOnlyBox is covariant\n</code></pre> <p>See <code>variance-of-generics</code> for more about variance.</p> <p>Generic protocols can also be recursive. Example:</p> <pre><code>T = TypeVar('T')\n\nclass Linked(Protocol[T]):\n    val: T\n    def next(self) -&gt; 'Linked[T]': ...\n\nclass L:\n    val: int\n    def next(self) -&gt; 'L': ...\n\ndef last(seq: Linked[T]) -&gt; T: ...\n\nresult = last(L())\nreveal_type(result)  # Revealed type is \"builtins.int\"\n</code></pre>"},{"location":"mypy/generics/#\u6cdb\u578b\u7c7b\u578b\u522b\u540d","title":"\u6cdb\u578b\u7c7b\u578b\u522b\u540d","text":"<p>Generic type aliases</p> \u4e2d\u6587\u82f1\u6587 <p>\u7c7b\u578b\u522b\u540d\u53ef\u4ee5\u662f\u6cdb\u578b\u7684\u3002 \u5728\u8fd9\u79cd\u60c5\u51b5\u4e0b\uff0c\u5b83\u4eec\u53ef\u4ee5\u901a\u8fc7\u4e24\u79cd\u65b9\u5f0f\u4f7f\u7528\uff1a \u5e26\u4e0b\u6807\u7684\u522b\u540d\u76f8\u5f53\u4e8e\u5e26\u6709\u66ff\u6362\u7c7b\u578b\u53d8\u91cf\u7684\u539f\u59cb\u7c7b\u578b\uff0c\u56e0\u6b64\u7c7b\u578b\u53c2\u6570\u7684\u6570\u91cf\u5fc5\u987b\u4e0e\u6cdb\u578b\u7c7b\u578b\u522b\u540d\u4e2d\u81ea\u7531\u7c7b\u578b\u53d8\u91cf\u7684\u6570\u91cf\u76f8\u5339\u914d\u3002 \u65e0\u4e0b\u6807\u7684\u522b\u540d\u88ab\u89c6\u4e3a\u539f\u59cb\u7c7b\u578b\uff0c\u81ea\u7531\u53d8\u91cf\u66ff\u6362\u4e3a\u201cAny\u201d\u3002 \u793a\u4f8b\uff08\u9075\u5faa <code>PEP 484\uff1a\u7c7b\u578b\u522b\u540d</code>\uff09\uff1a</p> <pre><code>from typing import TypeVar, Iterable, Union, Callable\n\nS = TypeVar('S')\n\nTInt = tuple[int, S]\nUInt = Union[S, int]\nCBack = Callable[..., S]\n\ndef response(query: str) -&gt; UInt[str]:  # Same as Union[str, int]\n    ...\ndef activate(cb: CBack[S]) -&gt; S:        # Same as Callable[..., S]\n    ...\ntable_entry: TInt  # Same as tuple[int, Any]\n\nT = TypeVar('T', int, float, complex)\n\nVec = Iterable[tuple[T, T]]\n\ndef inproduct(v: Vec[T]) -&gt; T:\n    return sum(x*y for x, y in v)\n\ndef dilate(v: Vec[T], scale: T) -&gt; Vec[T]:\n    return ((x * scale, y * scale) for x, y in v)\n\nv1: Vec[int] = []      # Same as Iterable[tuple[int, int]]\nv2: Vec = []           # Same as Iterable[tuple[Any, Any]]\nv3: Vec[int, int] = [] # Error: Invalid alias, too many type arguments!\n</code></pre> <p>\u7c7b\u578b\u522b\u540d\u53ef\u4ee5\u50cf\u5176\u4ed6\u540d\u79f0\u4e00\u6837\u4ece\u6a21\u5757\u5bfc\u5165\u3002 \u4e00\u4e2a\u522b\u540d\u4e5f\u53ef\u4ee5\u9488\u5bf9\u53e6\u4e00\u4e2a\u522b\u540d\uff0c\u5c3d\u7ba1\u4e0d\u5efa\u8bae\u6784\u5efa\u590d\u6742\u7684\u522b\u540d\u94fe\u2014\u2014\u8fd9\u4f1a\u59a8\u788d\u4ee3\u7801\u7684\u53ef\u8bfb\u6027\uff0c\u4ece\u800c\u8fdd\u80cc\u4e86\u4f7f\u7528\u522b\u540d\u7684\u76ee\u7684\u3002 \u4f8b\u5b50\uff1a</p> <pre><code>from typing import TypeVar, Generic, Optional\nfrom example1 import AliasType\nfrom example2 import Vec\n\n# AliasType and Vec are type aliases (Vec as defined above)\n\ndef fun() -&gt; AliasType:\n    ...\n\nT = TypeVar('T')\n\nclass NewVec(Vec[T]):\n    ...\n\nfor i, j in NewVec[int]():\n    ...\n\nOIntVec = Optional[Vec[int]]\n</code></pre> <p>Using type variable bounds or values in generic aliases has the same effect as in generic classes/functions.</p> <p>\u5728\u6cdb\u578b\u7c7b/\u51fd\u6570\u4e2d\u4f7f\u7528\u7684\u6cdb\u578b\u522b\u540d\u4e2d\u4f7f\u7528\u7c7b\u578b\u53d8\u91cf\u7ed1\u5b9a\u6216\u503c\u4e0e\u5177\u6709\u76f8\u540c\u7684\u6548\u679c\u3002</p> <p>Type aliases can be generic. In this case they can be used in two ways: Subscripted aliases are equivalent to original types with substituted type variables, so the number of type arguments must match the number of free type variables in the generic type alias. Unsubscripted aliases are treated as original types with free variables replaced with <code>Any</code>. Examples (following <code>PEP 484: Type aliases</code>):</p> <pre><code>from typing import TypeVar, Iterable, Union, Callable\n\nS = TypeVar('S')\n\nTInt = tuple[int, S]\nUInt = Union[S, int]\nCBack = Callable[..., S]\n\ndef response(query: str) -&gt; UInt[str]:  # Same as Union[str, int]\n    ...\ndef activate(cb: CBack[S]) -&gt; S:        # Same as Callable[..., S]\n    ...\ntable_entry: TInt  # Same as tuple[int, Any]\n\nT = TypeVar('T', int, float, complex)\n\nVec = Iterable[tuple[T, T]]\n\ndef inproduct(v: Vec[T]) -&gt; T:\n    return sum(x*y for x, y in v)\n\ndef dilate(v: Vec[T], scale: T) -&gt; Vec[T]:\n    return ((x * scale, y * scale) for x, y in v)\n\nv1: Vec[int] = []      # Same as Iterable[tuple[int, int]]\nv2: Vec = []           # Same as Iterable[tuple[Any, Any]]\nv3: Vec[int, int] = [] # Error: Invalid alias, too many type arguments!\n</code></pre> <p>Type aliases can be imported from modules just like other names. An alias can also target another alias, although building complex chains of aliases is not recommended -- this impedes code readability, thus defeating the purpose of using aliases.  Example:</p> <pre><code>from typing import TypeVar, Generic, Optional\nfrom example1 import AliasType\nfrom example2 import Vec\n\n# AliasType and Vec are type aliases (Vec as defined above)\n\ndef fun() -&gt; AliasType:\n    ...\n\nT = TypeVar('T')\n\nclass NewVec(Vec[T]):\n    ...\n\nfor i, j in NewVec[int]():\n    ...\n\nOIntVec = Optional[Vec[int]]\n</code></pre> <p>Using type variable bounds or values in generic aliases has the same effect as in generic classes/functions.</p>"},{"location":"mypy/generics/#\u6cdb\u578b\u7c7b\u5185\u90e8\u7ed3\u6784","title":"\u6cdb\u578b\u7c7b\u5185\u90e8\u7ed3\u6784","text":"<p>Generic class internals</p> \u4e2d\u6587\u82f1\u6587 <p>\u60a8\u53ef\u80fd\u60f3\u77e5\u9053\u5f53\u60a8\u7d22\u5f15\u6cdb\u578b\u7c7b\u65f6\u5728\u8fd0\u884c\u65f6\u4f1a\u53d1\u751f\u4ec0\u4e48\u3002 \u7d22\u5f15\u5411\u539f\u59cb\u7c7b\u8fd4\u56de\u4e00\u4e2a\u6cdb\u578b\u522b\u540d\uff0c\u8be5\u522b\u540d\u5728\u5b9e\u4f8b\u5316\u65f6\u8fd4\u56de\u539f\u59cb\u7c7b\u7684\u5b9e\u4f8b\uff1a</p> <pre><code>&gt;&gt;&gt; from typing import TypeVar, Generic\n&gt;&gt;&gt; T = TypeVar('T')\n&gt;&gt;&gt; class Stack(Generic[T]): ...\n&gt;&gt;&gt; Stack\n__main__.Stack\n&gt;&gt;&gt; Stack[int]\n__main__.Stack[int]\n&gt;&gt;&gt; instance = Stack[int]()\n&gt;&gt;&gt; instance.__class__\n__main__.Stack\n</code></pre> <p>\u6cdb\u578b\u522b\u540d\u53ef\u4ee5\u88ab\u5b9e\u4f8b\u5316\u6216\u5b50\u7c7b\u5316\uff0c\u7c7b\u4f3c\u4e8e\u771f\u5b9e\u7684\u7c7b\uff0c\u4f46\u4e0a\u9762\u7684\u793a\u4f8b\u8bf4\u660e\u7c7b\u578b\u53d8\u91cf\u5728\u8fd0\u884c\u65f6\u88ab\u5220\u9664\u3002 \u6cdb\u578b \u201cStack\u201d \u5b9e\u4f8b\u53ea\u662f\u666e\u901a\u7684 Python \u5bf9\u8c61\uff0c\u9664\u4e86\u91cd\u8f7d\u7d22\u5f15\u8fd0\u7b97\u7b26\u7684\u5143\u7c7b\u4e4b\u5916\uff0c\u5b83\u4eec\u6ca1\u6709\u989d\u5916\u7684\u8fd0\u884c\u65f6\u5f00\u9500\u6216\u9b54\u529b\uff0c\u56e0\u4e3a\u5b83\u4eec\u662f\u6cdb\u578b\u7684\u3002</p> <p>\u8bf7\u6ce8\u610f\uff0c\u5728 Python 3.8 \u53ca\u66f4\u4f4e\u7248\u672c\u4e2d\uff0c\u5185\u7f6e\u7c7b\u578b <code>list</code>\u3001<code>dict</code> \u548c\u5176\u4ed6\u4e0d\u652f\u6301\u7d22\u5f15\u3002 \u8fd9\u5c31\u662f\u4e3a\u4ec0\u4e48\u6211\u4eec\u6709\u522b\u540d <code>List</code>\u3001<code>Dict</code> \u7b49\u5728 <code>typing</code> \u6a21\u5757\u4e2d\u3002 \u5bf9\u8fd9\u4e9b\u522b\u540d\u8fdb\u884c\u7d22\u5f15\u4f1a\u4e3a\u60a8\u63d0\u4f9b\u4e00\u4e2a\u6cdb\u578b\u522b\u540d\uff0c\u8be5\u522b\u540d\u7c7b\u4f3c\u4e8e\u901a\u8fc7\u5728\u8f83\u65b0\u7248\u672c\u7684 Python \u4e2d\u76f4\u63a5\u5bf9\u76ee\u6807\u7c7b\u5efa\u7acb\u7d22\u5f15\u800c\u6784\u9020\u7684\u6cdb\u578b\u522b\u540d\uff1a</p> <pre><code>&gt;&gt;&gt; # \u4ec5\u4e0e Python 3.8 \u53ca\u66f4\u4f4e\u7248\u672c\u76f8\u5173\n&gt;&gt;&gt; # \u5bf9\u4e8e Python 3.9 \u53ca\u4ee5\u4e0a\u7248\u672c\uff0c\u66f4\u559c\u6b22 `list[int]` \u8bed\u6cd5\n&gt;&gt;&gt; from typing import List\n&gt;&gt;&gt; List[int]\ntyping.List[int]\n</code></pre> <p>\u8bf7\u6ce8\u610f\uff0c\u201ctyping\u201d \u4e2d\u7684\u901a\u7528\u522b\u540d\u4e0d\u652f\u6301\u6784\u9020\u5b9e\u4f8b\uff1a</p> <pre><code>&gt;&gt;&gt; from typing import List\n&gt;&gt;&gt; List[int]()\nTraceback (most recent call last):\n...\nTypeError: Type List cannot be instantiated; use list() instead\n</code></pre> <p>You may wonder what happens at runtime when you index a generic class. Indexing returns a generic alias to the original class that returns instances of the original class on instantiation:</p> <pre><code>&gt;&gt;&gt; from typing import TypeVar, Generic\n&gt;&gt;&gt; T = TypeVar('T')\n&gt;&gt;&gt; class Stack(Generic[T]): ...\n&gt;&gt;&gt; Stack\n__main__.Stack\n&gt;&gt;&gt; Stack[int]\n__main__.Stack[int]\n&gt;&gt;&gt; instance = Stack[int]()\n&gt;&gt;&gt; instance.__class__\n__main__.Stack\n</code></pre> <p>Generic aliases can be instantiated or subclassed, similar to real classes, but the above examples illustrate that type variables are erased at runtime. Generic <code>Stack</code> instances are just ordinary Python objects, and they have no extra runtime overhead or magic due to being generic, other than a metaclass that overloads the indexing operator.</p> <p>Note that in Python 3.8 and lower, the built-in types <code>list</code>, <code>dict</code> and others do not support indexing. This is why we have the aliases <code>List</code>, <code>Dict</code> and so on in the <code>typing</code> module. Indexing these aliases gives you a generic alias that resembles generic aliases constructed by directly indexing the target class in more recent versions of Python:</p> <pre><code>&gt;&gt;&gt; # Only relevant for Python 3.8 and below\n&gt;&gt;&gt; # For Python 3.9 onwards, prefer `list[int]` syntax\n&gt;&gt;&gt; from typing import List\n&gt;&gt;&gt; List[int]\ntyping.List[int]\n</code></pre> <p>Note that the generic aliases in <code>typing</code> don't support constructing instances:</p> <pre><code>&gt;&gt;&gt; from typing import List\n&gt;&gt;&gt; List[int]()\nTraceback (most recent call last):\n...\nTypeError: Type List cannot be instantiated; use list() instead\n</code></pre>"},{"location":"mypy/kind_of_types/","title":"\u7c7b\u578b\u5206\u7c7b","text":"\u4e2d\u6587\u82f1\u6587 <p>\u5230\u76ee\u524d\u4e3a\u6b62\uff0c\u6211\u4eec\u4e3b\u8981\u5c40\u9650\u4e8e\u5185\u7f6e\u7c7b\u578b\u3002 \u672c\u8282\u4ecb\u7ecd\u51e0\u79cd\u5176\u4ed6\u7c7b\u578b\u3002 \u60a8\u53ef\u80fd\u81f3\u5c11\u9700\u8981\u5176\u4e2d\u4e00\u4e9b\u6765\u5bf9\u4efb\u4f55\u91cd\u8981\u7684\u7a0b\u5e8f\u8fdb\u884c\u7c7b\u578b\u68c0\u67e5\u3002</p> <p>Kinds of types</p> <p>We've mostly restricted ourselves to built-in types until now. This section introduces several additional kinds of types. You are likely to need at least some of them to type check any non-trivial programs.</p>"},{"location":"mypy/kind_of_types/#class\u7684\u7c7b\u578b","title":"Class\u7684\u7c7b\u578b","text":"\u4e2d\u6587\u82f1\u6587 <p>\u6bcf\u4e2a\u7c7b\u90fd\u662f\u6709\u6548\u7684\u7c7b\u578b\u3002 \u5b50\u7c7b\u7684\u4efb\u4f55\u5b9e\u4f8b\u4e5f\u4e0e\u6240\u6709\u8d85\u7c7b\u517c\u5bb9 - \u56e0\u6b64\u6bcf\u4e2a\u503c\u90fd\u4e0e <code>object</code> \u7c7b\u578b\u517c\u5bb9(\u987a\u4fbf\u8bf4\u4e00\u53e5\uff0c\u8fd8\u6709 <code>Any</code> \u7c7b\u578b\uff0c\u5982\u4e0b\u6240\u8ff0)\u3002 Mypy \u5206\u6790\u7c7b\u7684\u4e3b\u4f53\u4ee5\u786e\u5b9a\u5b9e\u4f8b\u4e2d\u53ef\u7528\u7684\u65b9\u6cd5\u548c\u5c5e\u6027\u3002 \u6b64\u793a\u4f8b\u4f7f\u7528\u5b50\u7c7b\u5316\uff1a</p> <pre><code>class A:\n    def f(self) -&gt; int:  # Type of self inferred (A)\n        return 2\n\nclass B(A):\n    def f(self) -&gt; int:\n         return 3\n    def g(self) -&gt; int:\n        return 4\n\ndef foo(a: A) -&gt; None:\n    print(a.f())  # 3\n    a.g()         # Error: \"A\" has no attribute \"g\"\n\nfoo(B())  # OK (B is a subclass of A)\n</code></pre> <p>Class types</p> <p>Every class is also a valid type. Any instance of a subclass is also compatible with all superclasses -- it follows that every value is compatible with the <code>object</code> type (and incidentally also the <code>Any</code> type, discussed below). Mypy analyzes the bodies of classes to determine which methods and attributes are available in instances. This example uses subclassing:</p> <pre><code>class A:\n    def f(self) -&gt; int:  # Type of self inferred (A)\n        return 2\n\nclass B(A):\n    def f(self) -&gt; int:\n         return 3\n    def g(self) -&gt; int:\n        return 4\n\ndef foo(a: A) -&gt; None:\n    print(a.f())  # 3\n    a.g()         # Error: \"A\" has no attribute \"g\"\n\nfoo(B())  # OK (B is a subclass of A)\n</code></pre>"},{"location":"mypy/kind_of_types/#any-\u7c7b\u578b","title":"Any \u7c7b\u578b","text":"\u4e2d\u6587\u82f1\u6587 <p>A value with the <code>Any</code> type is dynamically typed. Mypy doesn't know anything about the possible runtime types of such value. Any operations are permitted on the value, and the operations are only checked at runtime. You can use <code>Any</code> as an \"escape hatch\" when you can't use a more precise type for some reason.</p> <p><code>Any</code> is compatible with every other type, and vice versa. You can freely assign a value of type <code>Any</code> to a variable with a more precise type:</p> <pre><code>a: Any = None\ns: str = ''\na = 2     # OK (assign \"int\" to \"Any\")\ns = a     # OK (assign \"Any\" to \"str\")\n</code></pre> <p>Declared (and inferred) types are ignored (or erased) at runtime. They are basically treated as comments, and thus the above code does not generate a runtime error, even though <code>s</code> gets an <code>int</code> value when the program is run, while the declared type of <code>s</code> is actually <code>str</code>! You need to be careful with <code>Any</code> types, since they let you lie to mypy, and this could easily hide bugs.</p> <p>If you do not define a function return value or argument types, these default to <code>Any</code>:</p> <pre><code>def show_heading(s) -&gt; None:\n    print('=== ' + s + ' ===')  # No static type checking, as s has type Any\n\nshow_heading(1)  # OK (runtime error only; mypy won't generate an error)\n</code></pre> <p>You should give a statically typed function an explicit <code>None</code> return type even if it doesn't return a value, as this lets mypy catch additional type errors:</p> <pre><code>def wait(t: float):  # Implicit Any return value\n    print('Waiting...')\n    time.sleep(t)\n\nif wait(2) &gt; 1:   # Mypy doesn't catch this error!\n    ...\n</code></pre> <p>If we had used an explicit <code>None</code> return type, mypy would have caught the error:</p> <pre><code>def wait(t: float) -&gt; None:\n    print('Waiting...')\n    time.sleep(t)\n\nif wait(2) &gt; 1:   # Error: can't compare None and int\n    ...\n</code></pre> <p>The <code>Any</code> type is discussed in more detail in section <code>dynamic-typing</code>.</p> <p>Note</p> <p>A function without any types in the signature is dynamically typed. The body of a dynamically typed function is not checked statically, and local variables have implicit <code>Any</code> types.</p> <p>This makes it easier to migrate legacy Python code to mypy, as mypy won't complain about dynamically typed functions.</p> <p>The Any type</p> <p>A value with the <code>Any</code> type is dynamically typed. Mypy doesn't know anything about the possible runtime types of such value. Any operations are permitted on the value, and the operations are only checked at runtime. You can use <code>Any</code> as an \"escape hatch\" when you can't use a more precise type for some reason.</p> <p><code>Any</code> is compatible with every other type, and vice versa. You can freely assign a value of type <code>Any</code> to a variable with a more precise type:</p> <pre><code>a: Any = None\ns: str = ''\na = 2     # OK (assign \"int\" to \"Any\")\ns = a     # OK (assign \"Any\" to \"str\")\n</code></pre> <p>Declared (and inferred) types are ignored (or erased) at runtime. They are basically treated as comments, and thus the above code does not generate a runtime error, even though <code>s</code> gets an <code>int</code> value when the program is run, while the declared type of <code>s</code> is actually <code>str</code>! You need to be careful with <code>Any</code> types, since they let you lie to mypy, and this could easily hide bugs.</p> <p>If you do not define a function return value or argument types, these default to <code>Any</code>:</p> <pre><code>def show_heading(s) -&gt; None:\n    print('=== ' + s + ' ===')  # No static type checking, as s has type Any\n\nshow_heading(1)  # OK (runtime error only; mypy won't generate an error)\n</code></pre> <p>You should give a statically typed function an explicit <code>None</code> return type even if it doesn't return a value, as this lets mypy catch additional type errors:</p> <pre><code>def wait(t: float):  # Implicit Any return value\n    print('Waiting...')\n    time.sleep(t)\n\nif wait(2) &gt; 1:   # Mypy doesn't catch this error!\n    ...\n</code></pre> <p>If we had used an explicit <code>None</code> return type, mypy would have caught the error:</p> <pre><code>def wait(t: float) -&gt; None:\n    print('Waiting...')\n    time.sleep(t)\n\nif wait(2) &gt; 1:   # Error: can't compare None and int\n    ...\n</code></pre> <p>The <code>Any</code> type is discussed in more detail in section <code>dynamic-typing</code>.</p> <p>Note</p> <p>A function without any types in the signature is dynamically typed. The body of a dynamically typed function is not checked statically, and local variables have implicit <code>Any</code> types.</p> <p>This makes it easier to migrate legacy Python code to mypy, as mypy won't complain about dynamically typed functions.</p>"},{"location":"mypy/kind_of_types/#tuple-\u7c7b\u578b","title":"Tuple \u7c7b\u578b","text":"\u4e2d\u6587\u82f1\u6587 <p>The type <code>tuple[T1, ..., Tn]</code> represents a tuple with the item types <code>T1</code>, ..., <code>Tn</code>:</p> <pre><code># Use `typing.Tuple` in Python 3.8 and earlier\ndef f(t: tuple[int, str]) -&gt; None:\n    t = 1, 'foo'    # OK\n    t = 'foo', 1    # Type check error\n</code></pre> <p>A tuple type of this kind has exactly a specific number of items (2 in the above example). Tuples can also be used as immutable, varying-length sequences. You can use the type <code>tuple[T, ...]</code> (with a literal <code>...</code> -- it's part of the syntax) for this purpose. Example:</p> <pre><code>def print_squared(t: tuple[int, ...]) -&gt; None:\n    for n in t:\n        print(n, n ** 2)\n\nprint_squared(())           # OK\nprint_squared((1, 3, 5))    # OK\nprint_squared([1, 2])       # Error: only a tuple is valid\n</code></pre> <p>Note</p> <p>Usually it's a better idea to use <code>Sequence[T]</code> instead of <code>tuple[T, ...]</code>, as <code>typing.Sequence</code> is also compatible with lists and other non-tuple sequences.</p> <p>Note</p> <p><code>tuple[...]</code> is valid as a base class in Python 3.6 and later, and always in stub files. In earlier Python versions you can sometimes work around this limitation by using a named tuple as a base class (see section <code>named-tuples</code>).</p> <p>Tuple types</p> <p>The type <code>tuple[T1, ..., Tn]</code> represents a tuple with the item types <code>T1</code>, ..., <code>Tn</code>:</p> <pre><code># Use `typing.Tuple` in Python 3.8 and earlier\ndef f(t: tuple[int, str]) -&gt; None:\n    t = 1, 'foo'    # OK\n    t = 'foo', 1    # Type check error\n</code></pre> <p>A tuple type of this kind has exactly a specific number of items (2 in the above example). Tuples can also be used as immutable, varying-length sequences. You can use the type <code>tuple[T, ...]</code> (with a literal <code>...</code> -- it's part of the syntax) for this purpose. Example:</p> <pre><code>def print_squared(t: tuple[int, ...]) -&gt; None:\n    for n in t:\n        print(n, n ** 2)\n\nprint_squared(())           # OK\nprint_squared((1, 3, 5))    # OK\nprint_squared([1, 2])       # Error: only a tuple is valid\n</code></pre> <p>Note</p> <p>Usually it's a better idea to use <code>Sequence[T]</code> instead of <code>tuple[T, ...]</code>, as <code>typing.Sequence</code> is also compatible with lists and other non-tuple sequences.</p> <p>Note</p> <p><code>tuple[...]</code> is valid as a base class in Python 3.6 and later, and always in stub files. In earlier Python versions you can sometimes work around this limitation by using a named tuple as a base class (see section <code>named-tuples</code>).</p>"},{"location":"mypy/kind_of_types/#callable-\u7c7b\u578b-\u4ee5\u53ca-lambdas","title":"Callable \u7c7b\u578b (\u4ee5\u53ca lambdas)","text":"\u4e2d\u6587\u82f1\u6587 <p>You can pass around function objects and bound methods in statically typed code. The type of a function that accepts arguments <code>A1</code>, ..., <code>An</code> and returns <code>Rt</code> is <code>Callable[[A1, ..., An], Rt]</code>. Example:</p> <pre><code>from typing import Callable\n\ndef twice(i: int, next: Callable[[int], int]) -&gt; int:\n    return next(next(i))\n\ndef add(i: int) -&gt; int:\n    return i + 1\n\nprint(twice(3, add))   # 5\n</code></pre> <p>You can only have positional arguments, and only ones without default values, in callable types. These cover the vast majority of uses of callable types, but sometimes this isn't quite enough. Mypy recognizes a special form <code>Callable[..., T]</code> (with a literal <code>...</code>) which can be used in less typical cases. It is compatible with arbitrary callable objects that return a type compatible with <code>T</code>, independent of the number, types or kinds of arguments. Mypy lets you call such callable values with arbitrary arguments, without any checking -- in this respect they are treated similar to a <code>(*args: Any, **kwargs: Any)</code> function signature. Example:</p> <pre><code>from typing import Callable\n\ndef arbitrary_call(f: Callable[..., int]) -&gt; int:\n    return f('x') + f(y=2)  # OK\n\narbitrary_call(ord)   # No static error, but fails at runtime\narbitrary_call(open)  # Error: does not return an int\narbitrary_call(1)     # Error: 'int' is not callable\n</code></pre> <p>In situations where more precise or complex types of callbacks are necessary one can use flexible <code>callback protocols</code>. Lambdas are also supported. The lambda argument and return value types cannot be given explicitly; they are always inferred based on context using bidirectional type inference:</p> <pre><code>l = map(lambda x: x + 1, [1, 2, 3])   # Infer x as int and l as list[int]\n</code></pre> <p>If you want to give the argument or return value types explicitly, use an ordinary, perhaps nested function definition.</p> <p>Callables can also be used against type objects, matching their <code>__init__</code> or <code>__new__</code> signature:</p> <pre><code>from typing import Callable\n\nclass C:\n    def __init__(self, app: str) -&gt; None:\n        pass\n\nCallableType = Callable[[str], C]\n\ndef class_or_callable(arg: CallableType) -&gt; None:\n    inst = arg(\"my_app\")\n    reveal_type(inst)  # Revealed type is \"C\"\n</code></pre> <p>This is useful if you want <code>arg</code> to be either a <code>Callable</code> returning an instance of <code>C</code> or the type of <code>C</code> itself. This also works with <code>callback protocols</code>.</p> <p>Callable types (and lambdas)</p> <p>You can pass around function objects and bound methods in statically typed code. The type of a function that accepts arguments <code>A1</code>, ..., <code>An</code> and returns <code>Rt</code> is <code>Callable[[A1, ..., An], Rt]</code>. Example:</p> <pre><code>from typing import Callable\n\ndef twice(i: int, next: Callable[[int], int]) -&gt; int:\n    return next(next(i))\n\ndef add(i: int) -&gt; int:\n    return i + 1\n\nprint(twice(3, add))   # 5\n</code></pre> <p>You can only have positional arguments, and only ones without default values, in callable types. These cover the vast majority of uses of callable types, but sometimes this isn't quite enough. Mypy recognizes a special form <code>Callable[..., T]</code> (with a literal <code>...</code>) which can be used in less typical cases. It is compatible with arbitrary callable objects that return a type compatible with <code>T</code>, independent of the number, types or kinds of arguments. Mypy lets you call such callable values with arbitrary arguments, without any checking -- in this respect they are treated similar to a <code>(*args: Any, **kwargs: Any)</code> function signature. Example:</p> <pre><code>from typing import Callable\n\ndef arbitrary_call(f: Callable[..., int]) -&gt; int:\n    return f('x') + f(y=2)  # OK\n\narbitrary_call(ord)   # No static error, but fails at runtime\narbitrary_call(open)  # Error: does not return an int\narbitrary_call(1)     # Error: 'int' is not callable\n</code></pre> <p>In situations where more precise or complex types of callbacks are necessary one can use flexible <code>callback protocols</code>. Lambdas are also supported. The lambda argument and return value types cannot be given explicitly; they are always inferred based on context using bidirectional type inference:</p> <pre><code>l = map(lambda x: x + 1, [1, 2, 3])   # Infer x as int and l as list[int]\n</code></pre> <p>If you want to give the argument or return value types explicitly, use an ordinary, perhaps nested function definition.</p> <p>Callables can also be used against type objects, matching their <code>__init__</code> or <code>__new__</code> signature:</p> <pre><code>from typing import Callable\n\nclass C:\n    def __init__(self, app: str) -&gt; None:\n        pass\n\nCallableType = Callable[[str], C]\n\ndef class_or_callable(arg: CallableType) -&gt; None:\n    inst = arg(\"my_app\")\n    reveal_type(inst)  # Revealed type is \"C\"\n</code></pre> <p>This is useful if you want <code>arg</code> to be either a <code>Callable</code> returning an instance of <code>C</code> or the type of <code>C</code> itself. This also works with <code>callback protocols</code>.</p>"},{"location":"mypy/kind_of_types/#union-\u7c7b\u578b","title":"Union \u7c7b\u578b","text":"\u4e2d\u6587\u82f1\u6587 <p>Python functions often accept values of two or more different types. You can use <code>overloading</code> to represent this, but union types are often more convenient.</p> <p>Use the <code>Union[T1, ..., Tn]</code> type constructor to construct a union type. For example, if an argument has type <code>Union[int, str]</code>, both integers and strings are valid argument values.</p> <p>You can use an <code>isinstance</code> check to narrow down a union type to a more specific type:</p> <pre><code>from typing import Union\n\ndef f(x: Union[int, str]) -&gt; None:\n    x + 1     # Error: str + int is not valid\n    if isinstance(x, int):\n        # Here type of x is int.\n        x + 1      # OK\n    else:\n        # Here type of x is str.\n        x + 'a'    # OK\n\nf(1)    # OK\nf('x')  # OK\nf(1.1)  # Error\n</code></pre> <p>Note</p> <p>Operations are valid for union types only if they are valid for every union item. This is why it's often necessary to use an <code>isinstance</code> check to first narrow down a union type to a non-union type. This also means that it's recommended to avoid union types as function return types, since the caller may have to use <code>isinstance</code> before doing anything interesting with the value.</p> <p>Union types</p> <p>Python functions often accept values of two or more different types. You can use <code>overloading</code> to represent this, but union types are often more convenient.</p> <p>Use the <code>Union[T1, ..., Tn]</code> type constructor to construct a union type. For example, if an argument has type <code>Union[int, str]</code>, both integers and strings are valid argument values.</p> <p>You can use an <code>isinstance</code> check to narrow down a union type to a more specific type:</p> <pre><code>from typing import Union\n\ndef f(x: Union[int, str]) -&gt; None:\n    x + 1     # Error: str + int is not valid\n    if isinstance(x, int):\n        # Here type of x is int.\n        x + 1      # OK\n    else:\n        # Here type of x is str.\n        x + 'a'    # OK\n\nf(1)    # OK\nf('x')  # OK\nf(1.1)  # Error\n</code></pre> <p>Note</p> <p>Operations are valid for union types only if they are valid for every union item. This is why it's often necessary to use an <code>isinstance</code> check to first narrow down a union type to a non-union type. This also means that it's recommended to avoid union types as function return types, since the caller may have to use <code>isinstance</code> before doing anything interesting with the value.</p>"},{"location":"mypy/kind_of_types/#optional-\u548c-none-\u7c7b\u578b","title":"Optional \u548c None \u7c7b\u578b","text":"\u4e2d\u6587\u82f1\u6587 <p>You can use the <code>typing.Optional</code> type modifier to define a type variant that allows <code>None</code>, such as <code>Optional[int]</code> (<code>Optional[X]</code> is the preferred shorthand for <code>Union[X, None]</code>):</p> <pre><code>from typing import Optional\n\ndef strlen(s: str) -&gt; Optional[int]:\n    if not s:\n        return None  # OK\n    return len(s)\n\ndef strlen_invalid(s: str) -&gt; int:\n    if not s:\n        return None  # Error: None not compatible with int\n    return len(s)\n</code></pre> <p>Most operations will not be allowed on unguarded <code>None</code> or <code>typing.Optional</code> values:</p> <pre><code>def my_inc(x: Optional[int]) -&gt; int:\n    return x + 1  # Error: Cannot add None and int\n</code></pre> <p>Instead, an explicit <code>None</code> check is required. Mypy has powerful type inference that lets you use regular Python idioms to guard against <code>None</code> values. For example, mypy recognizes <code>is None</code> checks:</p> <pre><code>def my_inc(x: Optional[int]) -&gt; int:\n    if x is None:\n        return 0\n    else:\n        # The inferred type of x is just int here.\n        return x + 1\n</code></pre> <p>Mypy will infer the type of <code>x</code> to be <code>int</code> in the else block due to the check against <code>None</code> in the if condition.</p> <p>Other supported checks for guarding against a <code>None</code> value include <code>if x is not None</code>, <code>if x</code> and <code>if not x</code>. Additionally, mypy understands <code>None</code> checks within logical expressions:</p> <pre><code>def concat(x: Optional[str], y: Optional[str]) -&gt; Optional[str]:\n    if x is not None and y is not None:\n        # Both x and y are not None here\n        return x + y\n    else:\n        return None\n</code></pre> <p>Sometimes mypy doesn't realize that a value is never <code>None</code>. This notably happens when a class instance can exist in a partially defined state, where some attribute is initialized to <code>None</code> during object construction, but a method assumes that the attribute is no longer <code>None</code>. Mypy will complain about the possible <code>None</code> value. You can use <code>assert x is not None</code> to work around this in the method:</p> <pre><code>class Resource:\n    path: Optional[str] = None\n\n    def initialize(self, path: str) -&gt; None:\n        self.path = path\n\n    def read(self) -&gt; str:\n        # We require that the object has been initialized.\n        assert self.path is not None\n        with open(self.path) as f:  # OK\n           return f.read()\n\nr = Resource()\nr.initialize('/foo/bar')\nr.read()\n</code></pre> <p>When initializing a variable as <code>None</code>, <code>None</code> is usually an empty place-holder value, and the actual value has a different type. This is why you need to annotate an attribute in cases like the class <code>Resource</code> above:</p> <pre><code>class Resource:\n    path: Optional[str] = None\n    ...\n</code></pre> <p>This also works for attributes defined within methods:</p> <pre><code>class Counter:\n    def __init__(self) -&gt; None:\n        self.count: Optional[int] = None\n</code></pre> <p>This is not a problem when using variable annotations, since no initial value is needed:</p> <pre><code>class Container:\n    items: list[str]  # No initial value\n</code></pre> <p>Mypy generally uses the first assignment to a variable to infer the type of the variable. However, if you assign both a <code>None</code> value and a non-<code>None</code> value in the same scope, mypy can usually do the right thing without an annotation:</p> <pre><code>def f(i: int) -&gt; None:\n    n = None  # Inferred type Optional[int] because of the assignment below\n    if i &gt; 0:\n         n = i\n    ...\n</code></pre> <p>Sometimes you may get the error \"Cannot determine type of \\\". In this case you should add an explicit <code>Optional[...]</code> annotation (or type comment). <p>Note</p> <p><code>None</code> is a type with only one value, <code>None</code>. <code>None</code> is also used as the return type for functions that don't return a value, i.e. functions that implicitly return <code>None</code>.</p> <p>Note</p> <p>The Python interpreter internally uses the name <code>NoneType</code> for the type of <code>None</code>, but <code>None</code> is always used in type annotations. The latter is shorter and reads better. (<code>NoneType</code> is available as <code>types.NoneType</code> on Python 3.10+, but is not exposed at all on earlier versions of Python.)</p> <p>Note</p> <p><code>Optional[...]</code> does not mean a function argument with a default value. It simply means that <code>None</code> is a valid value for the argument. This is a common confusion because <code>None</code> is a common default value for arguments.</p> <p>Optional types and the None type</p> <p>You can use the <code>typing.Optional</code> type modifier to define a type variant that allows <code>None</code>, such as <code>Optional[int]</code> (<code>Optional[X]</code> is the preferred shorthand for <code>Union[X, None]</code>):</p> <pre><code>from typing import Optional\n\ndef strlen(s: str) -&gt; Optional[int]:\n    if not s:\n        return None  # OK\n    return len(s)\n\ndef strlen_invalid(s: str) -&gt; int:\n    if not s:\n        return None  # Error: None not compatible with int\n    return len(s)\n</code></pre> <p>Most operations will not be allowed on unguarded <code>None</code> or <code>typing.Optional</code> values:</p> <pre><code>def my_inc(x: Optional[int]) -&gt; int:\n    return x + 1  # Error: Cannot add None and int\n</code></pre> <p>Instead, an explicit <code>None</code> check is required. Mypy has powerful type inference that lets you use regular Python idioms to guard against <code>None</code> values. For example, mypy recognizes <code>is None</code> checks:</p> <pre><code>def my_inc(x: Optional[int]) -&gt; int:\n    if x is None:\n        return 0\n    else:\n        # The inferred type of x is just int here.\n        return x + 1\n</code></pre> <p>Mypy will infer the type of <code>x</code> to be <code>int</code> in the else block due to the check against <code>None</code> in the if condition.</p> <p>Other supported checks for guarding against a <code>None</code> value include <code>if x is not None</code>, <code>if x</code> and <code>if not x</code>. Additionally, mypy understands <code>None</code> checks within logical expressions:</p> <pre><code>def concat(x: Optional[str], y: Optional[str]) -&gt; Optional[str]:\n    if x is not None and y is not None:\n        # Both x and y are not None here\n        return x + y\n    else:\n        return None\n</code></pre> <p>Sometimes mypy doesn't realize that a value is never <code>None</code>. This notably happens when a class instance can exist in a partially defined state, where some attribute is initialized to <code>None</code> during object construction, but a method assumes that the attribute is no longer <code>None</code>. Mypy will complain about the possible <code>None</code> value. You can use <code>assert x is not None</code> to work around this in the method:</p> <pre><code>class Resource:\n    path: Optional[str] = None\n\n    def initialize(self, path: str) -&gt; None:\n        self.path = path\n\n    def read(self) -&gt; str:\n        # We require that the object has been initialized.\n        assert self.path is not None\n        with open(self.path) as f:  # OK\n           return f.read()\n\nr = Resource()\nr.initialize('/foo/bar')\nr.read()\n</code></pre> <p>When initializing a variable as <code>None</code>, <code>None</code> is usually an empty place-holder value, and the actual value has a different type. This is why you need to annotate an attribute in cases like the class <code>Resource</code> above:</p> <pre><code>class Resource:\n    path: Optional[str] = None\n    ...\n</code></pre> <p>This also works for attributes defined within methods:</p> <pre><code>class Counter:\n    def __init__(self) -&gt; None:\n        self.count: Optional[int] = None\n</code></pre> <p>This is not a problem when using variable annotations, since no initial value is needed:</p> <pre><code>class Container:\n    items: list[str]  # No initial value\n</code></pre> <p>Mypy generally uses the first assignment to a variable to infer the type of the variable. However, if you assign both a <code>None</code> value and a non-<code>None</code> value in the same scope, mypy can usually do the right thing without an annotation:</p> <pre><code>def f(i: int) -&gt; None:\n    n = None  # Inferred type Optional[int] because of the assignment below\n    if i &gt; 0:\n         n = i\n    ...\n</code></pre> <p>Sometimes you may get the error \"Cannot determine type of \\\". In this case you should add an explicit <code>Optional[...]</code> annotation (or type comment). <p>Note</p> <p><code>None</code> is a type with only one value, <code>None</code>. <code>None</code> is also used as the return type for functions that don't return a value, i.e. functions that implicitly return <code>None</code>.</p> <p>Note</p> <p>The Python interpreter internally uses the name <code>NoneType</code> for the type of <code>None</code>, but <code>None</code> is always used in type annotations. The latter is shorter and reads better. (<code>NoneType</code> is available as <code>types.NoneType</code> on Python 3.10+, but is not exposed at all on earlier versions of Python.)</p> <p>Note</p> <p><code>Optional[...]</code> does not mean a function argument with a default value. It simply means that <code>None</code> is a valid value for the argument. This is a common confusion because <code>None</code> is a common default value for arguments.</p>"},{"location":"mypy/kind_of_types/#union-\u7684-x--y-\u8bed\u6cd5","title":"Union \u7684 X | Y \u8bed\u6cd5","text":"\u4e2d\u6587\u82f1\u6587 <p><code>PEP 604</code> introduced an alternative way for spelling union types. In Python 3.10 and later, you can write <code>Union[int, str]</code> as <code>int | str</code>. It is possible to use this syntax in versions of Python where it isn't supported by the runtime with some limitations (see <code>runtime troubles</code>).</p> <pre><code>t1: int | str  # equivalent to Union[int, str]\n\nt2: int | None  # equivalent to Optional[int]\n</code></pre> <p>X | Y syntax for Unions</p> <p><code>PEP 604</code> introduced an alternative way for spelling union types. In Python 3.10 and later, you can write <code>Union[int, str]</code> as <code>int | str</code>. It is possible to use this syntax in versions of Python where it isn't supported by the runtime with some limitations (see <code>runtime troubles</code>).</p> <pre><code>t1: int | str  # equivalent to Union[int, str]\n\nt2: int | None  # equivalent to Optional[int]\n</code></pre>"},{"location":"mypy/kind_of_types/#\u7981\u7528\u4e25\u683c\u7684\u53ef\u9009\u68c0\u67e5","title":"\u7981\u7528\u4e25\u683c\u7684\u53ef\u9009\u68c0\u67e5","text":"\u4e2d\u6587\u82f1\u6587 <p>Mypy also has an option to treat <code>None</code> as a valid value for every type (in case you know Java, it's useful to think of it as similar to the Java <code>null</code>). In this mode <code>None</code> is also valid for primitive types such as <code>int</code> and <code>float</code>, and <code>typing.Optional</code> types are not required.</p> <p>The mode is enabled through the <code>--no-strict-optional</code> command-line option. In mypy versions before 0.600 this was the default mode. You can enable this option explicitly for backward compatibility with earlier mypy versions, in case you don't want to introduce optional types to your codebase yet.</p> <p>It will cause mypy to silently accept some buggy code, such as this example -- it's not recommended if you can avoid it:</p> <pre><code>def inc(x: int) -&gt; int:\n    return x + 1\n\nx = inc(None)  # No error reported by mypy if strict optional mode disabled!\n</code></pre> <p>However, making code \"optional clean\" can take some work! You can also use <code>the mypy configuration file</code> to migrate your code to strict optional checking one file at a time, since there exists the per-module flag <code>strict_optional</code> to control strict optional mode.</p> <p>Often it's still useful to document whether a variable can be <code>None</code>. For example, this function accepts a <code>None</code> argument, but it's not obvious from its signature:</p> <pre><code>def greeting(name: str) -&gt; str:\n    if name:\n        return f'Hello, {name}'\n    else:\n        return 'Hello, stranger'\n\nprint(greeting('Python'))  # Okay!\nprint(greeting(None))      # Also okay!\n</code></pre> <p>You can still use <code>Optional[t]</code> to document that <code>None</code> is a valid argument type, even if strict <code>None</code> checking is not enabled:</p> <pre><code>from typing import Optional\n\ndef greeting(name: Optional[str]) -&gt; str:\n    if name:\n        return f'Hello, {name}'\n    else:\n        return 'Hello, stranger'\n</code></pre> <p>Mypy treats this as semantically equivalent to the previous example if strict optional checking is disabled, since <code>None</code> is implicitly valid for any type, but it's much more useful for a programmer who is reading the code. This also makes it easier to migrate to strict <code>None</code> checking in the future.</p> <p>Disabling strict optional checking</p> <p>Mypy also has an option to treat <code>None</code> as a valid value for every type (in case you know Java, it's useful to think of it as similar to the Java <code>null</code>). In this mode <code>None</code> is also valid for primitive types such as <code>int</code> and <code>float</code>, and <code>typing.Optional</code> types are not required.</p> <p>The mode is enabled through the <code>--no-strict-optional</code> command-line option. In mypy versions before 0.600 this was the default mode. You can enable this option explicitly for backward compatibility with earlier mypy versions, in case you don't want to introduce optional types to your codebase yet.</p> <p>It will cause mypy to silently accept some buggy code, such as this example -- it's not recommended if you can avoid it:</p> <pre><code>def inc(x: int) -&gt; int:\n    return x + 1\n\nx = inc(None)  # No error reported by mypy if strict optional mode disabled!\n</code></pre> <p>However, making code \"optional clean\" can take some work! You can also use <code>the mypy configuration file</code> to migrate your code to strict optional checking one file at a time, since there exists the per-module flag <code>strict_optional</code> to control strict optional mode.</p> <p>Often it's still useful to document whether a variable can be <code>None</code>. For example, this function accepts a <code>None</code> argument, but it's not obvious from its signature:</p> <pre><code>def greeting(name: str) -&gt; str:\n    if name:\n        return f'Hello, {name}'\n    else:\n        return 'Hello, stranger'\n\nprint(greeting('Python'))  # Okay!\nprint(greeting(None))      # Also okay!\n</code></pre> <p>You can still use <code>Optional[t]</code> to document that <code>None</code> is a valid argument type, even if strict <code>None</code> checking is not enabled:</p> <pre><code>from typing import Optional\n\ndef greeting(name: Optional[str]) -&gt; str:\n    if name:\n        return f'Hello, {name}'\n    else:\n        return 'Hello, stranger'\n</code></pre> <p>Mypy treats this as semantically equivalent to the previous example if strict optional checking is disabled, since <code>None</code> is implicitly valid for any type, but it's much more useful for a programmer who is reading the code. This also makes it easier to migrate to strict <code>None</code> checking in the future.</p>"},{"location":"mypy/kind_of_types/#\u7c7b\u578b\u522b\u540d","title":"\u7c7b\u578b\u522b\u540d","text":"\u4e2d\u6587\u82f1\u6587 <p>In certain situations, type names may end up being long and painful to type:</p> <pre><code>def f() -&gt; Union[list[dict[tuple[int, str], set[int]]], tuple[str, list[str]]]:\n    ...\n</code></pre> <p>When cases like this arise, you can define a type alias by simply assigning the type to a variable:</p> <pre><code>AliasType = Union[list[dict[tuple[int, str], set[int]]], tuple[str, list[str]]]\n\n# Now we can use AliasType in place of the full name:\n\ndef f() -&gt; AliasType:\n    ...\n</code></pre> <p>Note</p> <p>A type alias does not create a new type. It's just a shorthand notation for another type -- it's equivalent to the target type except for <code>generic aliases</code>.</p> <p>Since Mypy 0.930 you can also use explicit type aliases, which were introduced in <code>PEP 613</code>.</p> <p>There can be confusion about exactly when an assignment defines an implicit type alias -- for example, when the alias contains forward references, invalid types, or violates some other restrictions on type alias declarations.  Because the distinction between an unannotated variable and a type alias is implicit, ambiguous or incorrect type alias declarations default to defining a normal variable instead of a type alias.</p> <p>Explicit type aliases are unambiguous and can also improve readability by making the intent clear:</p> <pre><code>from typing import TypeAlias  # \"from typing_extensions\" in Python 3.9 and earlier\n\nAliasType: TypeAlias = Union[list[dict[tuple[int, str], set[int]]], tuple[str, list[str]]]\n</code></pre> <p>Type aliases</p> <p>In certain situations, type names may end up being long and painful to type:</p> <pre><code>def f() -&gt; Union[list[dict[tuple[int, str], set[int]]], tuple[str, list[str]]]:\n    ...\n</code></pre> <p>When cases like this arise, you can define a type alias by simply assigning the type to a variable:</p> <pre><code>AliasType = Union[list[dict[tuple[int, str], set[int]]], tuple[str, list[str]]]\n\n# Now we can use AliasType in place of the full name:\n\ndef f() -&gt; AliasType:\n    ...\n</code></pre> <p>Note</p> <p>A type alias does not create a new type. It's just a shorthand notation for another type -- it's equivalent to the target type except for <code>generic aliases</code>.</p> <p>Since Mypy 0.930 you can also use explicit type aliases, which were introduced in <code>PEP 613</code>.</p> <p>There can be confusion about exactly when an assignment defines an implicit type alias -- for example, when the alias contains forward references, invalid types, or violates some other restrictions on type alias declarations.  Because the distinction between an unannotated variable and a type alias is implicit, ambiguous or incorrect type alias declarations default to defining a normal variable instead of a type alias.</p> <p>Explicit type aliases are unambiguous and can also improve readability by making the intent clear:</p> <pre><code>from typing import TypeAlias  # \"from typing_extensions\" in Python 3.9 and earlier\n\nAliasType: TypeAlias = Union[list[dict[tuple[int, str], set[int]]], tuple[str, list[str]]]\n</code></pre>"},{"location":"mypy/kind_of_types/#\u547d\u540d\u5143\u7ec4","title":"\u547d\u540d\u5143\u7ec4","text":"\u4e2d\u6587\u82f1\u6587 <p>Mypy recognizes named tuples and can type check code that defines or uses them.  In this example, we can detect code trying to access a missing attribute:</p> <pre><code>Point = namedtuple('Point', ['x', 'y'])\np = Point(x=1, y=2)\nprint(p.z)  # Error: Point has no attribute 'z'\n</code></pre> <p>If you use <code>namedtuple</code> to define your named tuple, all the items are assumed to have <code>Any</code> types. That is, mypy doesn't know anything about item types. You can use <code>typing.NamedTuple</code> to also define item types:</p> <pre><code>from typing import NamedTuple\n\nPoint = NamedTuple('Point', [('x', int),\n                             ('y', int)])\np = Point(x=1, y='x')  # Argument has incompatible type \"str\"; expected \"int\"\n</code></pre> <p>Python 3.6 introduced an alternative, class-based syntax for named tuples with types:</p> <pre><code>from typing import NamedTuple\n\nclass Point(NamedTuple):\n    x: int\n    y: int\n\np = Point(x=1, y='x')  # Argument has incompatible type \"str\"; expected \"int\"\n</code></pre> <p>Note</p> <p>You can use the raw <code>NamedTuple</code> \"pseudo-class\" in type annotations if any <code>NamedTuple</code> object is valid.</p> <p>For example, it can be useful for deserialization:</p> <pre><code>def deserialize_named_tuple(arg: NamedTuple) -&gt; Dict[str, Any]:\n    return arg._asdict()\n\nPoint = namedtuple('Point', ['x', 'y'])\nPerson = NamedTuple('Person', [('name', str), ('age', int)])\n\ndeserialize_named_tuple(Point(x=1, y=2))  # ok\ndeserialize_named_tuple(Person(name='Nikita', age=18))  # ok\n\n# Error: Argument 1 to \"deserialize_named_tuple\" has incompatible type\n# \"Tuple[int, int]\"; expected \"NamedTuple\"\ndeserialize_named_tuple((1, 2))\n</code></pre> <p>Note that this behavior is highly experimental, non-standard, and may not be supported by other type checkers and IDEs.</p> <p>Named tuples</p> <p>Mypy recognizes named tuples and can type check code that defines or uses them.  In this example, we can detect code trying to access a missing attribute:</p> <pre><code>Point = namedtuple('Point', ['x', 'y'])\np = Point(x=1, y=2)\nprint(p.z)  # Error: Point has no attribute 'z'\n</code></pre> <p>If you use <code>namedtuple</code> to define your named tuple, all the items are assumed to have <code>Any</code> types. That is, mypy doesn't know anything about item types. You can use <code>typing.NamedTuple</code> to also define item types:</p> <pre><code>from typing import NamedTuple\n\nPoint = NamedTuple('Point', [('x', int),\n                             ('y', int)])\np = Point(x=1, y='x')  # Argument has incompatible type \"str\"; expected \"int\"\n</code></pre> <p>Python 3.6 introduced an alternative, class-based syntax for named tuples with types:</p> <pre><code>from typing import NamedTuple\n\nclass Point(NamedTuple):\n    x: int\n    y: int\n\np = Point(x=1, y='x')  # Argument has incompatible type \"str\"; expected \"int\"\n</code></pre> <p>Note</p> <p>You can use the raw <code>NamedTuple</code> \"pseudo-class\" in type annotations if any <code>NamedTuple</code> object is valid.</p> <p>For example, it can be useful for deserialization:</p> <pre><code>def deserialize_named_tuple(arg: NamedTuple) -&gt; Dict[str, Any]:\n    return arg._asdict()\n\nPoint = namedtuple('Point', ['x', 'y'])\nPerson = NamedTuple('Person', [('name', str), ('age', int)])\n\ndeserialize_named_tuple(Point(x=1, y=2))  # ok\ndeserialize_named_tuple(Person(name='Nikita', age=18))  # ok\n\n# Error: Argument 1 to \"deserialize_named_tuple\" has incompatible type\n# \"Tuple[int, int]\"; expected \"NamedTuple\"\ndeserialize_named_tuple((1, 2))\n</code></pre> <p>Note that this behavior is highly experimental, non-standard, and may not be supported by other type checkers and IDEs.</p>"},{"location":"mypy/kind_of_types/#\u7c7b\u5bf9\u8c61\u7684\u7c7b\u578b","title":"\u7c7b\u5bf9\u8c61\u7684\u7c7b\u578b","text":"\u4e2d\u6587\u82f1\u6587 <p>(Freely after <code>PEP 484: The type of class objects</code>.)</p> <p>Sometimes you want to talk about class objects that inherit from a given class.  This can be spelled as <code>type[C]</code> (or, on Python 3.8 and lower, <code>typing.Type[C]</code>) where <code>C</code> is a class.  In other words, when <code>C</code> is the name of a class, using <code>C</code> to annotate an argument declares that the argument is an instance of <code>C</code> (or of a subclass of <code>C</code>), but using <code>type[C]</code> as an argument annotation declares that the argument is a class object deriving from <code>C</code> (or <code>C</code> itself).</p> <p>For example, assume the following classes:</p> <pre><code>class User:\n    # Defines fields like name, email\n\nclass BasicUser(User):\n    def upgrade(self):\n        \"\"\"Upgrade to Pro\"\"\"\n\nclass ProUser(User):\n    def pay(self):\n        \"\"\"Pay bill\"\"\"\n</code></pre> <p>Note that <code>ProUser</code> doesn't inherit from <code>BasicUser</code>.</p> <p>Here's a function that creates an instance of one of these classes if you pass it the right class object:</p> <pre><code>def new_user(user_class):\n    user = user_class()\n    # (Here we could write the user object to a database)\n    return user\n</code></pre> <p>How would we annotate this function?  Without the ability to parameterize <code>type</code>, the best we could do would be:</p> <pre><code>def new_user(user_class: type) -&gt; User:\n    # Same  implementation as before\n</code></pre> <p>This seems reasonable, except that in the following example, mypy doesn't see that the <code>buyer</code> variable has type <code>ProUser</code>:</p> <pre><code>buyer = new_user(ProUser)\nbuyer.pay()  # Rejected, not a method on User\n</code></pre> <p>However, using the <code>type[C]</code> syntax and a type variable with an upper bound (see <code>type-variable-upper-bound</code>) we can do better:</p> <pre><code>U = TypeVar('U', bound=User)\n\ndef new_user(user_class: type[U]) -&gt; U:\n    # Same  implementation as before\n</code></pre> <p>Now mypy will infer the correct type of the result when we call <code>new_user()</code> with a specific subclass of <code>User</code>:</p> <pre><code>beginner = new_user(BasicUser)  # Inferred type is BasicUser\nbeginner.upgrade()  # OK\n</code></pre> <p>Note</p> <p>The value corresponding to <code>type[C]</code> must be an actual class object that's a subtype of <code>C</code>.  Its constructor must be compatible with the constructor of <code>C</code>.  If <code>C</code> is a type variable, its upper bound must be a class object.</p> <p>For more details about <code>type[]</code> and <code>typing.Type[]</code>, see <code>PEP 484: The type of class objects &lt;484#the-type-of-class-objects&gt;</code>.</p> <p>The type of class objects</p> <p>(Freely after <code>PEP 484: The type of class objects</code>.)</p> <p>Sometimes you want to talk about class objects that inherit from a given class.  This can be spelled as <code>type[C]</code> (or, on Python 3.8 and lower, <code>typing.Type[C]</code>) where <code>C</code> is a class.  In other words, when <code>C</code> is the name of a class, using <code>C</code> to annotate an argument declares that the argument is an instance of <code>C</code> (or of a subclass of <code>C</code>), but using <code>type[C]</code> as an argument annotation declares that the argument is a class object deriving from <code>C</code> (or <code>C</code> itself).</p> <p>For example, assume the following classes:</p> <pre><code>class User:\n    # Defines fields like name, email\n\nclass BasicUser(User):\n    def upgrade(self):\n        \"\"\"Upgrade to Pro\"\"\"\n\nclass ProUser(User):\n    def pay(self):\n        \"\"\"Pay bill\"\"\"\n</code></pre> <p>Note that <code>ProUser</code> doesn't inherit from <code>BasicUser</code>.</p> <p>Here's a function that creates an instance of one of these classes if you pass it the right class object:</p> <pre><code>def new_user(user_class):\n    user = user_class()\n    # (Here we could write the user object to a database)\n    return user\n</code></pre> <p>How would we annotate this function?  Without the ability to parameterize <code>type</code>, the best we could do would be:</p> <pre><code>def new_user(user_class: type) -&gt; User:\n    # Same  implementation as before\n</code></pre> <p>This seems reasonable, except that in the following example, mypy doesn't see that the <code>buyer</code> variable has type <code>ProUser</code>:</p> <pre><code>buyer = new_user(ProUser)\nbuyer.pay()  # Rejected, not a method on User\n</code></pre> <p>However, using the <code>type[C]</code> syntax and a type variable with an upper bound (see <code>type-variable-upper-bound</code>) we can do better:</p> <pre><code>U = TypeVar('U', bound=User)\n\ndef new_user(user_class: type[U]) -&gt; U:\n    # Same  implementation as before\n</code></pre> <p>Now mypy will infer the correct type of the result when we call <code>new_user()</code> with a specific subclass of <code>User</code>:</p> <pre><code>beginner = new_user(BasicUser)  # Inferred type is BasicUser\nbeginner.upgrade()  # OK\n</code></pre> <p>Note</p> <p>The value corresponding to <code>type[C]</code> must be an actual class object that's a subtype of <code>C</code>.  Its constructor must be compatible with the constructor of <code>C</code>.  If <code>C</code> is a type variable, its upper bound must be a class object.</p> <p>For more details about <code>type[]</code> and <code>typing.Type[]</code>, see <code>PEP 484: The type of class objects &lt;484#the-type-of-class-objects&gt;</code>.</p>"},{"location":"mypy/kind_of_types/#\u751f\u6210\u5668","title":"\u751f\u6210\u5668","text":"\u4e2d\u6587\u82f1\u6587 <p>A basic generator that only yields values can be succinctly annotated as having a return type of either <code>Iterator[YieldType]</code> or <code>Iterable[YieldType]</code>. For example:</p> <pre><code>def squares(n: int) -&gt; Iterator[int]:\n    for i in range(n):\n        yield i * i\n</code></pre> <p>A good rule of thumb is to annotate functions with the most specific return type possible. However, you should also take care to avoid leaking implementation details into a function's public API. In keeping with these two principles, prefer <code>Iterator[YieldType]</code> over <code>Iterable[YieldType]</code> as the return-type annotation for a generator function, as it lets mypy know that users are able to call <code>next</code> on the object returned by the function. Nonetheless, bear in mind that <code>Iterable</code> may sometimes be the better option, if you consider it an implementation detail that <code>next()</code> can be called on the object returned by your function.</p> <p>If you want your generator to accept values via the <code>generator.send</code> method or return a value, on the other hand, you should use the <code>Generator[YieldType, SendType, ReturnType]</code> generic type instead of either <code>Iterator</code> or <code>Iterable</code>. For example:</p> <pre><code>def echo_round() -&gt; Generator[int, float, str]:\n    sent = yield 0\n    while sent &gt;= 0:\n        sent = yield round(sent)\n    return 'Done'\n</code></pre> <p>Note that unlike many other generics in the typing module, the <code>SendType</code> of <code>typing.Generator</code> behaves contravariantly, not covariantly or invariantly.</p> <p>If you do not plan on receiving or returning values, then set the <code>SendType</code> or <code>ReturnType</code> to <code>None</code>, as appropriate. For example, we could have annotated the first example as the following:</p> <pre><code>def squares(n: int) -&gt; Generator[int, None, None]:\n    for i in range(n):\n        yield i * i\n</code></pre> <p>This is slightly different from using <code>Iterator[int]</code> or <code>Iterable[int]</code>, since generators have <code>generator.close</code>, <code>generator.send</code>, and <code>generator.throw</code> methods that generic iterators and iterables don't. If you plan to call these methods on the returned generator, use the <code>typing.Generator</code> type instead of <code>typing.Iterator</code> or <code>typing.Iterable</code>.</p> <p>Generators</p> <p>A basic generator that only yields values can be succinctly annotated as having a return type of either <code>Iterator[YieldType]</code> or <code>Iterable[YieldType]</code>. For example:</p> <pre><code>def squares(n: int) -&gt; Iterator[int]:\n    for i in range(n):\n        yield i * i\n</code></pre> <p>A good rule of thumb is to annotate functions with the most specific return type possible. However, you should also take care to avoid leaking implementation details into a function's public API. In keeping with these two principles, prefer <code>Iterator[YieldType]</code> over <code>Iterable[YieldType]</code> as the return-type annotation for a generator function, as it lets mypy know that users are able to call <code>next</code> on the object returned by the function. Nonetheless, bear in mind that <code>Iterable</code> may sometimes be the better option, if you consider it an implementation detail that <code>next()</code> can be called on the object returned by your function.</p> <p>If you want your generator to accept values via the <code>generator.send</code> method or return a value, on the other hand, you should use the <code>Generator[YieldType, SendType, ReturnType]</code> generic type instead of either <code>Iterator</code> or <code>Iterable</code>. For example:</p> <pre><code>def echo_round() -&gt; Generator[int, float, str]:\n    sent = yield 0\n    while sent &gt;= 0:\n        sent = yield round(sent)\n    return 'Done'\n</code></pre> <p>Note that unlike many other generics in the typing module, the <code>SendType</code> of <code>typing.Generator</code> behaves contravariantly, not covariantly or invariantly.</p> <p>If you do not plan on receiving or returning values, then set the <code>SendType</code> or <code>ReturnType</code> to <code>None</code>, as appropriate. For example, we could have annotated the first example as the following:</p> <pre><code>def squares(n: int) -&gt; Generator[int, None, None]:\n    for i in range(n):\n        yield i * i\n</code></pre> <p>This is slightly different from using <code>Iterator[int]</code> or <code>Iterable[int]</code>, since generators have <code>generator.close</code>, <code>generator.send</code>, and <code>generator.throw</code> methods that generic iterators and iterables don't. If you plan to call these methods on the returned generator, use the <code>typing.Generator</code> type instead of <code>typing.Iterator</code> or <code>typing.Iterable</code>.</p>"},{"location":"mypy/literal_and_enum/","title":"\u5b57\u9762\u91cf\u548c\u679a\u4e3e","text":"<p>Literal types and Enums</p>"},{"location":"mypy/literal_and_enum/#\u5b57\u9762\u91cf\u7c7b\u578b","title":"\u5b57\u9762\u91cf\u7c7b\u578b","text":"<p>Literal types</p> \u4e2d\u6587\u82f1\u6587 <p>\u5b57\u9762\u91cf\u7c7b\u578b\u53ef\u8ba9\u60a8\u6307\u793a\u8868\u8fbe\u5f0f\u7b49\u4e8e\u67d0\u4e2a\u7279\u5b9a\u7684\u539f\u59cb\u503c\u3002 \u4f8b\u5982\uff0c\u5982\u679c\u6211\u4eec\u7528 <code>Literal[\"foo\"]</code> \u7c7b\u578b\u6ce8\u91ca\u4e00\u4e2a\u53d8\u91cf\uff0cmypy \u5c06\u7406\u89e3\u8be5\u53d8\u91cf\u4e0d\u4ec5\u662f <code>str</code> \u7c7b\u578b\uff0c\u800c\u4e14\u8fd8\u7b49\u4e8e\u5b57\u7b26\u4e32 <code>\"foo\"</code>\u3002</p> <p>\u5f53\u6ce8\u91ca\u6839\u636e\u8c03\u7528\u8005\u63d0\u4f9b\u7684\u786e\u5207\u503c\u800c\u8868\u73b0\u4e0d\u540c\u7684\u51fd\u6570\u65f6\uff0c\u6b64\u529f\u80fd\u4e3b\u8981\u6709\u7528\u3002 \u4f8b\u5982\uff0c\u5047\u8bbe\u6211\u4eec\u6709\u4e00\u4e2a\u51fd\u6570\u201cfetch_data(...)\u201d\uff0c\u5982\u679c\u7b2c\u4e00\u4e2a\u53c2\u6570\u4e3a\u201cTrue\u201d\uff0c\u5219\u8fd4\u56de \u201cbytes\u201d \uff1b\u5982\u679c\u7b2c\u4e00\u4e2a\u53c2\u6570\u4e3a\u201cFalse\u201d\uff0c\u5219\u8fd4\u56de\u201cstr\u201d\u3002 \u6211\u4eec\u53ef\u4ee5\u4f7f\u7528\u201cLiteral[...]\u201d\u548c\u91cd\u8f7d\u4e3a\u6b64\u51fd\u6570\u6784\u9020\u7cbe\u786e\u7684\u7c7b\u578b\u7b7e\u540d\uff1a</p> <pre><code>from typing import overload, Union, Literal\n\n# \u524d\u4e24\u4e2a\u91cd\u8f7d\u4f7f\u7528 Literal[...]\uff0c\u56e0\u6b64\u6211\u4eec\u53ef\u4ee5\u83b7\u5f97\u7cbe\u786e\u7684\u8fd4\u56de\u7c7b\u578b\uff1a\n\n@overload\ndef fetch_data(raw: Literal[True]) -&gt; bytes: ...\n@overload\ndef fetch_data(raw: Literal[False]) -&gt; str: ...\n\n# \u6700\u540e\u4e00\u4e2a\u91cd\u8f7d\u662f\u8c03\u7528\u8005\u63d0\u4f9b\u5e38\u89c4\u5e03\u5c14\u503c\u65f6\u7684\u540e\u5907\uff1a\n\n@overload\ndef fetch_data(raw: bool) -&gt; Union[bytes, str]: ...\n\ndef fetch_data(raw: bool) -&gt; Union[bytes, str]:\n    # \u7701\u7565\u5b9e\u73b0\n    ...\n\nreveal_type(fetch_data(True))        # Revealed type is \"bytes\"\nreveal_type(fetch_data(False))       # Revealed type is \"str\"\n\n# \u6ca1\u6709\u6ce8\u91ca\u58f0\u660e\u7684\u53d8\u91cf\u5c06\u7ee7\u7eed\u5177\u6709\u201cbool\u201d\u7684\u63a8\u65ad\u7c7b\u578b\u3002\n\nvariable = True\nreveal_type(fetch_data(variable))    # Revealed type is \"Union[bytes, str]\"\n</code></pre> <p>Note</p> <p>\u672c\u9875\u4e2d\u7684\u793a\u4f8b\u4ece\u201ctyping\u201d\u6a21\u5757\u5bfc\u5165\u201cLiteral\u201d\u4ee5\u53ca\u201cFinal\u201d\u548c\u201cTypedDict\u201d\u3002 \u8fd9\u4e9b\u7c7b\u578b\u5df2\u6dfb\u52a0\u5230 Python 3.8 \u4e2d\u7684\u201ctyping\u201d\u4e2d\uff0c\u4f46\u4e5f\u53ef\u4ee5\u901a\u8fc7\u201ctyping_extensions\u201d\u5305\u5728 Python 3.4 - 3.7 \u4e2d\u4f7f\u7528\u3002</p> <p>Literal types let you indicate that an expression is equal to some specific primitive value. For example, if we annotate a variable with type <code>Literal[\"foo\"]</code>, mypy will understand that variable is not only of type <code>str</code>, but is also equal to specifically the string <code>\"foo\"</code>.</p> <p>This feature is primarily useful when annotating functions that behave differently based on the exact value the caller provides. For example, suppose we have a function <code>fetch_data(...)</code> that returns <code>bytes</code> if the first argument is <code>True</code>, and <code>str</code> if it's <code>False</code>. We can construct a precise type signature for this function using <code>Literal[...]</code> and overloads:</p> <pre><code>from typing import overload, Union, Literal\n\n# The first two overloads use Literal[...] so we can\n# have precise return types:\n\n@overload\ndef fetch_data(raw: Literal[True]) -&gt; bytes: ...\n@overload\ndef fetch_data(raw: Literal[False]) -&gt; str: ...\n\n# The last overload is a fallback in case the caller\n# provides a regular bool:\n\n@overload\ndef fetch_data(raw: bool) -&gt; Union[bytes, str]: ...\n\ndef fetch_data(raw: bool) -&gt; Union[bytes, str]:\n    # Implementation is omitted\n    ...\n\nreveal_type(fetch_data(True))        # Revealed type is \"bytes\"\nreveal_type(fetch_data(False))       # Revealed type is \"str\"\n\n# Variables declared without annotations will continue to have an\n# inferred type of 'bool'.\n\nvariable = True\nreveal_type(fetch_data(variable))    # Revealed type is \"Union[bytes, str]\"\n</code></pre> <p>Note</p> <p>The examples in this page import <code>Literal</code> as well as <code>Final</code> and <code>TypedDict</code> from the <code>typing</code> module. These types were added to <code>typing</code> in Python 3.8, but are also available for use in Python 3.4 - 3.7 via the <code>typing_extensions</code> package.</p>"},{"location":"mypy/literal_and_enum/#\u53c2\u6570\u5316\u5b57\u9762\u91cf","title":"\u53c2\u6570\u5316\u5b57\u9762\u91cf","text":"<p>Parameterizing Literals</p> \u4e2d\u6587\u82f1\u6587 <p>\u5b57\u9762\u91cf\u7c7b\u578b\u53ef\u4ee5\u5305\u542b\u4e00\u4e2a\u6216\u591a\u4e2a\u6587\u5b57 bool\u3001int\u3001str\u3001byte \u548c enum \u503c\u3002 \u4f46\u662f\uff0c\u5b57\u9762\u91cf\u7c7b\u578b\u4e0d\u80fd\u5305\u542b\u4efb\u610f\u8868\u8fbe\u5f0f\uff1a\u8bf8\u5982\u201cLiteral[my_string.trim()]\u201d\u3001\u201cLiteral[x &gt; 3]\u201d\u6216\u201cLiteral[3j + 4]\u201d\u4e4b\u7c7b\u7684\u7c7b\u578b\u90fd\u662f\u975e\u6cd5\u7684\u3002</p> <p>\u5305\u542b\u4e24\u4e2a\u6216\u591a\u4e2a\u503c\u7684\u6587\u5b57\u76f8\u5f53\u4e8e\u8fd9\u4e9b\u503c\u7684\u5e76\u96c6\u3002 \u56e0\u6b64\uff0c <code>Literal[-3, b\"foo\", MyEnum.A]</code> \u76f8\u5f53\u4e8e <code>Union[Literal[-3], Literal[b] \u201cfoo\u201d]\uff0c</code>Literal[[MyEnum.A]]`\u3002 \u8fd9\u4f7f\u5f97\u7f16\u5199\u6d89\u53ca\u6587\u5b57\u7684\u66f4\u590d\u6742\u7684\u7c7b\u578b\u53d8\u5f97\u66f4\u52a0\u65b9\u4fbf\u3002</p> <p>\u5b57\u9762\u91cf\u7c7b\u578b\u4e5f\u53ef\u80fd\u5305\u542b\u201cNone\u201d\u3002 Mypy \u4f1a\u5c06 <code>Literal[None]</code> \u89c6\u4e3a\u7b49\u540c\u4e8e <code>None</code>\u3002 \u8fd9\u610f\u5473\u7740 <code>Literal[4, None]</code>\u3001<code>Union[Literal[4], None]</code> \u548c <code>Optional[Literal[4]]</code> \u90fd\u662f\u7b49\u4ef7\u7684\u3002</p> <p>\u6587\u5b57\u8fd8\u53ef\u4ee5\u5305\u542b\u5176\u4ed6\u5b57\u9762\u91cf\u7c7b\u578b\u7684\u522b\u540d\u3002 \u4f8b\u5982\uff0c\u4ee5\u4e0b\u7a0b\u5e8f\u662f\u5408\u6cd5\u7684\uff1a</p> <pre><code>PrimaryColors = Literal[\"red\", \"blue\", \"yellow\"]\nSecondaryColors = Literal[\"purple\", \"green\", \"orange\"]\nAllowedColors = Literal[PrimaryColors, SecondaryColors]\n\ndef paint(color: AllowedColors) -&gt; None: ...\n\npaint(\"red\")        # Type checks!\npaint(\"turquoise\")  # Does not type check\n</code></pre> <p>\u5b57\u9762\u91cf\u4e0d\u80fd\u5305\u542b\u4efb\u4f55\u5176\u4ed6\u7c7b\u578b\u6216\u8868\u8fbe\u5f0f\u3002 \u8fd9\u610f\u5473\u7740\u6267\u884c <code>Literal[my_instance]</code>\u3001<code>Literal[Any]</code>\u3001<code>Literal[3.14]</code> \u6216 <code>Literal[{\"foo\": 2, \"bar\": 5}]</code> \u90fd\u662f\u975e\u6cd5\u7684\u3002</p> <p>Literal types may contain one or more literal bools, ints, strs, bytes, and enum values. However, literal types cannot contain arbitrary expressions: types like <code>Literal[my_string.trim()]</code>, <code>Literal[x &gt; 3]</code>, or <code>Literal[3j + 4]</code> are all illegal.</p> <p>Literals containing two or more values are equivalent to the union of those values.= So, <code>Literal[-3, b\"foo\", MyEnum.A]</code> is equivalent to= <code>Union[Literal[-3], Literal[b\"foo\"], Literal[MyEnum.A]]</code>. This makes writing more= complex types involving literals a little more convenient.</p> <p>Literal types may also contain <code>None</code>. Mypy will treat <code>Literal[None]</code> as being equivalent to just <code>None</code>. This means that <code>Literal[4, None]</code>, <code>Union[Literal[4], None]</code>, and <code>Optional[Literal[4]]</code> are all equivalent.</p> <p>Literals may also contain aliases to other literal types. For example, the following program is legal:</p> <pre><code>PrimaryColors = Literal[\"red\", \"blue\", \"yellow\"]\nSecondaryColors = Literal[\"purple\", \"green\", \"orange\"]\nAllowedColors = Literal[PrimaryColors, SecondaryColors]\n\ndef paint(color: AllowedColors) -&gt; None: ...\n\npaint(\"red\")        # Type checks!\npaint(\"turquoise\")  # Does not type check\n</code></pre> <p>Literals may not contain any other kind of type or expression. This means doing <code>Literal[my_instance]</code>, <code>Literal[Any]</code>, <code>Literal[3.14]</code>, or <code>Literal[{\"foo\": 2, \"bar\": 5}]</code> are all illegal.</p>"},{"location":"mypy/literal_and_enum/#\u58f0\u660e\u5b57\u9762\u91cf","title":"\u58f0\u660e\u5b57\u9762\u91cf","text":"<p>Declaring literal variables</p> \u4e2d\u6587\u82f1\u6587 <p>\u60a8\u5fc5\u987b\u663e\u5f0f\u5411\u53d8\u91cf\u6dfb\u52a0\u6ce8\u91ca\u4ee5\u58f0\u660e\u5b83\u5177\u6709\u5b57\u9762\u91cf\u7c7b\u578b\uff1a</p> <pre><code>a: Literal[19] = 19\nreveal_type(a)          # Revealed type is \"Literal[19]\"\n</code></pre> <p>\u4e3a\u4e86\u4fdd\u6301\u5411\u540e\u517c\u5bb9\u6027\uff0c\u6ca1\u6709\u6b64\u6ce8\u89e3\u7684\u53d8\u91cf\u4e0d\u5047\u5b9a\u4e3a\u5b57\u9762\u91cf\uff1a</p> <pre><code>b = 19\nreveal_type(b)          # Revealed type is \"int\"\n</code></pre> <p>\u5982\u679c\u60a8\u53d1\u73b0\u5728\u7c7b\u578b\u63d0\u793a\u4e2d\u91cd\u590d\u53d8\u91cf\u7684\u503c\u5f88\u4e4f\u5473\uff0c\u60a8\u53ef\u4ee5\u5c06\u53d8\u91cf\u66f4\u6539\u4e3a\u201cFinal\u201d\uff08\u8bf7\u53c2\u9605\u201cfinal_attrs\u201d\uff09\uff1a</p> <pre><code>from typing import Final, Literal\n\ndef expects_literal(x: Literal[19]) -&gt; None: pass\n\nc: Final = 19\n\nreveal_type(c)          # Revealed type is \"Literal[19]?\"\nexpects_literal(c)      # ...and this type checks!\n</code></pre> <p>\u5982\u679c\u60a8\u6ca1\u6709\u5728 \u201cFinal\u201d \u4e2d\u63d0\u4f9b\u663e\u5f0f\u7c7b\u578b\uff0c\u5219 \u201cc\u201d \u7684\u7c7b\u578b\u5c06\u53d8\u4e3a\u4e0a\u4e0b\u6587\u76f8\u5173\uff1a\u5728\u6267\u884c\u7c7b\u578b\u68c0\u67e5\u4e4b\u524d\uff0c\u53ea\u8981\u4f7f\u7528\u539f\u59cb\u5206\u914d\u7684\u503c\uff0cmypy \u57fa\u672c\u4e0a\u90fd\u4f1a\u5c1d\u8bd5\u201c\u66ff\u6362\u201d\u539f\u59cb\u5206\u914d\u7684\u503c\u3002 \u8fd9\u5c31\u662f\u4e3a\u4ec0\u4e48 <code>c</code> \u7684\u663e\u793a\u7c7b\u578b\u662f <code>Literal[19]?</code>\uff1a\u672b\u5c3e\u7684\u95ee\u53f7\u53cd\u6620\u4e86\u8fd9\u79cd\u4e0a\u4e0b\u6587\u76f8\u5173\u7684\u6027\u8d28\u3002</p> <p>\u4f8b\u5982\uff0cmypy \u5c06\u5bf9\u4e0a\u8ff0\u7a0b\u5e8f\u8fdb\u884c\u7c7b\u578b\u68c0\u67e5\uff0c\u51e0\u4e4e\u5c31\u50cf\u8fd9\u6837\u7f16\u5199\u7684\uff1a</p> <pre><code>from typing import Final, Literal\n\ndef expects_literal(x: Literal[19]) -&gt; None: pass\n\nreveal_type(19)\nexpects_literal(19)\n</code></pre> <p>\u8fd9\u610f\u5473\u7740\u867d\u7136\u5c06\u53d8\u91cf\u66f4\u6539\u4e3a\u201cFinal\u201d\u4e0e\u6dfb\u52a0\u663e\u5f0f\u201cLiteral[...]\u201d\u6ce8\u91ca\u5e76\u4e0d\u5b8c\u5168\u76f8\u540c\uff0c\u4f46\u5728\u5b9e\u8df5\u4e2d\u901a\u5e38\u4f1a\u4ea7\u751f\u76f8\u540c\u7684\u6548\u679c\u3002</p> <p>\u4e0a\u4e0b\u6587\u76f8\u5173\u7c7b\u578b\u4e0e\u771f\u5b9e\u5b57\u9762\u91cf\u7c7b\u578b\u7684\u884c\u4e3a\u4e0d\u540c\u7684\u4e3b\u8981\u60c5\u51b5\u662f\u5f53\u60a8\u5c1d\u8bd5\u5728\u672a\u660e\u786e\u671f\u671b\u201cLiteral[...]\u201d\u7684\u5730\u65b9\u4f7f\u7528\u8fd9\u4e9b\u7c7b\u578b\u65f6\u3002 \u4f8b\u5982\uff0c\u6bd4\u8f83\u548c\u5bf9\u6bd4\u5f53\u60a8\u5c1d\u8bd5\u5c06\u8fd9\u4e9b\u7c7b\u578b\u9644\u52a0\u5230\u5217\u8868\u65f6\u4f1a\u53d1\u751f\u4ec0\u4e48\uff1a</p> <pre><code>from typing import Final, Literal\n\na: Final = 19\nb: Literal[19] = 19\n\n# Mypy \u4f1a\u9009\u62e9\u5728\u8fd9\u91cc\u63a8\u65ad list[int]\u3002\nlist_of_ints = []\nlist_of_ints.append(a)\nreveal_type(list_of_ints)  # Revealed type is \"list[int]\"\n\n# \u4f46\u662f\uff0c\u5982\u679c\u60a8\u8981\u9644\u52a0\u7684\u53d8\u91cf\u662f\u663e\u5f0f\u6587\u5b57\uff0c\u5219 mypy \u5c06\u63a8\u65ad list[Literal[19]]\u3002\nlist_of_lits = []\nlist_of_lits.append(b)\nreveal_type(list_of_lits)  # Revealed type is \"list[Literal[19]]\"\n</code></pre> <p>You must explicitly add an annotation to a variable to declare that it has a literal type:</p> <pre><code>a: Literal[19] = 19\nreveal_type(a)          # Revealed type is \"Literal[19]\"\n</code></pre> <p>In order to preserve backwards-compatibility, variables without this annotation are not assumed to be literals:</p> <pre><code>b = 19\nreveal_type(b)          # Revealed type is \"int\"\n</code></pre> <p>If you find repeating the value of the variable in the type hint to be tedious, you can instead change the variable to be <code>Final</code> (see <code>final_attrs</code>):</p> <pre><code>from typing import Final, Literal\n\ndef expects_literal(x: Literal[19]) -&gt; None: pass\n\nc: Final = 19\n\nreveal_type(c)          # Revealed type is \"Literal[19]?\"\nexpects_literal(c)      # ...and this type checks!\n</code></pre> <p>If you do not provide an explicit type in the <code>Final</code>, the type of <code>c</code> becomes context-sensitive: mypy will basically try \"substituting\" the original assigned value whenever it's used before performing type checking. This is why the revealed type of <code>c</code> is <code>Literal[19]?</code>: the question mark at the end reflects this context-sensitive nature.</p> <p>For example, mypy will type check the above program almost as if it were written like so:</p> <pre><code>from typing import Final, Literal\n\ndef expects_literal(x: Literal[19]) -&gt; None: pass\n\nreveal_type(19)\nexpects_literal(19)\n</code></pre> <p>This means that while changing a variable to be <code>Final</code> is not quite the same thing as adding an explicit <code>Literal[...]</code> annotation, it often leads to the same effect in practice.</p> <p>The main cases where the behavior of context-sensitive vs true literal types differ are when you try using those types in places that are not explicitly expecting a <code>Literal[...]</code>. For example, compare and contrast what happens when you try appending these types to a list:</p> <pre><code>from typing import Final, Literal\n\na: Final = 19\nb: Literal[19] = 19\n\n# Mypy will choose to infer list[int] here.\nlist_of_ints = []\nlist_of_ints.append(a)\nreveal_type(list_of_ints)  # Revealed type is \"list[int]\"\n\n# But if the variable you're appending is an explicit Literal, mypy\n# will infer list[Literal[19]].\nlist_of_lits = []\nlist_of_lits.append(b)\nreveal_type(list_of_lits)  # Revealed type is \"list[Literal[19]]\"\n</code></pre>"},{"location":"mypy/literal_and_enum/#\u667a\u80fd\u7d22\u5f15","title":"\u667a\u80fd\u7d22\u5f15","text":"<p>Intelligent indexing</p> \u4e2d\u6587\u82f1\u6587 <p>\u6211\u4eec\u53ef\u4ee5\u4f7f\u7528 Literal \u7c7b\u578b\u66f4\u7cbe\u786e\u5730\u7d22\u5f15\u5230\u7ed3\u6784\u5316\u5f02\u6784\u7c7b\u578b\uff0c\u4f8b\u5982\u5143\u7ec4\u3001NamedTuples \u548c TypedDicts\u3002 \u6b64\u529f\u80fd\u79f0\u4e3a\u201c\u667a\u80fd\u7d22\u5f15\u201d\u3002</p> <p>\u4f8b\u5982\uff0c\u5f53\u6211\u4eec\u4f7f\u7528\u67d0\u4e9b int \u7d22\u5f15\u5143\u7ec4\u65f6\uff0c\u63a8\u65ad\u7684\u7c7b\u578b\u901a\u5e38\u662f\u5143\u7ec4\u9879\u7c7b\u578b\u7684\u5e76\u96c6\u3002 \u4f46\u662f\uff0c\u5982\u679c\u6211\u4eec\u53ea\u60f3\u8981\u4e0e\u67d0\u4e2a\u7279\u5b9a\u7d22\u5f15\u76f8\u5bf9\u5e94\u7684\u7c7b\u578b\uff0c\u6211\u4eec\u53ef\u4ee5\u4f7f\u7528\u5b57\u9762\u91cf\u7c7b\u578b\uff0c\u5982\u4e0b\u6240\u793a\uff1a</p> <pre><code>from typing import TypedDict\n\ntup = (\"foo\", 3.4)\n\n# \u4f7f\u7528 int \u6587\u5b57\u8fdb\u884c\u7d22\u5f15\u53ef\u4ee5\u4e3a\u6211\u4eec\u63d0\u4f9b\u8be5\u7d22\u5f15\u7684\u786e\u5207\u7c7b\u578b\nreveal_type(tup[0])  # Revealed type is \"str\"\n\n# \u4f46\u662f\u5982\u679c\u6211\u4eec\u5e0c\u671b\u7d22\u5f15\u662f\u4e00\u4e2a\u53d8\u91cf\u600e\u4e48\u529e\uff1f \u901a\u5e38 mypy \u4e0d\u4f1a\u786e\u5207\u77e5\u9053\u7d22\u5f15\u662f\u4ec0\u4e48\uff0c\u56e0\u6b64\u4f1a\u8fd4\u56de\u4e0d\u592a\u7cbe\u786e\u7684\u7c7b\u578b\uff1a\nint_index = 0\nreveal_type(tup[int_index])  # Revealed type is \"Union[str, float]\"\n\n# \u4f46\u662f\u5982\u679c\u6211\u4eec\u4f7f\u7528 Literal \u7c7b\u578b\u6216 Final int\uff0c\u6211\u4eec\u5c31\u53ef\u4ee5\u6062\u590d\u539f\u6765\u7684\u7cbe\u5ea6\uff1a\nlit_index: Literal[0] = 0\nfin_index: Final = 0\nreveal_type(tup[lit_index])  # Revealed type is \"str\"\nreveal_type(tup[fin_index])  # Revealed type is \"str\"\n\n# \u6211\u4eec\u53ef\u4ee5\u4f7f\u7528 TypedDict \u548c str \u952e\u505a\u540c\u6837\u7684\u4e8b\u60c5\uff1a\nclass MyDict(TypedDict):\n    name: str\n    main_id: int\n    backup_id: int\n\nd: MyDict = {\"name\": \"Saanvi\", \"main_id\": 111, \"backup_id\": 222}\nname_key: Final = \"name\"\nreveal_type(d[name_key])  # Revealed type is \"str\"\n\n# \u60a8\u8fd8\u53ef\u4ee5\u4f7f\u7528\u5b57\u9762\u91cf\u8054\u5408\u8fdb\u884c\u7d22\u5f15\nid_key: Literal[\"main_id\", \"backup_id\"]\nreveal_type(d[id_key])    # Revealed type is \"int\"\n</code></pre> <p>We can use Literal types to more precisely index into structured heterogeneous types such as tuples, NamedTuples, and TypedDicts. This feature is known as intelligent indexing.</p> <p>For example, when we index into a tuple using some int, the inferred type is normally the union of the tuple item types. However, if we want just the type corresponding to some particular index, we can use Literal types like so:</p> <pre><code>from typing import TypedDict\n\ntup = (\"foo\", 3.4)\n\n# Indexing with an int literal gives us the exact type for that index\nreveal_type(tup[0])  # Revealed type is \"str\"\n\n# But what if we want the index to be a variable? Normally mypy won't\n# know exactly what the index is and so will return a less precise type:\nint_index = 0\nreveal_type(tup[int_index])  # Revealed type is \"Union[str, float]\"\n\n# But if we use either Literal types or a Final int, we can gain back\n# the precision we originally had:\nlit_index: Literal[0] = 0\nfin_index: Final = 0\nreveal_type(tup[lit_index])  # Revealed type is \"str\"\nreveal_type(tup[fin_index])  # Revealed type is \"str\"\n\n# We can do the same thing with with TypedDict and str keys:\nclass MyDict(TypedDict):\n    name: str\n    main_id: int\n    backup_id: int\n\nd: MyDict = {\"name\": \"Saanvi\", \"main_id\": 111, \"backup_id\": 222}\nname_key: Final = \"name\"\nreveal_type(d[name_key])  # Revealed type is \"str\"\n\n# You can also index using unions of literals\nid_key: Literal[\"main_id\", \"backup_id\"]\nreveal_type(d[id_key])    # Revealed type is \"int\"\n</code></pre>"},{"location":"mypy/literal_and_enum/#\u6807\u8bb0\u8054\u5408\u7c7b\u578b","title":"\u6807\u8bb0\u8054\u5408\u7c7b\u578b","text":"<p>Tagged unions</p> \u4e2d\u6587\u82f1\u6587 <p>\u5f53\u60a8\u6709\u7c7b\u578b\u7684\u8054\u5408\u65f6\uff0c\u901a\u5e38\u53ef\u4ee5\u4f7f\u7528\u201cisinstance\u201d\u68c0\u67e5\u6765\u533a\u5206\u8054\u5408\u4e2d\u7684\u6bcf\u79cd\u7c7b\u578b\u3002 \u4f8b\u5982\uff0c\u5982\u679c\u60a8\u6709\u4e00\u4e2a\u7c7b\u578b\u4e3a\u201cUnion[int, str]\u201d\u7684\u53d8\u91cf\u201cx\u201d\uff0c\u60a8\u53ef\u4ee5\u901a\u8fc7\u6267\u884c\u201cif isinstance(x, int): ..\u201d\u6765\u7f16\u5199\u4e00\u4e9b\u4ec5\u5f53\u201cx\u201d\u662f int \u65f6\u624d\u8fd0\u884c\u7684\u4ee3\u7801\u3002 .`.</p> <p>\u7136\u800c\uff0c\u8fd9\u6837\u505a\u5e76\u4e0d\u603b\u662f\u53ef\u80fd\u6216\u65b9\u4fbf\u3002 \u4f8b\u5982\uff0c\u4e0d\u53ef\u80fd\u4f7f\u7528\u201cisinstance\u201d\u6765\u533a\u5206\u4e24\u4e2a\u4e0d\u540c\u7684 TypedDict\uff0c\u56e0\u4e3a\u5728\u8fd0\u884c\u65f6\uff0c\u60a8\u7684\u53d8\u91cf\u53ea\u662f\u4e00\u4e2a\u5b57\u5178\u3002</p> <p>\u76f8\u53cd\uff0c\u60a8\u53ef\u4ee5\u505a\u7684\u662f\u4f7f\u7528\u4e0d\u540c\u7684\u6587\u5b57\u7c7b\u578b\u6807\u7b7e\u6216\u6807\u8bb0\u60a8\u7684 TypedDicts\u3002 \u7136\u540e\uff0c\u60a8\u53ef\u4ee5\u901a\u8fc7\u68c0\u67e5\u6807\u7b7e\u6765\u533a\u5206\u6bcf\u79cd TypedDict\uff1a</p> <pre><code>from typing import Literal, TypedDict, Union\n\nclass NewJobEvent(TypedDict):\n    tag: Literal[\"new-job\"]\n    job_name: str\n    config_file_path: str\n\nclass CancelJobEvent(TypedDict):\n    tag: Literal[\"cancel-job\"]\n    job_id: int\n\nEvent = Union[NewJobEvent, CancelJobEvent]\n\ndef process_event(event: Event) -&gt; None:\n    # \u7531\u4e8e\u6211\u4eec\u786e\u4fdd\u4e24\u4e2a TypedDict \u90fd\u6709\u4e00\u4e2a\u540d\u4e3a\u201ctag\u201d\u7684\u952e\uff0c\u56e0\u6b64\u6267\u884c\u201cevent[\u201ctag\u201d]\u201d\u662f\u5b89\u5168\u7684\u3002 \n    # \u8be5\u8868\u8fbe\u5f0f\u901a\u5e38\u5177\u6709 Literal[\"new-job\", \"cancel-job\"] \u7c7b\u578b\uff0c\n    # \u4f46\u4e0b\u9762\u7684\u68c0\u67e5\u4f1a\u5c06\u7c7b\u578b\u8303\u56f4\u7f29\u5c0f\u4e3a Literal[\"new-job\"] \u6216 Literal[\"cancel-job\"]\u3002\n    #\n    # \u8fd9\u53c8\u5c06\u201cevent\u201d\u7684\u7c7b\u578b\u7f29\u5c0f\u4e3a NewJobEvent \u6216 CancelJobEvent\u3002\n    if event[\"tag\"] == \"new-job\":\n        print(event[\"job_name\"])\n    else:\n        print(event[\"job_id\"])\n</code></pre> <p>\u867d\u7136\u6b64\u529f\u80fd\u5728\u4f7f\u7528 TypedDicts \u65f6\u975e\u5e38\u6709\u7528\uff0c\u4f46\u60a8\u4e5f\u53ef\u4ee5\u5bf9\u5e38\u89c4\u5bf9\u8c61\u3001\u5143\u7ec4\u6216\u547d\u540d\u5143\u7ec4\u4f7f\u7528\u76f8\u540c\u7684\u6280\u672f\u3002</p> <p>\u7c7b\u4f3c\u5730\uff0c\u6807\u7b7e\u4e0d\u9700\u8981\u662f\u4e13\u95e8\u7684 str \u6587\u5b57\uff1a\u5b83\u4eec\u53ef\u4ee5\u662f\u60a8\u901a\u5e38\u53ef\u4ee5\u5728\u201cif\u201d\u8bed\u53e5\u7b49\u4e2d\u7f29\u5c0f\u8303\u56f4\u7684\u4efb\u4f55\u7c7b\u578b\u3002  \u4f8b\u5982\uff0c\u60a8\u53ef\u4ee5\u5c06\u6807\u7b7e\u8bbe\u7f6e\u4e3a int \u6216 Enum Literals\uff0c\u751a\u81f3\u53ef\u4ee5\u4f7f\u7528\u201cisinstance()\u201d\u7f29\u5c0f\u5e38\u89c4\u7c7b\uff1a</p> <pre><code>from typing import Generic, TypeVar, Union\n\nT = TypeVar('T')\n\nclass Wrapper(Generic[T]):\n    def __init__(self, inner: T) -&gt; None:\n        self.inner = inner\n\ndef process(w: Union[Wrapper[int], Wrapper[str]]) -&gt; None:\n    # \u6267\u884c\u201cif isinstance(w, Wrapper[int])\u201d\u4e0d\u8d77\u4f5c\u7528\uff1aisinstance \u8981\u6c42\u7b2c\u4e8c\u4e2a\u53c2\u6570\u59cb\u7ec8\u662f*\u5df2\u5220\u9664\u7684*\u7c7b\u578b\uff0c\u6ca1\u6709\u6cdb\u578b\u3002 \u8fd9\u662f\u56e0\u4e3a\u6cdb\u578b\u662f\u4e00\u4e2a\u4ec5\u8f93\u5165\u7684\u6982\u5ff5\uff0c\u5e76\u4e14\u5728\u8fd0\u884c\u65f6\u4e0d\u4ee5\u201cisinstance\u201d\u59cb\u7ec8\u53ef\u4ee5\u68c0\u67e5\u7684\u65b9\u5f0f\u5b58\u5728\u3002\n    #\n    # \u7136\u800c\uff0c\u6211\u4eec\u53ef\u4ee5\u901a\u8fc7\u68c0\u67e5\u201cw.inner\u201d\u7684\u7c7b\u578b\u6765\u7f29\u5c0f\u201cw\u201d\u672c\u8eab\u6765\u56de\u907f\u8fd9\u4e2a\u95ee\u9898\uff1a\n    if isinstance(w.inner, int):\n        reveal_type(w)  # Revealed type is \"Wrapper[int]\"\n    else:\n        reveal_type(w)  # Revealed type is \"Wrapper[str]\"\n</code></pre> <p>\u5728\u5176\u4ed6\u7f16\u7a0b\u8bed\u8a00\u4e2d\uff0c\u6b64\u529f\u80fd\u6709\u65f6\u79f0\u4e3a\u201c\u6c42\u548c\u7c7b\u578b\u201d\u6216\u201c\u53ef\u533a\u5206\u8054\u5408\u7c7b\u578b\u201d\u3002</p> <p>When you have a union of types, you can normally discriminate between each type in the union by using <code>isinstance</code> checks. For example, if you had a variable <code>x</code> of type <code>Union[int, str]</code>, you could write some code that runs only if <code>x</code> is an int by doing <code>if isinstance(x, int): ...</code>.</p> <p>However, it is not always possible or convenient to do this. For example, it is not possible to use <code>isinstance</code> to distinguish between two different TypedDicts since at runtime, your variable will simply be just a dict.</p> <p>Instead, what you can do is label or tag your TypedDicts with a distinct Literal type. Then, you can discriminate between each kind of TypedDict by checking the label:</p> <pre><code>from typing import Literal, TypedDict, Union\n\nclass NewJobEvent(TypedDict):\n    tag: Literal[\"new-job\"]\n    job_name: str\n    config_file_path: str\n\nclass CancelJobEvent(TypedDict):\n    tag: Literal[\"cancel-job\"]\n    job_id: int\n\nEvent = Union[NewJobEvent, CancelJobEvent]\n\ndef process_event(event: Event) -&gt; None:\n    # Since we made sure both TypedDicts have a key named 'tag', it's\n    # safe to do 'event[\"tag\"]'. This expression normally has the type\n    # Literal[\"new-job\", \"cancel-job\"], but the check below will narrow\n    # the type to either Literal[\"new-job\"] or Literal[\"cancel-job\"].\n    #\n    # This in turns narrows the type of 'event' to either NewJobEvent\n    # or CancelJobEvent.\n    if event[\"tag\"] == \"new-job\":\n        print(event[\"job_name\"])\n    else:\n        print(event[\"job_id\"])\n</code></pre> <p>While this feature is mostly useful when working with TypedDicts, you can also use the same technique with regular objects, tuples, or namedtuples.</p> <p>Similarly, tags do not need to be specifically str Literals: they can be any type you can normally narrow within <code>if</code> statements and the like. For example, you could have your tags be int or Enum Literals or even regular classes you narrow using <code>isinstance()</code>:</p> <pre><code>from typing import Generic, TypeVar, Union\n\nT = TypeVar('T')\n\nclass Wrapper(Generic[T]):\n    def __init__(self, inner: T) -&gt; None:\n        self.inner = inner\n\ndef process(w: Union[Wrapper[int], Wrapper[str]]) -&gt; None:\n    # Doing `if isinstance(w, Wrapper[int])` does not work: isinstance requires\n    # that the second argument always be an *erased* type, with no generics.\n    # This is because generics are a typing-only concept and do not exist at\n    # runtime in a way `isinstance` can always check.\n    #\n    # However, we can side-step this by checking the type of `w.inner` to\n    # narrow `w` itself:\n    if isinstance(w.inner, int):\n        reveal_type(w)  # Revealed type is \"Wrapper[int]\"\n    else:\n        reveal_type(w)  # Revealed type is \"Wrapper[str]\"\n</code></pre> <p>This feature is sometimes called \"sum types\" or \"discriminated union types\" in other programming languages.</p>"},{"location":"mypy/literal_and_enum/#\u8be6\u5c3d\u6027\u68c0\u67e5","title":"\u8be6\u5c3d\u6027\u68c0\u67e5","text":"<p>Exhaustiveness checking</p> \u4e2d\u6587\u82f1\u6587 <p>\u60a8\u53ef\u80fd\u60f3\u8981\u68c0\u67e5\u67d0\u4e9b\u4ee3\u7801\u662f\u5426\u6db5\u76d6\u4e86\u6240\u6709\u53ef\u80fd\u7684\u201cLiteral\u201d\u6216\u201cEnum\u201d\u60c5\u51b5\u3002 \u4f8b\u5b50\uff1a</p> <pre><code>from typing import Literal\n\nPossibleValues = Literal['one', 'two']\n\ndef validate(x: PossibleValues) -&gt; bool:\n    if x == 'one':\n        return True\n    elif x == 'two':\n        return False\n    raise ValueError(f'Invalid value: {x}')\n\nassert validate('one') is True\nassert validate('two') is False\n</code></pre> <p>\u4e0a\u9762\u7684\u4ee3\u7801\u5f88\u5bb9\u6613\u51fa\u9519\u3002 \u60a8\u53ef\u4ee5\u5411\u201cPossibleValues\u201d\u6dfb\u52a0\u4e00\u4e2a\u65b0\u7684\u6587\u5b57\u503c\uff0c\u4f46\u5fd8\u8bb0\u5728\u201cvalidate\u201d\u51fd\u6570\u4e2d\u5904\u7406\u5b83\uff1a</p> <pre><code>PossibleValues = Literal['one', 'two', 'three']\n</code></pre> <p>Mypy \u4e0d\u4f1a\u53d1\u73b0\u201cthree\u201d\u672a\u88ab\u8986\u76d6\u3002 \u5982\u679c\u60a8\u5e0c\u671b mypy \u6267\u884c\u8be6\u5c3d\u68c0\u67e5\uff0c\u5219\u9700\u8981\u66f4\u65b0\u4ee3\u7801\u4ee5\u4f7f\u7528 <code>assert_never()</code> \u68c0\u67e5\uff1a</p> <pre><code>from typing import Literal, NoReturn\n\nPossibleValues = Literal['one', 'two']\n\ndef assert_never(value: NoReturn) -&gt; NoReturn:\n    # \u8fd9\u5728\u8fd0\u884c\u65f6\u4e5f\u6709\u6548\n    assert False, f'This code should never be reached, got: {value}'\n\ndef validate(x: PossibleValues) -&gt; bool:\n    if x == 'one':\n        return True\n    elif x == 'two':\n        return False\n    assert_never(x)\n</code></pre> <p>\u73b0\u5728\uff0c\u5982\u679c\u60a8\u5411\u201cPossibleValues\u201d\u6dfb\u52a0\u65b0\u503c\u4f46\u4e0d\u66f4\u65b0\u201cvalidate\u201d\uff0cmypy \u5c06\u53d1\u73b0\u9519\u8bef\uff1a</p> <pre><code>PossibleValues = Literal['one', 'two', 'three']\n\ndef validate(x: PossibleValues) -&gt; bool:\n    if x == 'one':\n        return True\n    elif x == 'two':\n        return False\n    # Error: Argument 1 to \"assert_never\" has incompatible type \"Literal['three']\";\n    # expected \"NoReturn\"\n    assert_never(x)\n</code></pre> <p>\u5982\u679c\u4e0d\u9700\u8981\u8fd0\u884c\u65f6\u68c0\u67e5\u610f\u5916\u503c\uff0c\u5219\u53ef\u4ee5\u7701\u7565\u4e0a\u9762\u793a\u4f8b\u4e2d\u7684\u201cassert_never\u201d\u8c03\u7528\uff0c\u5e76\u4e14 mypy \u4ecd\u4f1a\u751f\u6210\u6709\u5173\u51fd\u6570\u201cvalidate\u201d\u8fd4\u56de\u65e0\u503c\u7684\u9519\u8bef\uff1a</p> <pre><code>PossibleValues = Literal['one', 'two', 'three']\n\n# Error: Missing return statement\ndef validate(x: PossibleValues) -&gt; bool:\n    if x == 'one':\n        return True\n    elif x == 'two':\n        return False\n</code></pre> <p>\u5339\u914d\u8bed\u53e5\u4e5f\u652f\u6301\u8be6\u5c3d\u68c0\u67e5\uff08Python 3.10 \u53ca\u66f4\u9ad8\u7248\u672c\uff09\uff1a</p> <pre><code>def validate(x: PossibleValues) -&gt; bool:\n    match x:\n        case 'one':\n            return True\n        case 'two':\n            return False\n    assert_never(x)\n</code></pre> <p>You may want to check that some code covers all possible <code>Literal</code> or <code>Enum</code> cases. Example:</p> <pre><code>from typing import Literal\n\nPossibleValues = Literal['one', 'two']\n\ndef validate(x: PossibleValues) -&gt; bool:\n    if x == 'one':\n        return True\n    elif x == 'two':\n        return False\n    raise ValueError(f'Invalid value: {x}')\n\nassert validate('one') is True\nassert validate('two') is False\n</code></pre> <p>In the code above, it's easy to make a mistake. You can add a new literal value to <code>PossibleValues</code> but forget to handle it in the <code>validate</code> function:</p> <pre><code>PossibleValues = Literal['one', 'two', 'three']\n</code></pre> <p>Mypy won't catch that <code>'three'</code> is not covered.  If you want mypy to perform an exhaustiveness check, you need to update your code to use an <code>assert_never()</code> check:</p> <pre><code>from typing import Literal, NoReturn\n\nPossibleValues = Literal['one', 'two']\n\ndef assert_never(value: NoReturn) -&gt; NoReturn:\n    # This also works at runtime as well\n    assert False, f'This code should never be reached, got: {value}'\n\ndef validate(x: PossibleValues) -&gt; bool:\n    if x == 'one':\n        return True\n    elif x == 'two':\n        return False\n    assert_never(x)\n</code></pre> <p>Now if you add a new value to <code>PossibleValues</code> but don't update <code>validate</code>, mypy will spot the error:</p> <pre><code>PossibleValues = Literal['one', 'two', 'three']\n\ndef validate(x: PossibleValues) -&gt; bool:\n    if x == 'one':\n        return True\n    elif x == 'two':\n        return False\n    # Error: Argument 1 to \"assert_never\" has incompatible type \"Literal['three']\";\n    # expected \"NoReturn\"\n    assert_never(x)\n</code></pre> <p>If runtime checking against unexpected values is not needed, you can leave out the <code>assert_never</code> call in the above example, and mypy will still generate an error about function <code>validate</code> returning without a value:</p> <pre><code>PossibleValues = Literal['one', 'two', 'three']\n\n# Error: Missing return statement\ndef validate(x: PossibleValues) -&gt; bool:\n    if x == 'one':\n        return True\n    elif x == 'two':\n        return False\n</code></pre> <p>Exhaustiveness checking is also supported for match statements (Python 3.10 and later):</p> <pre><code>def validate(x: PossibleValues) -&gt; bool:\n    match x:\n        case 'one':\n            return True\n        case 'two':\n            return False\n    assert_never(x)\n</code></pre>"},{"location":"mypy/literal_and_enum/#\u5c40\u9650\u6027","title":"\u5c40\u9650\u6027","text":"<p>Limitations</p> \u4e2d\u6587\u82f1\u6587 <p>Mypy \u65e0\u6cd5\u6df1\u5165\u7406\u89e3\u4f7f\u7528\u201cLiteral[..]\u201d\u7c7b\u578b\u53d8\u91cf\u7684\u8868\u8fbe\u5f0f\u3002 \u4f8b\u5982\uff0c\u5982\u679c\u60a8\u6709\u4e00\u4e2a\u7c7b\u578b\u4e3a\u201cLiteral[3]\u201d\u7684\u53d8\u91cf\u201ca\u201d\u548c\u53e6\u4e00\u4e2a\u7c7b\u578b\u4e3a\u201cLiteral[5]\u201d\u7684\u53d8\u91cf\u201cb\u201d\uff0cmypy \u5c06\u63a8\u65ad\u201ca + b\u201d\u7684\u7c7b\u578b\u4e3a\u201cint\u201d\uff0c \u4e0d\u662f** \u8f93\u5165 <code>Literal[8]</code>\u3002</p> <p>\u57fa\u672c\u89c4\u5219\u662f\u6587\u5b57\u7c7b\u578b\u88ab\u89c6\u4e3a\u53c2\u6570\u5177\u6709\u7684\u4efb\u4f55\u7c7b\u578b\u7684\u5e38\u89c4\u5b50\u7c7b\u578b\u3002 \u4f8b\u5982\uff0c\u201cLiteral[3]\u201d\u88ab\u89c6\u4e3a\u201cint\u201d\u7684\u5b50\u7c7b\u578b\uff0c\u56e0\u6b64\u5c06\u76f4\u63a5\u7ee7\u627f\u201cint\u201d\u7684\u6240\u6709\u65b9\u6cd5\u3002 \u8fd9\u610f\u5473\u7740 <code>Literal[3].__add__</code> \u63a5\u53d7\u4e0e <code>int.__add__</code> \u76f8\u540c\u7684\u53c2\u6570\u5e76\u5177\u6709\u76f8\u540c\u7684\u8fd4\u56de\u7c7b\u578b\u3002</p> <p>Mypy will not understand expressions that use variables of type <code>Literal[..]</code> on a deep level. For example, if you have a variable <code>a</code> of type <code>Literal[3]</code> and another variable <code>b</code> of type <code>Literal[5]</code>, mypy will infer that <code>a + b</code> has type <code>int</code>, not type <code>Literal[8]</code>.</p> <p>The basic rule is that literal types are treated as just regular subtypes of whatever type the parameter has. For example, <code>Literal[3]</code> is treated as a subtype of <code>int</code> and so will inherit all of <code>int</code>'s methods directly. This means that <code>Literal[3].__add__</code> accepts the same arguments and has the same return type as <code>int.__add__</code>.</p>"},{"location":"mypy/literal_and_enum/#\u679a\u4e3e","title":"\u679a\u4e3e","text":"<p>Enums</p> \u4e2d\u6587\u82f1\u6587 <p>Mypy \u5bf9 <code>enum.Enum</code> \u53ca\u5176\u5b50\u7c7b\u6709\u7279\u6b8a\u652f\u6301: <code>enum.IntEnum</code>, <code>enum.Flag</code>, <code>enum.IntFlag</code>, and <code>enum.StrEnum</code>.</p> <pre><code>from enum import Enum\n\nclass Direction(Enum):\n    up = 'up'\n    down = 'down'\n\nreveal_type(Direction.up)  # Revealed type is \"Literal[Direction.up]?\"\nreveal_type(Direction.down)  # Revealed type is \"Literal[Direction.down]?\"\n</code></pre> <p>You can use enums to annotate types as you would expect:</p> <pre><code>class Movement:\n    def __init__(self, direction: Direction, speed: float) -&gt; None:\n        self.direction = direction\n        self.speed = speed\n\nMovement(Direction.up, 5.0)  # ok\nMovement('up', 5.0)  # E: Argument 1 to \"Movement\" has incompatible type \"str\"; expected \"Direction\"\n</code></pre> <p>Mypy has special support for <code>enum.Enum</code> and its subclasses: <code>enum.IntEnum</code>, <code>enum.Flag</code>, <code>enum.IntFlag</code>, and <code>enum.StrEnum</code>.</p> <pre><code>from enum import Enum\n\nclass Direction(Enum):\n    up = 'up'\n    down = 'down'\n\nreveal_type(Direction.up)  # Revealed type is \"Literal[Direction.up]?\"\nreveal_type(Direction.down)  # Revealed type is \"Literal[Direction.down]?\"\n</code></pre> <p>You can use enums to annotate types as you would expect:</p> <pre><code>class Movement:\n    def __init__(self, direction: Direction, speed: float) -&gt; None:\n        self.direction = direction\n        self.speed = speed\n\nMovement(Direction.up, 5.0)  # ok\nMovement('up', 5.0)  # E: Argument 1 to \"Movement\" has incompatible type \"str\"; expected \"Direction\"\n</code></pre>"},{"location":"mypy/literal_and_enum/#\u8be6\u5c3d\u68c0\u67e5","title":"\u8be6\u5c3d\u68c0\u67e5","text":"<p>Exhaustiveness checking</p> \u4e2d\u6587\u82f1\u6587 <p>\u4e0e\u201cLiteral\u201d\u7c7b\u578b\u7c7b\u4f3c\uff0c\u201cEnum\u201d\u652f\u6301\u8be6\u5c3d\u68c0\u67e5\u3002 \u8ba9\u6211\u4eec\u4ece\u4e00\u4e2a\u5b9a\u4e49\u5f00\u59cb\uff1a</p> <pre><code>from enum import Enum\nfrom typing import NoReturn\n\ndef assert_never(value: NoReturn) -&gt; NoReturn:\n    # \u8fd9\u5728\u8fd0\u884c\u65f6\u4e5f\u6709\u6548\uff1a\n    assert False, f'This code should never be reached, got: {value}'\n\nclass Direction(Enum):\n    up = 'up'\n    down = 'down'\n</code></pre> <p>\u73b0\u5728\uff0c\u8ba9\u6211\u4eec\u4f7f\u7528\u8be6\u5c3d\u68c0\u67e5\uff1a</p> <pre><code>def choose_direction(direction: Direction) -&gt; None:\n    if direction is Direction.up:\n        reveal_type(direction)  # N: Revealed type is \"Literal[Direction.up]\"\n        print('Going up!')\n        return\n    elif direction is Direction.down:\n        print('Down')\n        return\n    # \u8fd9\u6761\u7ebf\u6c38\u8fdc\u4e0d\u4f1a\u5230\u8fbe\n    assert_never(direction)\n</code></pre> <p>\u5982\u679c\u6211\u4eec\u5fd8\u8bb0\u5904\u7406\u5176\u4e2d\u4e00\u79cd\u60c5\u51b5\uff0cmypy \u5c06\u751f\u6210\u9519\u8bef\uff1a</p> <pre><code>def choose_direction(direction: Direction) -&gt; None:\n    if direction == Direction.up:\n        print('Going up!')\n        return\n    assert_never(direction)  # E: Argument 1 to \"assert_never\" has incompatible type \"Direction\"; expected \"NoReturn\"\n</code></pre> <p>\u5339\u914d\u8bed\u53e5\u4e5f\u652f\u6301\u8be6\u5c3d\u68c0\u67e5\uff08Python 3.10 \u53ca\u66f4\u9ad8\u7248\u672c\uff09\u3002</p> <p>You may want to check that some code covers all possible <code>Literal</code> or <code>Enum</code> cases. Example:</p> <pre><code>from enum import Enum\nfrom typing import NoReturn\n\ndef assert_never(value: NoReturn) -&gt; NoReturn:\n    # \u8fd9\u5728\u8fd0\u884c\u65f6\u4e5f\u6709\u6548\uff1a\n    assert False, f'This code should never be reached, got: {value}'\n\nclass Direction(Enum):\n    up = 'up'\n    down = 'down'\n</code></pre> <p>Now, let's use an exhaustiveness check:</p> <pre><code>def choose_direction(direction: Direction) -&gt; None:\n    if direction is Direction.up:\n        reveal_type(direction)  # N: Revealed type is \"Literal[Direction.up]\"\n        print('Going up!')\n        return\n    elif direction is Direction.down:\n        print('Down')\n        return\n    # \u8fd9\u6761\u7ebf\u6c38\u8fdc\u4e0d\u4f1a\u5230\u8fbe\n    assert_never(direction)\n</code></pre> <p>If we forget to handle one of the cases, mypy will generate an error:</p> <pre><code>def choose_direction(direction: Direction) -&gt; None:\n    if direction == Direction.up:\n        print('Going up!')\n        return\n    assert_never(direction)  # E: Argument 1 to \"assert_never\" has incompatible type \"Direction\"; expected \"NoReturn\"\n</code></pre> <p>Exhaustiveness checking is also supported for match statements (Python 3.10 and later).</p>"},{"location":"mypy/literal_and_enum/#\u989d\u5916\u7684\u679a\u4e3e\u68c0\u67e5","title":"\u989d\u5916\u7684\u679a\u4e3e\u68c0\u67e5","text":"<p>Extra Enum checks</p> \u4e2d\u6587\u82f1\u6587 <p>Mypy \u8fd8\u5c1d\u8bd5\u50cf Python \u8fd0\u884c\u65f6\u4e00\u6837\u652f\u6301\u201cEnum\u201d\u7684\u7279\u6b8a\u529f\u80fd\uff1a</p> <ul> <li>\u4efb\u4f55\u5e26\u6709\u503c\u7684\u201cEnum\u201d\u7c7b\u90fd\u662f\u9690\u5f0f\u7684\u201cfinal\u201d. \u8fd9\u662f CPython \u4e2d\u53d1\u751f\u7684\u60c5\u51b5\uff1a</li> </ul> <pre><code>&gt;&gt;&gt; class AllDirection(Direction):\n...     left = 'left'\n...     right = 'right'\nTraceback (most recent call last):\n    ...\nTypeError: AllDirection: cannot extend enumeration 'Direction'\n</code></pre> <p>Mypy \u4e5f\u6355\u83b7\u4e86\u8fd9\u4e2a\u9519\u8bef\uff1a</p> <pre><code>class AllDirection(Direction):  # E: Cannot inherit from final class \"Direction\"\n    left = 'left'\n    right = 'right'\n</code></pre> <p>-\u6240\u6709\u201cEnum\u201d\u5b57\u6bb5\u4e5f\u9690\u5f0f\u4e3a\u201cfinal\u201d\u3002</p> <pre><code>Direction.up = '^'  # E: Cannot assign to final attribute \"up\"\n</code></pre> <ul> <li>\u68c0\u67e5\u6240\u6709\u5b57\u6bb5\u540d\u79f0\u662f\u5426\u552f\u4e00\u3002</li> </ul> <pre><code>class Some(Enum):\n    x = 1\n    x = 2  # E: Attempted to reuse member name \"x\" in Enum definition \"Some\"\n</code></pre> <ul> <li>\u57fa\u7c7b\u6ca1\u6709\u51b2\u7a81\u5e76\u4e14 mixin \u7c7b\u578b\u662f\u6b63\u786e\u7684\u3002</li> </ul> <pre><code>class WrongEnum(str, int, enum.Enum):\n    # E: Only a single data type mixin is allowed for Enum subtypes, found extra \"int\"\n    ...\n\nclass MixinAfterEnum(enum.Enum, Mixin): # E: No base classes are allowed after \"enum.Enum\"\n    ...\n</code></pre> <p>Mypy also tries to support special features of <code>Enum</code> the same way Python's runtime does:</p> <ul> <li>Any <code>Enum</code> class with values is implicitly <code>final</code>. This is what happens in CPython:</li> </ul> <pre><code>&gt;&gt;&gt; class AllDirection(Direction):\n...     left = 'left'\n...     right = 'right'\nTraceback (most recent call last):\n    ...\nTypeError: AllDirection: cannot extend enumeration 'Direction'\n</code></pre> <p>Mypy also catches this error:</p> <pre><code>class AllDirection(Direction):  # E: Cannot inherit from final class \"Direction\"\n    left = 'left'\n    right = 'right'\n</code></pre> <ul> <li>All <code>Enum</code> fields are implicitly <code>final</code> as well.</li> </ul> <pre><code>Direction.up = '^'  # E: Cannot assign to final attribute \"up\"\n</code></pre> <ul> <li>All field names are checked to be unique.</li> </ul> <pre><code>class Some(Enum):\n    x = 1\n    x = 2  # E: Attempted to reuse member name \"x\" in Enum definition \"Some\"\n</code></pre> <ul> <li>Base classes have no conflicts and mixin types are correct.</li> </ul> <pre><code>class WrongEnum(str, int, enum.Enum):\n    # E: Only a single data type mixin is allowed for Enum subtypes, found extra \"int\"\n    ...\n\nclass MixinAfterEnum(enum.Enum, Mixin): # E: No base classes are allowed after \"enum.Enum\"\n    ...\n</code></pre>"},{"location":"mypy/metaclasses/","title":"\u5143\u7c7b","text":"\u4e2d\u6587\u82f1\u6587 <p>\u5143\u7c7b <code>metaclasses</code> \u662f\u4e00\u4e2a\u63cf\u8ff0\u5176\u4ed6\u7c7b\u7684\u6784\u9020\u548c\u884c\u4e3a\u7684\u7c7b\uff0c\u7c7b\u4f3c\u4e8e\u7c7b\u63cf\u8ff0\u5bf9\u8c61\u7684\u6784\u9020\u548c\u884c\u4e3a\u3002 \u9ed8\u8ba4\u5143\u7c7b\u662f <code>type</code>\uff0c\u4f46\u53ef\u4ee5\u4f7f\u7528\u5176\u4ed6\u5143\u7c7b\u3002 \u5143\u7c7b\u5141\u8bb8\u521b\u5efa \u201c\u4e00\u79cd\u4e0d\u540c\u7c7b\u578b\u7684\u7c7b\u201d\uff0c\u4f8b\u5982 <code>enum.Enum</code>\u3001<code>typing.NamedTuple</code> \u548c\u5355\u4f8b\u3002</p> <p>Mypy \u5bf9 <code>abc.ABCMeta</code> \u548c <code>EnumMeta</code> \u6709\u4e00\u4e9b\u7279\u6b8a\u7684\u7406\u89e3\u3002</p> <p>Metaclasses</p> <p>A <code>metaclasses</code> is a class that describes the construction and behavior of other classes, similarly to how classes describe the construction and behavior of objects. The default metaclass is <code>type</code>, but it's possible to use other metaclasses. Metaclasses allows one to create \"a different kind of class\", such as <code>enum.Enum</code>s\u3001<code>typing.NamedTuple</code>s and singletons.</p> <p>Mypy has some special understanding of {py:class}<code>~abc.ABCMeta</code> and <code>EnumMeta</code>.</p>"},{"location":"mypy/metaclasses/#\u5b9a\u4e49\u5143\u7c7b","title":"\u5b9a\u4e49\u5143\u7c7b","text":"\u4e2d\u6587\u82f1\u6587 <pre><code>class M(type):\n    pass\n\nclass A(metaclass=M):\n    pass\n</code></pre> <p>Defining a metaclass</p> <pre><code>class M(type):\n    pass\n\nclass A(metaclass=M):\n    pass\n</code></pre>"},{"location":"mypy/metaclasses/#\u5143\u7c7b\u4f7f\u7528\u793a\u4f8b","title":"\u5143\u7c7b\u4f7f\u7528\u793a\u4f8b","text":"\u4e2d\u6587\u82f1\u6587 <p>Mypy \u652f\u6301\u5728\u5143\u7c7b\u4e2d\u67e5\u627e\u5c5e\u6027\uff1a</p> <pre><code>from typing import Type, TypeVar, ClassVar\nT = TypeVar('T')\n\nclass M(type):\n    count: ClassVar[int] = 0\n\n    def make(cls: Type[T]) -&gt; T:\n        M.count += 1\n        return cls()\n\nclass A(metaclass=M):\n    pass\n\na: A = A.make()  # make() \u4f1a\u5728 M \u4e2d\u67e5\u627e\uff1b \u7ed3\u679c\u662f A \u7c7b\u578b\u7684\u5bf9\u8c61\nprint(A.count)\n\nclass B(A):\n    pass\n\nb: B = B.make()  # \u5143\u7c7b\u662f\u7ee7\u627f\u7684\nprint(B.count + \" objects were created\")  # Error: Unsupported operand types for + (\"int\" and \"str\")\n</code></pre> <p>Metaclass usage example</p> <p>Mypy supports the lookup of attributes in the metaclass:</p> <pre><code>from typing import Type, TypeVar, ClassVar\nT = TypeVar('T')\n\nclass M(type):\n    count: ClassVar[int] = 0\n\n    def make(cls: Type[T]) -&gt; T:\n        M.count += 1\n        return cls()\n\nclass A(metaclass=M):\n    pass\n\na: A = A.make()  # make() is looked up at M; the result is an object of type A\nprint(A.count)\n\nclass B(A):\n    pass\n\nb: B = B.make()  # metaclasses are inherited\nprint(B.count + \" objects were created\")  # Error: Unsupported operand types for + (\"int\" and \"str\")\n</code></pre>"},{"location":"mypy/metaclasses/#\u5143\u7c7b\u652f\u6301\u7684\u9677\u9631\u548c\u9650\u5236","title":"\u5143\u7c7b\u652f\u6301\u7684\u9677\u9631\u548c\u9650\u5236","text":"\u4e2d\u6587\u82f1\u6587 <p>\u8bf7\u6ce8\u610f\uff0c\u5143\u7c7b\u5bf9\u7ee7\u627f\u7ed3\u6784\u63d0\u51fa\u4e86\u4e00\u4e9b\u8981\u6c42\uff0c\u56e0\u6b64\u6700\u597d\u4e0d\u8981\u5c06\u5143\u7c7b\u548c\u7c7b\u5c42\u6b21\u7ed3\u6784\u7ed3\u5408\u8d77\u6765\uff1a</p> <pre><code>class M1(type): pass\nclass M2(type): pass\n\nclass A1(metaclass=M1): pass\nclass A2(metaclass=M2): pass\n\nclass B1(A1, metaclass=M2): pass  # Mypy Error: metaclass conflict\n# \u5728\u8fd0\u884c\u65f6\uff0c\u4e0a\u9762\u7684\u5b9a\u4e49\u4f1a\u5f15\u53d1\u5f02\u5e38\n# TypeError: metaclass conflict: \u6d3e\u751f\u7c7b\u7684\u5143\u7c7b\u5fc5\u987b\u662f\u5176\u6240\u6709\u57fa\u7c7b\u7684\u5143\u7c7b\u7684\uff08\u975e\u4e25\u683c\uff09\u5b50\u7c7b\n\nclass B12(A1, A2): pass  # Mypy Error: metaclass conflict\n\n# \u8fd9\u53ef\u4ee5\u901a\u8fc7\u901a\u7528\u5143\u7c7b\u5b50\u7c7b\u578b\u6765\u89e3\u51b3\uff1a\nclass CorrectMeta(M1, M2): pass\nclass B2(A1, A2, metaclass=CorrectMeta): pass  # OK, \u8fd0\u884c\u65f6\u4e5f\u6ca1\u95ee\u9898\n</code></pre> <ul> <li>Mypy \u4e0d\u7406\u89e3\u52a8\u6001\u8ba1\u7b97\u7684\u5143\u7c7b\uff0c\u4f8b\u5982 <code>class A(metaclass=f()): ...</code></li> <li>Mypy \u4e0d\u4f1a\u4e5f\u4e0d\u53ef\u80fd\u7406\u89e3\u4efb\u610f\u5143\u7c7b\u4ee3\u7801\u3002</li> <li>Mypy \u4ec5\u5c06 <code>type</code> \u7684\u5b50\u7c7b\u8bc6\u522b\u4e3a\u6f5c\u5728\u7684\u5143\u7c7b\u3002</li> </ul> <p>Gotchas and limitations of metaclass support</p> <p>Note that metaclasses pose some requirements on the inheritance structure, so it's better not to combine metaclasses and class hierarchies:</p> <pre><code>class M1(type): pass\nclass M2(type): pass\n\nclass A1(metaclass=M1): pass\nclass A2(metaclass=M2): pass\n\nclass B1(A1, metaclass=M2): pass  # Mypy Error: metaclass conflict\n# At runtime the above definition raises an exception\n# TypeError: metaclass conflict: the metaclass of a derived class must be a (non-strict) subclass of the metaclasses of all its bases\n\nclass B12(A1, A2): pass  # Mypy Error: metaclass conflict\n\n# This can be solved via a common metaclass subtype:\nclass CorrectMeta(M1, M2): pass\nclass B2(A1, A2, metaclass=CorrectMeta): pass  # OK, runtime is also OK\n</code></pre> <ul> <li>Mypy does not understand dynamically-computed metaclasses, such as <code>class A(metaclass=f()): ...</code></li> <li>Mypy does not and cannot understand arbitrary metaclass code.</li> <li>Mypy only recognizes subclasses of <code>type</code> as potential metaclasses.</li> </ul>"},{"location":"mypy/more_types/","title":"\u66f4\u591a\u7c7b\u578b","text":"\u4e2d\u6587\u82f1\u6587 <p>\u672c\u8282\u4ecb\u7ecd\u4e86\u4e00\u4e9b\u5176\u4ed6\u7c7b\u578b\uff0c\u5305\u62ec <code>typing.NoReturn</code>\u3001[<code>typing.NewType</code>]( https://docs.python.org/3/library/typing.html#typing.NewType\uff09\uff0c\u4ee5\u53ca\u5f02\u6b65\u4ee3\u7801\u7684\u7c7b\u578b\u3002 \u5b83\u8fd8\u8ba8\u8bba\u4e86\u5982\u4f55\u4f7f\u7528\u91cd\u8f7d\u4e3a\u51fd\u6570\u63d0\u4f9b\u66f4\u7cbe\u786e\u7684\u7c7b\u578b\u3002 \u6240\u6709\u8fd9\u4e9b\u4ec5\u5728\u7279\u5b9a\u60c5\u51b5\u4e0b\u6709\u7528\uff0c\u56e0\u6b64\u8bf7\u968f\u610f\u8df3\u8fc7\u672c\u8282\uff0c\u5f53\u60a8\u9700\u8981\u5176\u4e2d\u4e00\u4e9b\u65f6\u518d\u56de\u6765\u3002</p> <p>\u4ee5\u4e0b\u662f\u672c\u6587\u6240\u6db5\u76d6\u5185\u5bb9\u7684\u5feb\u901f\u6458\u8981\uff1a</p> <ul> <li><code>typing.NoReturn</code> \u8ba9\u60a8\u544a\u8bc9 mypy \u51fd\u6570\u6c38\u8fdc\u4e0d\u4f1a\u6b63\u5e38\u8fd4\u56de\u3002</li> <li><code>typing.NewType</code> \u5141\u8bb8\u60a8\u5b9a\u4e49\u7c7b\u578b\u7684\u534f\u53d8\uff0c\u8be5\u534f\u53d8\u88ab mypy \u89c6\u4e3a\u5355\u72ec\u7684\u7c7b\u578b\uff0c\u4f46\u5728\u8fd0\u884c\u65f6\u4e0e\u539f\u59cb\u7c7b\u578b\u76f8\u540c\u3002 \u4f8b\u5982\uff0c\u60a8\u53ef\u4ee5\u5c06 <code>UserId</code> \u4f5c\u4e3a <code>int</code> \u7684\u534f\u53d8\uff0c\u5b83\u5728\u8fd0\u884c\u65f6\u53ea\u662f\u4e00\u4e2a<code>int</code>\u3002</li> <li><code>typing.overload</code> \u8ba9\u60a8\u5b9a\u4e49\u4e00\u4e2a\u53ef\u4ee5\u63a5\u53d7\u591a\u4e2a\u4e0d\u540c\u7b7e\u540d\u7684\u51fd\u6570\u3002 \u5982\u679c\u60a8\u9700\u8981\u5bf9\u53c2\u6570\u548c\u8fd4\u56de\u7c7b\u578b\u4e4b\u95f4\u7684\u5173\u7cfb\u8fdb\u884c\u7f16\u7801\uff0c\u800c\u8fd9\u79cd\u5173\u7cfb\u5f88\u96be\u6b63\u5e38\u8868\u8fbe\uff0c\u90a3\u4e48\u8fd9\u975e\u5e38\u6709\u7528\u3002</li> <li>\u5f02\u6b65\u7c7b\u578b\u5141\u8bb8\u60a8\u4f7f\u7528 <code>async</code> \u548c <code>await</code> \u7684\u540c\u65f6\u652f\u6301\u68c0\u67e5\u7f16\u7801\u7c7b\u578b\u3002</li> </ul> <p>More types</p> <p>This section introduces a few additional kinds of types, including <code>typing.NoReturn</code>, <code>typing.NewType</code>, and types for async code. It also discusses how to give functions more precise types using overloads. All of these are only situationally useful, so feel free to skip this section and come back when you have a need for some of them.</p> <p>Here's a quick summary of what's covered here:</p> <ul> <li><code>typing.NoReturn</code> lets you tell mypy that a function never returns normally.</li> <li><code>typing.NewType</code> lets you define a variant of a type that is treated as a separate type by mypy but is identical to the original type at runtime. For example, you can have <code>UserId</code> as a variant of <code>int</code> that is just an <code>int</code> at runtime.</li> <li><code>typing.overload</code> lets you define a function that can accept multiple distinct signatures. This is useful if you need to encode a relationship between the arguments and the return type that would be difficult to express normally.</li> <li>Async types let you type check programs using <code>async</code> and <code>await</code>.</li> </ul>"},{"location":"mypy/more_types/#noreturn\u7c7b\u578b","title":"NoReturn\u7c7b\u578b","text":"<p>The NoReturn type</p> \u4e2d\u6587\u82f1\u6587 <p>Mypy \u63d0\u4f9b\u5bf9\u6c38\u4e0d\u8fd4\u56de\u7684\u51fd\u6570\u7684\u652f\u6301\u3002 \u4f8b\u5982\uff0c\u65e0\u6761\u4ef6\u5f15\u53d1\u5f02\u5e38\u7684\u51fd\u6570\uff1a</p> <pre><code>from typing import NoReturn\n\ndef stop() -&gt; NoReturn:\n    raise Exception('no way')\n</code></pre> <p>Mypy will ensure that functions annotated as returning <code>NoReturn</code> truly never return, either implicitly or explicitly. Mypy will also recognize that the code after calls to such functions is unreachable and will behave accordingly:</p> <pre><code>def f(x: int) -&gt; int:\n    if x == 0:\n        return x\n    stop()\n    return 'whatever works'  # No error in an unreachable block\n</code></pre> <p>Mypy \u5c06\u786e\u4fdd\u6ce8\u91ca\u4e3a\u8fd4\u56de <code>NoReturn</code> \u7684\u51fd\u6570\u771f\u6b63\u6c38\u8fdc\u4e0d\u4f1a\u8fd4\u56de\uff0c\u65e0\u8bba\u662f\u9690\u5f0f\u8fd8\u662f\u663e\u5f0f\u3002 Mypy \u8fd8\u4f1a\u8bc6\u522b\u51fa\u8c03\u7528\u6b64\u7c7b\u51fd\u6570\u540e\u7684\u4ee3\u7801\u662f\u65e0\u6cd5\u8bbf\u95ee\u7684\uff0c\u5e76\u4f1a\u505a\u51fa\u76f8\u5e94\u7684\u884c\u4e3a\uff1a</p> <pre><code>python3 -m pip install --upgrade typing-extensions\n</code></pre> <p>Mypy provides support for functions that never return. For example, a function that unconditionally raises an exception:</p> <pre><code>from typing import NoReturn\n\ndef stop() -&gt; NoReturn:\n    raise Exception('no way')\n</code></pre> <p>Mypy will ensure that functions annotated as returning <code>NoReturn</code> truly never return, either implicitly or explicitly. Mypy will also recognize that the code after calls to such functions is unreachable and will behave accordingly:</p> <pre><code>def f(x: int) -&gt; int:\n    if x == 0:\n        return x\n    stop()\n    return 'whatever works'  # No error in an unreachable block\n</code></pre> <p>In earlier Python versions you need to install <code>typing_extensions</code> using pip to use <code>NoReturn</code> in your code. Python 3 command line:</p> <pre><code>python3 -m pip install --upgrade typing-extensions\n</code></pre>"},{"location":"mypy/more_types/#newtype\u7c7b\u578b","title":"NewType\u7c7b\u578b","text":"<p>NewTypes</p> \u4e2d\u6587\u82f1\u6587 <p>\u5728\u67d0\u4e9b\u60c5\u51b5\u4e0b\uff0c\u60a8\u53ef\u80fd\u5e0c\u671b\u901a\u8fc7\u521b\u5efa\u4ec5\u7528\u4e8e\u533a\u5206\u67d0\u4e9b\u503c\u4e0e\u57fa\u7c7b\u5b9e\u4f8b\u7684\u7b80\u5355\u6d3e\u751f\u7c7b\u6765\u907f\u514d\u7f16\u7a0b\u9519\u8bef\u3002 \u4f8b\u5b50\uff1a</p> <pre><code>class UserId(int):\n    pass\n\ndef get_by_user_id(user_id: UserId):\n    ...\n</code></pre> <p>\u7136\u800c\uff0c\u8fd9\u79cd\u65b9\u6cd5\u5f15\u5165\u4e86\u4e00\u4e9b\u8fd0\u884c\u65f6\u5f00\u9500\u3002 \u4e3a\u4e86\u907f\u514d\u8fd9\u79cd\u60c5\u51b5\uff0c\u7c7b\u578b\u6a21\u5757\u63d0\u4f9b\u4e86\u4e00\u4e2a\u8f85\u52a9\u5bf9\u8c61 \u201cNewType\u201d\uff0c\u5b83\u521b\u5efa\u7b80\u5355\u7684\u552f\u4e00\u7c7b\u578b\uff0c\u8fd0\u884c\u65f6\u5f00\u9500\u51e0\u4e4e\u4e3a\u96f6\u3002  Mypy \u4f1a\u5c06\u8bed\u53e5 <code>Derived = NewType('Derived', Base)</code> \u89c6\u4e3a\u5927\u81f4\u76f8\u5f53\u4e8e\u4ee5\u4e0b\u5b9a\u4e49\uff1a</p> <pre><code>class Derived(Base):\n    def __init__(self, _x: Base) -&gt; None:\n        ...\n</code></pre> <p>\u4f46\u662f\uff0c\u5728\u8fd0\u884c\u65f6\uff0c <code>NewType('Derived', Base)</code> \u5c06\u8fd4\u56de\u4e00\u4e2a\u865a\u62df\u53ef\u8c03\u7528\u5bf9\u8c61\uff0c\u8be5\u53ef\u8c03\u7528\u5bf9\u8c61\u4ec5\u8fd4\u56de\u5176\u53c2\u6570\uff1a</p> <pre><code>def Derived(_x):\n    return _x\n</code></pre> <p>Mypy \u5c06\u9700\u8981\u4ece\u9700\u8981 \u201cUserId\u201d \u7684 \u201cint\u201d \u663e\u5f0f\u8f6c\u6362\uff0c\u800c\u9700\u8981\u201cint\u201d\u7684\u5730\u65b9\u4ece\u201cUserId\u201d\u9690\u5f0f\u8f6c\u6362\u3002 \u4f8b\u5b50\uff1a</p> <pre><code>from typing import NewType\n\nUserId = NewType('UserId', int)\n\ndef name_by_id(user_id: UserId) -&gt; str:\n    ...\n\nUserId('user')          # Fails type check\n\nname_by_id(42)          # Fails type check\nname_by_id(UserId(42))  # OK\n\nnum: int = UserId(5) + 1\n</code></pre> <p><code>NewType</code> \u53ea\u63a5\u53d7\u4e24\u4e2a\u53c2\u6570\u3002 \u7b2c\u4e00\u4e2a\u53c2\u6570\u5fc5\u987b\u662f\u5305\u542b\u65b0\u7c7b\u578b\u540d\u79f0\u7684\u5b57\u7b26\u4e32\u6587\u5b57\uff0c\u5e76\u4e14\u5fc5\u987b\u7b49\u4e8e\u5206\u914d\u65b0\u7c7b\u578b\u7684\u53d8\u91cf\u7684\u540d\u79f0\u3002 \u7b2c\u4e8c\u4e2a\u53c2\u6570\u5fc5\u987b\u662f\u4e00\u4e2a\u6b63\u786e\u7684\u53ef\u5b50\u7c7b\uff0c\u5373\u4e0d\u662f\u50cf <code>Union</code> \u7b49\u7c7b\u578b\u6784\u9020\u3002</p> <p><code>NewType</code> \u8fd4\u56de\u7684\u53ef\u8c03\u7528\u5bf9\u8c61\u4ec5\u63a5\u53d7\u4e00\u4e2a\u53c2\u6570\uff1b \u8fd9\u76f8\u5f53\u4e8e\u53ea\u652f\u6301\u4e00\u4e2a\u63a5\u53d7\u57fa\u7c7b\u5b9e\u4f8b\u7684\u6784\u9020\u51fd\u6570\uff08\u89c1\u4e0a\u6587\uff09\u3002 \u4f8b\u5b50\uff1a</p> <pre><code>from typing import NewType\n\nclass PacketId:\n    def __init__(self, major: int, minor: int) -&gt; None:\n        self._major = major\n        self._minor = minor\n\nTcpPacketId = NewType('TcpPacketId', PacketId)\n\npacket = PacketId(100, 100)\ntcp_packet = TcpPacketId(packet)  # OK\n\ntcp_packet = TcpPacketId(127, 0)  # Fails in type checker and at runtime\n</code></pre> <p>\u60a8\u4e0d\u80fd\u4f7f\u7528 <code>isinstance</code> \u6216 <code>issubclass</code> \u5728 <code>NewType</code> \u8fd4\u56de\u7684\u5bf9\u8c61\u4e0a\uff0c\u4e5f\u4e0d\u80fd\u5bf9 <code>NewType</code> \u8fd4\u56de\u7684\u5bf9\u8c61\u8fdb\u884c\u5b50\u7c7b\u5316\u3002</p> <p>Note</p> <p>\u4e0e\u7c7b\u578b\u522b\u540d\u4e0d\u540c\uff0c\u201cNewType\u201d \u5728\u4f7f\u7528\u65f6\u5c06\u521b\u5efa\u4e00\u4e2a\u5168\u65b0\u4e14\u552f\u4e00\u7684\u7c7b\u578b\u3002 <code>NewType</code> \u7684\u9884\u671f\u76ee\u7684\u662f\u5e2e\u52a9\u60a8\u68c0\u6d4b\u610f\u5916\u5730\u5c06\u65e7\u57fa\u672c\u7c7b\u578b\u548c\u65b0\u6d3e\u751f\u7c7b\u578b\u6df7\u5408\u5728\u4e00\u8d77\u7684\u60c5\u51b5\u3002</p> <p>\u4f8b\u5982\uff0c\u4f7f\u7528\u7c7b\u578b\u522b\u540d\u65f6\uff0c\u4ee5\u4e0b\u5185\u5bb9\u5c06\u6210\u529f\u8fdb\u884c\u7c7b\u578b\u68c0\u67e5\uff1a</p> <pre><code>UserId = int\n\ndef name_by_id(user_id: UserId) -&gt; str:\n    ...\n\nname_by_id(3)  # int \u548c UserId \u662f\u540c\u4e49\u8bcd\n</code></pre> <p>\u4f46\u4f7f\u7528 <code>NewType</code> \u7684\u7c7b\u4f3c\u793a\u4f8b\u4e0d\u4f1a\u8fdb\u884c\u7c7b\u578b\u68c0\u67e5\uff1a</p> <pre><code>from typing import NewType\n\nUserId = NewType('UserId', int)\n\ndef name_by_id(user_id: UserId) -&gt; str:\n    ...\n\nname_by_id(3)  # int \u4e0e UserId \u4e0d\u540c\n</code></pre> <p>There are situations where you may want to avoid programming errors by creating simple derived classes that are only used to distinguish certain values from base class instances. Example:</p> <pre><code>class UserId(int):\n    pass\n\ndef get_by_user_id(user_id: UserId):\n    ...\n</code></pre> <p>However, this approach introduces some runtime overhead. To avoid this, the typing module provides a helper object <code>NewType</code> that creates simple unique types with almost zero runtime overhead. Mypy will treat the statement <code>Derived = NewType('Derived', Base)</code> as being roughly equivalent to the following definition:</p> <pre><code>class Derived(Base):\n    def __init__(self, _x: Base) -&gt; None:\n        ...\n</code></pre> <p>However, at runtime, <code>NewType('Derived', Base)</code> will return a dummy callable that simply returns its argument:</p> <pre><code>def Derived(_x):\n    return _x\n</code></pre> <p>Mypy will require explicit casts from <code>int</code> where <code>UserId</code> is expected, while implicitly casting from <code>UserId</code> where <code>int</code> is expected. Examples:</p> <pre><code>from typing import NewType\n\nUserId = NewType('UserId', int)\n\ndef name_by_id(user_id: UserId) -&gt; str:\n    ...\n\nUserId('user')          # Fails type check\n\nname_by_id(42)          # Fails type check\nname_by_id(UserId(42))  # OK\n\nnum: int = UserId(5) + 1\n</code></pre> <p><code>NewType</code> accepts exactly two arguments. The first argument must be a string literal containing the name of the new type and must equal the name of the variable to which the new type is assigned. The second argument must be a properly subclassable class, i.e., not a type construct like <code>Union</code>, etc.</p> <p>The callable returned by <code>NewType</code> accepts only one argument; this is equivalent to supporting only one constructor accepting an instance of the base class (see above). Example:</p> <pre><code>from typing import NewType\n\nclass PacketId:\n    def __init__(self, major: int, minor: int) -&gt; None:\n        self._major = major\n        self._minor = minor\n\nTcpPacketId = NewType('TcpPacketId', PacketId)\n\npacket = PacketId(100, 100)\ntcp_packet = TcpPacketId(packet)  # OK\n\ntcp_packet = TcpPacketId(127, 0)  # Fails in type checker and at runtime\n</code></pre> <p>You cannot use <code>isinstance</code> or <code>issubclass</code> on the object returned by <code>NewType</code>, nor can you subclass an object returned by <code>NewType</code>.</p> <p>Note</p> <p>Unlike type aliases, <code>NewType</code> will create an entirely new and unique type when used. The intended purpose of <code>NewType</code> is to help you detect cases where you accidentally mixed together the old base type and the new derived type.</p> <p>For example, the following will successfully typecheck when using type aliases:</p> <pre><code>UserId = int\n\ndef name_by_id(user_id: UserId) -&gt; str:\n    ...\n\nname_by_id(3)  # ints and UserId are synonymous\n</code></pre> <p>But a similar example using <code>NewType</code> will not typecheck:</p> <pre><code>from typing import NewType\n\nUserId = NewType('UserId', int)\n\ndef name_by_id(user_id: UserId) -&gt; str:\n    ...\n\nname_by_id(3)  # int is not the same as UserId\n</code></pre>"},{"location":"mypy/more_types/#\u51fd\u6570\u91cd\u8f7d","title":"\u51fd\u6570\u91cd\u8f7d","text":"<p>Function overloading</p> \u4e2d\u6587\u82f1\u6587 <p>\u6709\u65f6\uff0c\u51fd\u6570\u4e2d\u7684\u53c2\u6570\u548c\u7c7b\u578b\u5f7c\u6b64\u4f9d\u8d56\uff0c\u800c\u65e0\u6cd5\u4f7f\u7528 <code>Union</code> \u6355\u83b7 \u3002 \u4f8b\u5982\uff0c\u5047\u8bbe\u6211\u4eec\u8981\u7f16\u5199\u4e00\u4e2a\u53ef\u4ee5\u63a5\u53d7 x-y \u5750\u6807\u7684\u51fd\u6570\u3002 \u5982\u679c\u6211\u4eec\u53ea\u4f20\u5165\u4e00\u4e2a x-y \u5750\u6807\uff0c\u6211\u4eec\u5c06\u8fd4\u56de\u4e00\u4e2a \u201cClickEvent\u201d \u5bf9\u8c61\u3002 \u4f46\u662f\uff0c\u5982\u679c\u6211\u4eec\u4f20\u5165\u4e24\u4e2a x-y \u5750\u6807\uff0c\u6211\u4eec\u5c06\u8fd4\u56de\u4e00\u4e2a \u201cDragEvent\u201d \u5bf9\u8c61\u3002</p> <p>\u6211\u4eec\u7b2c\u4e00\u6b21\u5c1d\u8bd5\u7f16\u5199\u8fd9\u4e2a\u51fd\u6570\u53ef\u80fd\u5982\u4e0b\u6240\u793a\uff1a</p> <pre><code>from typing import Union, Optional\n\ndef mouse_event(x1: int,\n                y1: int,\n                x2: Optional[int] = None,\n                y2: Optional[int] = None) -&gt; Union[ClickEvent, DragEvent]:\n    if x2 is None and y2 is None:\n        return ClickEvent(x1, y1)\n    elif x2 is not None and y2 is not None:\n        return DragEvent(x1, y1, x2, y2)\n    else:\n        raise TypeError(\"Bad arguments\")\n</code></pre> <p>\u867d\u7136\u8fd9\u4e2a\u51fd\u6570\u7b7e\u540d\u6709\u6548\uff0c\u4f46\u5b83\u592a\u677e\u6563\u4e86\uff1a\u5b83\u610f\u5473\u7740\u65e0\u8bba\u6211\u4eec\u4f20\u5165\u7684\u53c2\u6570\u6570\u91cf\u5982\u4f55\uff0c\u201cmouse_event\u201d \u90fd\u53ef\u4ee5\u8fd4\u56de\u4efb\u4e00\u5bf9\u8c61\u3002\u5b83\u4e5f\u4e0d\u7981\u6b62\u8c03\u7528\u8005\u4f20\u5165\u9519\u8bef\u6570\u91cf\u7684\u6574\u6570\uff1amypy \u4f1a\u50cf\u8fd9\u6837\u5bf9\u5f85\u8c03\u7528 \u4f8b\u5982\uff0c\u201cmouse_event(1, 2, 20)\u201d \u662f\u6709\u6548\u7684\u3002</p> <p>\u6211\u4eec\u53ef\u4ee5\u901a\u8fc7\u4f7f\u7528 <code>overloading</code> \u505a\u5f97\u66f4\u597d\uff0c\u5b83\u53ef\u4ee5\u8ba9\u6211\u4eec\u4e3a\u540c\u4e00\u4e2a\u51fd\u6570\u63d0\u4f9b\u591a\u4e2a\u7c7b\u578b\u6ce8\u91ca\uff08\u7b7e\u540d\uff09\u4ee5\u66f4\u51c6\u786e\u5730\u63cf\u8ff0\u51fd\u6570\u7684\u884c\u4e3a\uff1a</p> <pre><code>from typing import Union, overload\n\n# \u91cd\u8f7d\u201cmouse_event\u201d\u7684*\u534f\u53d8*\u3002\n# \u8fd9\u4e9b\u534f\u53d8\u4e3a\u7c7b\u578b\u68c0\u67e5\u5668\u63d0\u4f9b\u4e86\u989d\u5916\u7684\u4fe1\u606f\u3002\n# \u5b83\u4eec\u5728\u8fd0\u884c\u65f6\u88ab\u5ffd\u7565\u3002\n\n@overload\ndef mouse_event(x1: int, y1: int) -&gt; ClickEvent: ...\n@overload\ndef mouse_event(x1: int, y1: int, x2: int, y2: int) -&gt; DragEvent: ...\n\n# \u201cmouse_event\u201d\u7684\u5b9e\u9645*\u5b9e\u73b0*\u3002\n# \u5b9e\u73b0\u5305\u542b\u5b9e\u9645\u7684\u8fd0\u884c\u65f6\u903b\u8f91\u3002\n#\n# \u5b83\u53ef\u80fd\u6709\u4e5f\u53ef\u80fd\u6ca1\u6709\u7c7b\u578b\u63d0\u793a\u3002 \u5982\u679c\u662f\uff0cmypy \u5c06\u6839\u636e\u7c7b\u578b\u63d0\u793a\u68c0\u67e5\u5b9e\u73b0\u7684\u4e3b\u4f53\u3002\n#\n# Mypy \u8fd8\u5c06\u68c0\u67e5\u5e76\u786e\u4fdd\u7b7e\u540d\u4e0e\u63d0\u4f9b\u7684\u534f\u53d8\u4e00\u81f4\u3002\n\ndef mouse_event(x1: int,\n                y1: int,\n                x2: Optional[int] = None,\n                y2: Optional[int] = None) -&gt; Union[ClickEvent, DragEvent]:\n    if x2 is None and y2 is None:\n        return ClickEvent(x1, y1)\n    elif x2 is not None and y2 is not None:\n        return DragEvent(x1, y1, x2, y2)\n    else:\n        raise TypeError(\"Bad arguments\")\n</code></pre> <p>\u8fd9\u4f7f\u5f97 mypy \u80fd\u591f\u66f4\u51c6\u786e\u5730\u7406\u89e3\u5bf9 \u201cmouse_event\u201d \u7684\u8c03\u7528\u3002 \u4f8b\u5982\uff0cmypy \u5c06\u7406\u89e3 \u201cmouse_event(5, 25)\u201d \u5c06\u59cb\u7ec8\u5177\u6709 \u201cClickEvent\u201d \u7684\u8fd4\u56de\u7c7b\u578b\uff0c\u5e76\u5c06\u62a5\u544a \u201cmouse_event(5, 25, 2)\u201d \u7b49\u8c03\u7528\u7684\u9519\u8bef\u3002</p> <p>\u53e6\u4e00\u4e2a\u4f8b\u5b50\uff0c\u5047\u8bbe\u6211\u4eec\u8981\u7f16\u5199\u4e00\u4e2a\u81ea\u5b9a\u4e49\u5bb9\u5668\u7c7b\u6765\u5b9e\u73b0 <code>__getitem__</code> \u65b9\u6cd5 (<code>[]</code> \u62ec\u53f7\u7d22\u5f15\uff09\u3002 \u5982\u679c\u6b64\u65b9\u6cd5\u63a5\u6536\u5230\u4e00\u4e2a\u6574\u6570\uff0c\u6211\u4eec\u5c06\u8fd4\u56de\u4e00\u4e2a\u9879\u76ee\u3002 \u5982\u679c\u5b83\u6536\u5230\u4e00\u4e2a\u201c\u5207\u7247\u201d\uff0c\u6211\u4eec\u5c06\u8fd4\u56de\u4e00\u4e2a\u9879\u76ee\u7684\u201c\u5e8f\u5217\u201d\u3002</p> <p>\u6211\u4eec\u53ef\u4ee5\u901a\u8fc7\u4f7f\u7528\u91cd\u8f7d\u6765\u7cbe\u786e\u7f16\u7801\u53c2\u6570\u548c\u8fd4\u56de\u7c7b\u578b\u4e4b\u95f4\u7684\u5173\u7cfb\uff0c\u5982\u4e0b\u6240\u793a\uff1a</p> <pre><code>from typing import Sequence, TypeVar, Union, overload\n\nT = TypeVar('T')\n\nclass MyList(Sequence[T]):\n    @overload\n    def __getitem__(self, index: int) -&gt; T: ...\n\n    @overload\n    def __getitem__(self, index: slice) -&gt; Sequence[T]: ...\n\n    def __getitem__(self, index: Union[int, slice]) -&gt; Union[T, Sequence[T]]:\n        if isinstance(index, int):\n            # Return a T here\n        elif isinstance(index, slice):\n            # Return a sequence of Ts here\n        else:\n            raise TypeError(...)\n</code></pre> <p>Note</p> <p>\u5982\u679c\u60a8\u53ea\u9700\u8981\u5c06\u7c7b\u578b\u53d8\u91cf\u9650\u5236\u4e3a\u67d0\u4e9b\u7c7b\u578b\u6216\u5b50\u7c7b\u578b\uff0c\u5219\u53ef\u4ee5\u4f7f\u7528<code>\u503c\u9650\u5236</code>\u3002</p> <p>\u51fd\u6570\u53c2\u6570\u7684\u9ed8\u8ba4\u503c\u4e0d\u4f1a\u5f71\u54cd\u5176\u7b7e\u540d\u2014\u2014\u53ea\u6709\u9ed8\u8ba4\u503c\u7684\u7f3a\u5931\u6216\u5b58\u5728\u624d\u4f1a\u5f71\u54cd\u3002 \u56e0\u6b64\uff0c\u4e3a\u4e86\u51cf\u5c11\u5197\u4f59\uff0c\u53ef\u4ee5\u7528\u201c...\u201d\u4f5c\u4e3a\u5360\u4f4d\u7b26\u6765\u66ff\u6362\u91cd\u8f7d\u5b9a\u4e49\u4e2d\u7684\u9ed8\u8ba4\u503c\uff1a</p> <pre><code>from typing import overload\n\nclass M: ...\n\n@overload\ndef get_model(model_or_pk: M, flag: bool = ...) -&gt; M: ...\n@overload\ndef get_model(model_or_pk: int, flag: bool = ...) -&gt; M | None: ...\n\ndef get_model(model_or_pk: int | M, flag: bool = True) -&gt; M | None:\n    ...\n</code></pre> <p>Sometimes the arguments and types in a function depend on each other in ways that can't be captured with a <code>Union</code>. For example, suppose we want to write a function that can accept x-y coordinates. If we pass in just a single x-y coordinate, we return a <code>ClickEvent</code> object. However, if we pass in two x-y coordinates, we return a <code>DragEvent</code> object.</p> <p>Our first attempt at writing this function might look like this:</p> <pre><code>from typing import Union, Optional\n\ndef mouse_event(x1: int,\n                y1: int,\n                x2: Optional[int] = None,\n                y2: Optional[int] = None) -&gt; Union[ClickEvent, DragEvent]:\n    if x2 is None and y2 is None:\n        return ClickEvent(x1, y1)\n    elif x2 is not None and y2 is not None:\n        return DragEvent(x1, y1, x2, y2)\n    else:\n        raise TypeError(\"Bad arguments\")\n</code></pre> <p>While this function signature works, it's too loose: it implies <code>mouse_event</code> could return either object regardless of the number of arguments we pass in. It also does not prohibit a caller from passing in the wrong number of ints: mypy would treat calls like <code>mouse_event(1, 2, 20)</code> as being valid, for example.</p> <p>We can do better by using <code>overloading</code> which lets us give the same function multiple type annotations (signatures) to more accurately describe the function's behavior:</p> <pre><code>from typing import Union, overload\n\n# Overload *variants* for 'mouse_event'.\n# These variants give extra information to the type checker.\n# They are ignored at runtime.\n\n@overload\ndef mouse_event(x1: int, y1: int) -&gt; ClickEvent: ...\n@overload\ndef mouse_event(x1: int, y1: int, x2: int, y2: int) -&gt; DragEvent: ...\n\n# The actual *implementation* of 'mouse_event'.\n# The implementation contains the actual runtime logic.\n#\n# It may or may not have type hints. If it does, mypy\n# will check the body of the implementation against the\n# type hints.\n#\n# Mypy will also check and make sure the signature is\n# consistent with the provided variants.\n\ndef mouse_event(x1: int,\n                y1: int,\n                x2: Optional[int] = None,\n                y2: Optional[int] = None) -&gt; Union[ClickEvent, DragEvent]:\n    if x2 is None and y2 is None:\n        return ClickEvent(x1, y1)\n    elif x2 is not None and y2 is not None:\n        return DragEvent(x1, y1, x2, y2)\n    else:\n        raise TypeError(\"Bad arguments\")\n</code></pre> <p>This allows mypy to understand calls to <code>mouse_event</code> much more precisely. For example, mypy will understand that <code>mouse_event(5, 25)</code> will always have a return type of <code>ClickEvent</code> and will report errors for calls like <code>mouse_event(5, 25, 2)</code>.</p> <p>As another example, suppose we want to write a custom container class that implements the <code>__getitem__</code> method (<code>[]</code> bracket indexing). If this method receives an integer we return a single item. If it receives a <code>slice</code>, we return a <code>Sequence</code> of items.</p> <p>We can precisely encode this relationship between the argument and the return type by using overloads like so:</p> <pre><code>from typing import Sequence, TypeVar, Union, overload\n\nT = TypeVar('T')\n\nclass MyList(Sequence[T]):\n    @overload\n    def __getitem__(self, index: int) -&gt; T: ...\n\n    @overload\n    def __getitem__(self, index: slice) -&gt; Sequence[T]: ...\n\n    def __getitem__(self, index: Union[int, slice]) -&gt; Union[T, Sequence[T]]:\n        if isinstance(index, int):\n            # Return a T here\n        elif isinstance(index, slice):\n            # Return a sequence of Ts here\n        else:\n            raise TypeError(...)\n</code></pre> <p>Note</p> <p>If you just need to constrain a type variable to certain types or subtypes, you can use a <code>value restriction</code>.</p> <p>The default values of a function's arguments don't affect its signature -- only the absence or presence of a default value does. So in order to reduce redundancy, it's possible to replace default values in overload definitions with <code>...</code> as a placeholder:</p> <pre><code>from typing import overload\n\nclass M: ...\n\n@overload\ndef get_model(model_or_pk: M, flag: bool = ...) -&gt; M: ...\n@overload\ndef get_model(model_or_pk: int, flag: bool = ...) -&gt; M | None: ...\n\ndef get_model(model_or_pk: int | M, flag: bool = True) -&gt; M | None:\n    ...\n</code></pre>"},{"location":"mypy/more_types/#\u8fd0\u884c\u65f6\u884c\u4e3a","title":"\u8fd0\u884c\u65f6\u884c\u4e3a","text":"<p>Runtime behavior</p> \u4e2d\u6587\u82f1\u6587 <p>\u91cd\u8f7d\u51fd\u6570\u5fc5\u987b\u7531\u4e24\u4e2a\u6216\u591a\u4e2a\u91cd\u8f7d\u534f\u53d8\u7ec4\u6210\uff0c\u540e\u8ddf\u4e00\u4e2a\u5b9e\u73b0\u3002 \u534f\u53d8\u548c\u5b9e\u73b0\u5728\u4ee3\u7801\u4e2d\u5fc5\u987b\u76f8\u90bb\uff1a\u5c06\u5b83\u4eec\u89c6\u4e3a\u4e00\u4e2a\u4e0d\u53ef\u5206\u5272\u7684\u5355\u5143\u3002</p> <p>\u534f\u53d8\u4e3b\u4f53\u5fc5\u987b\u5168\u90e8\u4e3a\u7a7a\uff1b \u4ec5\u5141\u8bb8\u5b9e\u73b0\u5305\u542b\u4ee3\u7801\u3002 \u8fd9\u662f\u56e0\u4e3a\u5728\u8fd0\u884c\u65f6\uff0c\u534f\u53d8\u88ab\u5b8c\u5168\u5ffd\u7565\uff1a\u5b83\u4eec\u88ab\u6700\u7ec8\u7684\u5b9e\u73b0\u51fd\u6570\u8986\u76d6\u3002</p> <p>\u8fd9\u610f\u5473\u7740\u91cd\u8f7d\u51fd\u6570\u4ecd\u7136\u662f\u666e\u901a\u7684Python\u51fd\u6570\uff01 \u6ca1\u6709\u81ea\u52a8\u8c03\u5ea6\u5904\u7406\uff0c\u60a8\u5fc5\u987b\u624b\u52a8\u5904\u7406\u5b9e\u73b0\u4e2d\u7684\u4e0d\u540c\u7c7b\u578b\uff08\u4f8b\u5982\uff0c\u901a\u8fc7\u4f7f\u7528 <code>if</code> \u8bed\u53e5\u548c <code>isinstance</code> \u68c0\u67e5)\u3002</p> <p>\u5982\u679c\u8981\u5728\u5b58\u6839\u6587\u4ef6\u4e2d\u6dfb\u52a0\u91cd\u8f7d\uff0c\u5219\u5e94\u7701\u7565\u5b9e\u73b0\u51fd\u6570\uff1a\u5b58\u6839\u4e0d\u5305\u542b\u8fd0\u884c\u65f6\u903b\u8f91\u3002</p> <p>Note</p> <p>\u867d\u7136\u6211\u4eec\u53ef\u4ee5\u4f7f\u7528 \u201cpass\u201d \u5173\u952e\u5b57\u5c06\u534f\u53d8\u4e3b\u4f53\u7559\u7a7a\uff0c\u4f46\u66f4\u5e38\u89c1\u7684\u7ea6\u5b9a\u662f\u4f7f\u7528\u7701\u7565\u53f7\uff08\u201c...\u201d\uff09\u6587\u5b57\u3002</p> <p>An overloaded function must consist of two or more overload variants followed by an implementation. The variants and the implementations must be adjacent in the code: think of them as one indivisible unit.</p> <p>The variant bodies must all be empty; only the implementation is allowed to contain code. This is because at runtime, the variants are completely ignored: they're overridden by the final implementation function.</p> <p>This means that an overloaded function is still an ordinary Python function! There is no automatic dispatch handling and you must manually handle the different types in the implementation (e.g. by using <code>if</code> statements and <code>isinstance</code> checks).</p> <p>If you are adding an overload within a stub file, the implementation function should be omitted: stubs do not contain runtime logic.</p> <p>Note</p> <p>While we can leave the variant body empty using the <code>pass</code> keyword, the more common convention is to instead use the ellipsis (<code>...</code>) literal.</p>"},{"location":"mypy/more_types/#\u91cd\u8f7d\u7684\u7c7b\u578b\u8fdb\u884c\u8c03\u7528\u68c0\u67e5","title":"\u91cd\u8f7d\u7684\u7c7b\u578b\u8fdb\u884c\u8c03\u7528\u68c0\u67e5","text":"<p>Type checking calls to overloads</p> \u4e2d\u6587\u82f1\u6587 <p>\u5f53\u60a8\u8c03\u7528\u91cd\u8f7d\u51fd\u6570\u65f6\uff0cmypy \u5c06\u5728\u8003\u8651\u53c2\u6570\u7c7b\u578b\u548c\u6570\u91cf\u540e\uff0c\u901a\u8fc7\u9009\u62e9\u6700\u4f73\u5339\u914d\u534f\u53d8\u6765\u63a8\u65ad\u6b63\u786e\u7684\u8fd4\u56de\u7c7b\u578b\u3002 \u7136\u800c\uff0c\u8c03\u7528\u6c38\u8fdc\u4e0d\u4f1a\u6839\u636e\u5b9e\u73b0\u8fdb\u884c\u7c7b\u578b\u68c0\u67e5\u3002 \u8fd9\u5c31\u662f\u4e3a\u4ec0\u4e48 mypy \u4f1a\u62a5\u544a\u50cf \u201cmouse_event(5, 25, 3)\u201d \u8fd9\u6837\u7684\u8c03\u7528\u65e0\u6548\uff0c\u5373\u4f7f\u5b83\u4e0e\u5b9e\u73b0\u7b7e\u540d\u5339\u914d\u3002</p> <p>\u5982\u679c\u6709\u591a\u4e2a\u540c\u6837\u597d\u7684\u5339\u914d\u534f\u53d8\uff0cmypy \u5c06\u9009\u62e9\u6700\u5148\u5b9a\u4e49\u7684\u534f\u53d8\u3002 \u4f8b\u5982\uff0c\u8003\u8651\u4ee5\u4e0b\u7a0b\u5e8f\uff1a</p> <pre><code># For Python 3.8 and below you must use `typing.List` instead of `list`. e.g.\n# from typing import List\nfrom typing import overload\n\n@overload\ndef summarize(data: list[int]) -&gt; float: ...\n\n@overload\ndef summarize(data: list[str]) -&gt; str: ...\n\ndef summarize(data):\n    if not data:\n        return 0.0\n    elif isinstance(data[0], int):\n        # Do int specific code\n    else:\n        # Do str-specific code\n\n# What is the type of 'output'? float or str?\noutput = summarize([])\n</code></pre> <p><code>summarize([])</code> \u8c03\u7528\u5339\u914d\u4e24\u79cd\u534f\u53d8\uff1a\u7a7a\u5217\u8868\u53ef\u4ee5\u662f <code>list[int]</code> \u6216 <code>list[str]</code>\u3002 \u5728\u8fd9\u79cd\u60c5\u51b5\u4e0b\uff0cmypy \u5c06\u901a\u8fc7\u9009\u62e9\u7b2c\u4e00\u4e2a\u5339\u914d\u7684\u534f\u53d8\u6765\u6253\u7834\u5e73\u5c40\uff1a\u201coutput\u201d \u5c06\u5177\u6709 \u201cfloat\u201d \u7684\u63a8\u65ad\u7c7b\u578b\u3002 \u5b9e\u73b0\u8005\u8d1f\u8d23\u786e\u4fdd \u201csummarize\u201d \u5728\u8fd0\u884c\u65f6\u4ee5\u76f8\u540c\u7684\u65b9\u5f0f\u6253\u7834\u8054\u7cfb\u3002</p> <p>\u4f46\u662f\uff0c\u201c\u9009\u62e9\u7b2c\u4e00\u4e2a\u5339\u914d\u9879\u201d \u89c4\u5219\u6709\u4e24\u4e2a\u4f8b\u5916\u3002 \u9996\u5148\uff0c\u5982\u679c\u7531\u4e8e\u53c2\u6570\u7c7b\u578b\u4e3a\u201cAny\u201d\u800c\u5bfc\u81f4\u591a\u4e2a\u534f\u53d8\u5339\u914d\uff0c\u5219 mypy \u5c06\u4f7f\u63a8\u65ad\u7c7b\u578b\u4e5f\u4e3a\u201cAny\u201d\uff1a</p> <pre><code>dynamic_var: Any = some_dynamic_function()\n\n# output2 is of type 'Any'\noutput2 = summarize(dynamic_var)\n</code></pre> <p>\u5176\u6b21\uff0c\u5982\u679c\u7531\u4e8e\u4e00\u4e2a\u6216\u591a\u4e2a\u53c2\u6570\u662f\u8054\u5408\u800c\u5bfc\u81f4\u591a\u4e2a\u534f\u53d8\u5339\u914d\uff0c\u5219 mypy \u5c06\u4f7f\u63a8\u65ad\u7c7b\u578b\u6210\u4e3a\u5339\u914d\u534f\u53d8\u8fd4\u56de\u7684\u5e76\u96c6\uff1a</p> <pre><code>some_list: Union[list[int], list[str]]\n\n# output3 is of type 'Union[float, str]'\noutput3 = summarize(some_list)\n</code></pre> <p>Note</p> <p>\u7531\u4e8e\u201c\u9009\u62e9\u7b2c\u4e00\u4e2a\u5339\u914d\u201d\u89c4\u5219\uff0c\u66f4\u6539\u91cd\u8f7d\u534f\u53d8\u7684\u987a\u5e8f\u53ef\u4ee5\u66f4\u6539 mypy \u7c7b\u578b\u68c0\u67e5\u7a0b\u5e8f\u7684\u65b9\u5f0f\u3002</p> <p>\u4e3a\u4e86\u5c3d\u91cf\u51cf\u5c11\u6f5c\u5728\u95ee\u9898\uff0c\u6211\u4eec\u5efa\u8bae\u60a8\uff1a</p> <ol> <li>\u786e\u4fdd\u60a8\u7684\u91cd\u8f7d\u534f\u53d8\u4ee5\u4e0e\u5b9e\u73b0\u4e2d\u8fd0\u884c\u65f6\u68c0\u67e5\uff08\u4f8b\u5982 <code>isinstance</code> \u68c0\u67e5\uff09\u76f8\u540c\u7684\u987a\u5e8f\u5217\u51fa\u3002</li> <li>\u6309\u7167\u4ece\u6700\u5177\u4f53\u5230\u6700\u4e0d\u5177\u4f53\u7684\u987a\u5e8f\u5bf9\u534f\u53d8\u548c\u8fd0\u884c\u65f6\u68c0\u67e5\u8fdb\u884c\u6392\u5e8f\u3002\uff08\u6709\u5173\u793a\u4f8b\uff0c\u8bf7\u53c2\u9605\u4ee5\u4e0b\u90e8\u5206\uff09\u3002</li> </ol> <p>When you call an overloaded function, mypy will infer the correct return type by picking the best matching variant, after taking into consideration both the argument types and arity. However, a call is never type checked against the implementation. This is why mypy will report calls like <code>mouse_event(5, 25, 3)</code> as being invalid even though it matches the implementation signature.</p> <p>If there are multiple equally good matching variants, mypy will select the variant that was defined first. For example, consider the following program:</p> <pre><code># For Python 3.8 and below you must use `typing.List` instead of `list`. e.g.\n# from typing import List\nfrom typing import overload\n\n@overload\ndef summarize(data: list[int]) -&gt; float: ...\n\n@overload\ndef summarize(data: list[str]) -&gt; str: ...\n\ndef summarize(data):\n    if not data:\n        return 0.0\n    elif isinstance(data[0], int):\n        # Do int specific code\n    else:\n        # Do str-specific code\n\n# What is the type of 'output'? float or str?\noutput = summarize([])\n</code></pre> <p>The <code>summarize([])</code> call matches both variants: an empty list could be either a <code>list[int]</code> or a <code>list[str]</code>. In this case, mypy will break the tie by picking the first matching variant: <code>output</code> will have an inferred type of <code>float</code>. The implementor is responsible for making sure <code>summarize</code> breaks ties in the same way at runtime.</p> <p>However, there are two exceptions to the \"pick the first match\" rule. First, if multiple variants match due to an argument being of type <code>Any</code>, mypy will make the inferred type also be <code>Any</code>:</p> <pre><code>dynamic_var: Any = some_dynamic_function()\n\n# output2 is of type 'Any'\noutput2 = summarize(dynamic_var)\n</code></pre> <p>Second, if multiple variants match due to one or more of the arguments being a union, mypy will make the inferred type be the union of the matching variant returns:</p> <pre><code>some_list: Union[list[int], list[str]]\n\n# output3 is of type 'Union[float, str]'\noutput3 = summarize(some_list)\n</code></pre> <p>Note</p> <p>Due to the \"pick the first match\" rule, changing the order of your overload variants can change how mypy type checks your program.</p> <p>To minimize potential issues, we recommend that you:</p> <ol> <li>Make sure your overload variants are listed in the same order as the runtime checks (e.g. <code>isinstance</code> checks) in your implementation.</li> <li>Order your variants and runtime checks from most to least specific. (See the following section for an example).</li> </ol>"},{"location":"mypy/more_types/#\u534f\u53d8\u7684\u7c7b\u578b\u68c0\u67e5","title":"\u534f\u53d8\u7684\u7c7b\u578b\u68c0\u67e5","text":"<p>Type checking the variants</p> \u4e2d\u6587\u82f1\u6587 <p>Mypy \u5c06\u5bf9\u60a8\u7684\u91cd\u8f7d\u534f\u53d8\u5b9a\u4e49\u6267\u884c\u591a\u6b21\u68c0\u67e5\uff0c\u4ee5\u786e\u4fdd\u5b83\u4eec\u7684\u884c\u4e3a\u7b26\u5408\u9884\u671f\u3002 \u9996\u5148\uff0cmypy \u5c06\u68c0\u67e5\u5e76\u786e\u4fdd\u6ca1\u6709\u91cd\u8f7d\u534f\u53d8\u906e\u76d6\u540e\u7eed\u534f\u53d8\u3002 \u4f8b\u5982\uff0c\u8003\u8651\u4ee5\u4e0b\u51fd\u6570\uff0c\u5b83\u5c06\u4e24\u4e2a\u201cExpression\u201d\u5bf9\u8c61\u52a0\u5728\u4e00\u8d77\uff0c\u5e76\u5305\u542b\u4e00\u4e2a\u7279\u6b8a\u60c5\u51b5\u6765\u5904\u7406\u63a5\u6536\u4e24\u4e2a\u201cLiteral\u201d\u7c7b\u578b\uff1a</p> <pre><code>from typing import overload, Union\n\nclass Expression:\n    # ...snip...\n\nclass Literal(Expression):\n    # ...snip...\n\n# Warning -- the first overload variant shadows the second!\n\n@overload\ndef add(left: Expression, right: Expression) -&gt; Expression: ...\n\n@overload\ndef add(left: Literal, right: Literal) -&gt; Literal: ...\n\ndef add(left: Expression, right: Expression) -&gt; Expression:\n    # ...snip...\n</code></pre> <p>\u867d\u7136\u6b64\u4ee3\u7801\u7247\u6bb5\u5728\u6280\u672f\u4e0a\u662f\u7c7b\u578b\u5b89\u5168\u7684\uff0c\u4f46\u5b83\u786e\u5b9e\u5305\u542b\u53cd\u6a21\u5f0f\uff1a\u6c38\u8fdc\u4e0d\u4f1a\u9009\u62e9\u7b2c\u4e8c\u4e2a\u534f\u53d8\uff01 \u5982\u679c\u6211\u4eec\u5c1d\u8bd5\u8c03\u7528\u201cadd(Literal(3), Literal(4))\u201d\uff0cmypy \u5c06\u59cb\u7ec8\u9009\u62e9\u7b2c\u4e00\u4e2a\u534f\u53d8\u5e76\u5c06\u51fd\u6570\u8c03\u7528\u8bc4\u4f30\u4e3a\u201cExpression\u201d\u7c7b\u578b\uff0c\u800c\u4e0d\u662f\u201cLiteral\u201d\u3002 \u8fd9\u662f\u56e0\u4e3a <code>Literal</code> \u662f <code>Expression</code> \u7684\u5b50\u7c7b\u578b\uff0c\u8fd9\u610f\u5473\u7740\u201c\u9009\u62e9\u7b2c\u4e00\u4e2a\u5339\u914d\u201d\u89c4\u5219\u5728\u8003\u8651\u7b2c\u4e00\u6b21\u91cd\u8f7d\u540e\u5c06\u59cb\u7ec8\u505c\u6b62\u3002</p> <p>\u56e0\u4e3a\u62e5\u6709\u6c38\u8fdc\u65e0\u6cd5\u5339\u914d\u7684\u91cd\u8f7d\u534f\u53d8\u51e0\u4e4e\u80af\u5b9a\u662f\u4e00\u4e2a\u9519\u8bef\uff0c\u6240\u4ee5 mypy \u5c06\u62a5\u544a\u9519\u8bef\u3002 \u8981\u4fee\u590d\u8be5\u9519\u8bef\uff0c\u6211\u4eec\u53ef\u4ee5 1) \u5220\u9664\u7b2c\u4e8c\u4e2a\u91cd\u8f7d\u6216 2) \u4ea4\u6362\u91cd\u8f7d\u7684\u987a\u5e8f\uff1a</p> <pre><code># Everything is ok now -- the variants are correctly ordered\n# from most to least specific.\n\n@overload\ndef add(left: Literal, right: Literal) -&gt; Literal: ...\n\n@overload\ndef add(left: Expression, right: Expression) -&gt; Expression: ...\n\ndef add(left: Expression, right: Expression) -&gt; Expression:\n    # ...snip...\n</code></pre> <p>Mypy \u8fd8\u5c06\u5bf9\u4e0d\u540c\u7684\u534f\u53d8\u8fdb\u884c\u7c7b\u578b\u68c0\u67e5\uff0c\u5e76\u6807\u8bb0\u4efb\u4f55\u5177\u6709\u672c\u8d28\u4e0a\u4e0d\u5b89\u5168\u7684\u91cd\u53e0\u534f\u53d8\u7684\u91cd\u8f7d\u3002 \u4f8b\u5982\uff0c\u8003\u8651\u4ee5\u4e0b\u4e0d\u5b89\u5168\u91cd\u8f7d\u5b9a\u4e49\uff1a</p> <pre><code>from typing import overload, Union\n\n@overload\ndef unsafe_func(x: int) -&gt; int: ...\n\n@overload\ndef unsafe_func(x: object) -&gt; str: ...\n\ndef unsafe_func(x: object) -&gt; Union[int, str]:\n    if isinstance(x, int):\n        return 42\n    else:\n        return \"some string\"\n</code></pre> <p>\u4ece\u8868\u9762\u4e0a\u770b\uff0c\u8fd9\u4e2a\u51fd\u6570\u5b9a\u4e49\u4f3c\u4e4e\u6ca1\u95ee\u9898\u3002 \u4f46\u662f\uff0c\u5f53\u6211\u4eec\u5c1d\u8bd5\u50cf\u8fd9\u6837\u4f7f\u7528\u5b83\u65f6\uff0c\u4f1a\u5bfc\u81f4\u63a8\u65ad\u7c7b\u578b\u4e0e\u5b9e\u9645\u8fd0\u884c\u65f6\u7c7b\u578b\u4e4b\u95f4\u5b58\u5728\u5dee\u5f02\uff1a</p> <pre><code>some_obj: object = 42\nunsafe_func(some_obj) + \" danger danger\"  # Type checks, yet crashes at runtime!\n</code></pre> <p>\u7531\u4e8e <code>some_obj</code> \u7684\u7c7b\u578b\u4e3a <code>object</code>\uff0cmypy \u5c06\u51b3\u5b9a <code>unsafe_func</code> \u5fc5\u987b\u8fd4\u56de <code>str</code> \u7c7b\u578b\u7684\u5185\u5bb9\uff0c\u5e76\u4e14 \u603b\u7ed3\u4ee5\u4e0a\u5185\u5bb9\u5c06\u8fdb\u884c\u7c7b\u578b\u68c0\u67e5\u3002 \u4f46\u5b9e\u9645\u4e0a\uff0c<code>unsafe_func</code>\u4f1a\u8fd4\u56de\u4e00\u4e2aint\uff0c\u5bfc\u81f4\u4ee3\u7801\u5728\u8fd0\u884c\u65f6\u5d29\u6e83\uff01</p> <p>\u4e3a\u4e86\u9632\u6b62\u6b64\u7c7b\u95ee\u9898\uff0cmypy \u5c06\u5c3d\u6700\u5927\u52aa\u529b\u68c0\u6d4b\u5e76\u7981\u6b62\u672c\u8d28\u4e0a\u4e0d\u5b89\u5168\u7684\u91cd\u53e0\u91cd\u8f7d\u3002 \u5f53\u4ee5\u4e0b\u4e24\u4e2a\u6761\u4ef6\u90fd\u6210\u7acb\u65f6\uff0c\u4e24\u4e2a\u53d8\u4f53\u88ab\u89c6\u4e3a\u4e0d\u5b89\u5168\u91cd\u53e0\uff1a</p> <ol> <li>\u7b2c\u4e00\u4e2a\u53d8\u4f53\u7684\u6240\u6709\u53c2\u6570\u90fd\u4e0e\u7b2c\u4e8c\u4e2a\u53d8\u4f53\u517c\u5bb9\u3002</li> <li>\u7b2c\u4e00\u4e2a\u53d8\u4f53\u7684\u8fd4\u56de\u7c7b\u578b\u4e0e\u7b2c\u4e8c\u4e2a\u53d8\u4f53\u201c\u4e0d\u201d\u517c\u5bb9\uff08\u4f8b\u5982\u4e0d\u662f\u5176\u5b50\u7c7b\u578b\uff09\u3002</li> </ol> <p>\u56e0\u6b64\uff0c\u5728\u6b64\u793a\u4f8b\u4e2d\uff0c\u7b2c\u4e00\u4e2a\u53d8\u4f53\u4e2d\u7684 \u201cint\u201d \u53c2\u6570\u662f\u7b2c\u4e8c\u4e2a\u53d8\u4f53\u4e2d \u201cobject\u201d \u53c2\u6570\u7684\u5b50\u7c7b\u578b\uff0c\u4f46 \u201cint\u201d \u8fd4\u56de\u7c7b\u578b\u4e0d\u662f \u201cstr\u201d \u7684\u5b50\u7c7b\u578b\u3002 \u8fd9\u4e24\u4e2a\u6761\u4ef6\u90fd\u6210\u7acb\uff0c\u56e0\u6b64 mypy \u4f1a\u6b63\u786e\u5730\u5c06 <code>unsafe_func</code> \u6807\u8bb0\u4e3a\u4e0d\u5b89\u5168\u3002</p> <p>\u4f46\u662f\uff0cmypy \u4e0d\u4f1a\u68c0\u6d4b \u6240\u6709 \u4e0d\u5b89\u5168\u7684\u91cd\u8f7d\u4f7f\u7528\u3002 \u4f8b\u5982\uff0c\u5047\u8bbe\u6211\u4eec\u4fee\u6539\u4e0a\u9762\u7684\u4ee3\u7801\u7247\u6bb5\uff0c\u4f7f\u5176\u8c03\u7528 \u201csummarize\u201d \u800c\u4e0d\u662f \u201cunsafe_func\u201d \uff1a</p> <pre><code>some_list: list[str] = []\nsummarize(some_list) + \"danger danger\"  # Type safe, yet crashes at runtime!\n</code></pre> <p>\u6211\u4eec\u5728\u8fd9\u91cc\u9047\u5230\u4e86\u7c7b\u4f3c\u7684\u95ee\u9898\u3002 \u8be5\u7a0b\u5e8f\u7c7b\u578b\u68c0\u67e5\u6211\u4eec\u662f\u5426\u53ea\u67e5\u770b\u91cd\u8f7d\u4e0a\u7684\u6ce8\u91ca\u3002 \u4f46\u7531\u4e8e\u201csummarize(...)\u201d\u88ab\u8bbe\u8ba1\u4e3a\u5728\u63a5\u6536\u5230\u7a7a\u5217\u8868\u65f6\u504f\u5411\u4e8e\u8fd4\u56de\u6d6e\u70b9\u6570\uff0c\u56e0\u6b64\u8be5\u7a0b\u5e8f\u5b9e\u9645\u4e0a\u4f1a\u5728\u8fd0\u884c\u65f6\u5d29\u6e83\u3002</p> <p>mypy \u6ca1\u6709\u5c06\u50cf\u201csummarize\u201d\u8fd9\u6837\u7684\u5b9a\u4e49\u6807\u8bb0\u4e3a\u6f5c\u5728\u4e0d\u5b89\u5168\u7684\u539f\u56e0\u662f\uff0c\u5982\u679c\u8fd9\u6837\u505a\uff0c\u7f16\u5199\u5b89\u5168\u91cd\u8f7d\u5c06\u975e\u5e38\u56f0\u96be\u3002 \u4f8b\u5982\uff0c\u5047\u8bbe\u6211\u4eec\u5b9a\u4e49\u4e00\u4e2a\u5177\u6709\u4e24\u4e2a\u5206\u522b\u63a5\u53d7\u7c7b\u578b\u201cA\u201d\u548c\u201cB\u201d\u7684\u53d8\u4f53\u7684\u91cd\u8f7d\u3002 \u5373\u4f7f\u8fd9\u4e24\u79cd\u7c7b\u578b\u5b8c\u5168\u4e0d\u76f8\u5173\uff0c\u7528\u6237\u4ecd\u7136\u53ef\u80fd\u901a\u8fc7\u4f20\u5165\u7ee7\u627f\u81ea\u201cA\u201d\u548c\u201cB\u201d\u7684\u7b2c\u4e09\u79cd\u7c7b\u578b\u201cC\u201d\u7684\u503c\u6765\u89e6\u53d1\u4e0e\u4e0a\u8ff0\u7c7b\u4f3c\u7684\u8fd0\u884c\u65f6\u9519\u8bef\u3002</p> <p>\u503c\u5f97\u5e86\u5e78\u7684\u662f\uff0c\u6b64\u7c7b\u60c5\u51b5\u76f8\u5bf9\u8f83\u5c11\u3002 \u7136\u800c\uff0c\u8fd9\u786e\u5b9e\u610f\u5473\u7740\uff0c\u5728\u8bbe\u8ba1\u6216\u4f7f\u7528\u91cd\u8f7d\u51fd\u6570\u65f6\u5e94\u8be5\u5c0f\u5fc3\u8c28\u614e\uff0c\u56e0\u4e3a\u8be5\u91cd\u8f7d\u51fd\u6570\u53ef\u80fd\u4f1a\u63a5\u6536\u4e24\u4e2a\u770b\u4f3c\u4e0d\u76f8\u5173\u7c7b\u578b\u7684\u5b9e\u4f8b\u503c\u3002</p> <p>Mypy will perform several checks on your overload variant definitions to ensure they behave as expected. First, mypy will check and make sure that no overload variant is shadowing a subsequent one. For example, consider the following function which adds together two <code>Expression</code> objects, and contains a special-case to handle receiving two <code>Literal</code> types:</p> <pre><code>from typing import overload, Union\n\nclass Expression:\n    # ...snip...\n\nclass Literal(Expression):\n    # ...snip...\n\n# Warning -- the first overload variant shadows the second!\n\n@overload\ndef add(left: Expression, right: Expression) -&gt; Expression: ...\n\n@overload\ndef add(left: Literal, right: Literal) -&gt; Literal: ...\n\ndef add(left: Expression, right: Expression) -&gt; Expression:\n    # ...snip...\n</code></pre> <p>While this code snippet is technically type-safe, it does contain an anti-pattern: the second variant will never be selected! If we try calling <code>add(Literal(3), Literal(4))</code>, mypy will always pick the first variant and evaluate the function call to be of type <code>Expression</code>, not <code>Literal</code>. This is because <code>Literal</code> is a subtype of <code>Expression</code>, which means the \"pick the first match\" rule will always halt after considering the first overload.</p> <p>Because having an overload variant that can never be matched is almost certainly a mistake, mypy will report an error. To fix the error, we can either 1) delete the second overload or 2) swap the order of the overloads:</p> <pre><code># Everything is ok now -- the variants are correctly ordered\n# from most to least specific.\n\n@overload\ndef add(left: Literal, right: Literal) -&gt; Literal: ...\n\n@overload\ndef add(left: Expression, right: Expression) -&gt; Expression: ...\n\ndef add(left: Expression, right: Expression) -&gt; Expression:\n    # ...snip...\n</code></pre> <p>Mypy will also type check the different variants and flag any overloads that have inherently unsafely overlapping variants. For example, consider the following unsafe overload definition:</p> <pre><code>from typing import overload, Union\n\n@overload\ndef unsafe_func(x: int) -&gt; int: ...\n\n@overload\ndef unsafe_func(x: object) -&gt; str: ...\n\ndef unsafe_func(x: object) -&gt; Union[int, str]:\n    if isinstance(x, int):\n        return 42\n    else:\n        return \"some string\"\n</code></pre> <p>On the surface, this function definition appears to be fine. However, it will result in a discrepancy between the inferred type and the actual runtime type when we try using it like so:</p> <pre><code>some_obj: object = 42\nunsafe_func(some_obj) + \" danger danger\"  # Type checks, yet crashes at runtime!\n</code></pre> <p>Since <code>some_obj</code> is of type <code>object</code>, mypy will decide that <code>unsafe_func</code> must return something of type <code>str</code> and concludes the above will type check. But in reality, <code>unsafe_func</code> will return an int, causing the code to crash at runtime!</p> <p>To prevent these kinds of issues, mypy will detect and prohibit inherently unsafely overlapping overloads on a best-effort basis. Two variants are considered unsafely overlapping when both of the following are true:</p> <ol> <li>All of the arguments of the first variant are compatible with the second.</li> <li>The return type of the first variant is not compatible with (e.g. is not a subtype of) the second.</li> </ol> <p>So in this example, the <code>int</code> argument in the first variant is a subtype of the <code>object</code> argument in the second, yet the <code>int</code> return type is not a subtype of <code>str</code>. Both conditions are true, so mypy will correctly flag <code>unsafe_func</code> as being unsafe.</p> <p>However, mypy will not detect all unsafe uses of overloads. For example, suppose we modify the above snippet so it calls <code>summarize</code> instead of <code>unsafe_func</code>:</p> <pre><code>some_list: list[str] = []\nsummarize(some_list) + \"danger danger\"  # Type safe, yet crashes at runtime!\n</code></pre> <p>We run into a similar issue here. This program type checks if we look just at the annotations on the overloads. But since <code>summarize(...)</code> is designed to be biased towards returning a float when it receives an empty list, this program will actually crash during runtime.</p> <p>The reason mypy does not flag definitions like <code>summarize</code> as being potentially unsafe is because if it did, it would be extremely difficult to write a safe overload. For example, suppose we define an overload with two variants that accept types <code>A</code> and <code>B</code> respectively. Even if those two types were completely unrelated, the user could still potentially trigger a runtime error similar to the ones above by passing in a value of some third type <code>C</code> that inherits from both <code>A</code> and <code>B</code>.</p> <p>Thankfully, these types of situations are relatively rare. What this does mean, however, is that you should exercise caution when designing or using an overloaded function that can potentially receive values that are an instance of two seemingly unrelated types.</p>"},{"location":"mypy/more_types/#\u7c7b\u578b\u68c0\u67e5\u7684\u5b9e\u73b0","title":"\u7c7b\u578b\u68c0\u67e5\u7684\u5b9e\u73b0","text":"<p>Type checking the implementation</p> \u4e2d\u6587\u82f1\u6587 <p>\u5b9e\u73b0\u7684\u4e3b\u4f53\u6839\u636e\u5b9e\u73b0\u4e0a\u63d0\u4f9b\u7684\u7c7b\u578b\u63d0\u793a\u8fdb\u884c\u7c7b\u578b\u68c0\u67e5\u3002 \u4f8b\u5982\uff0c\u5728\u4e0a\u9762\u7684 \u201cMyList\u201d \u793a\u4f8b\u4e2d\uff0c\u4e3b\u4f53\u4e2d\u7684\u4ee3\u7801\u4f7f\u7528\u53c2\u6570\u5217\u8868 \u201cindex: Union[int, slice]\u201d \u548c\u8fd4\u56de\u7c7b\u578b \u201cUnion[T, Sequence[T]]\u201d \u8fdb\u884c\u68c0\u67e5\u3002 \u5982\u679c\u5b9e\u73b0\u4e0a\u6ca1\u6709\u6ce8\u91ca\uff0c\u5219\u4e0d\u4f1a\u5bf9\u4e3b\u4f53\u8fdb\u884c\u7c7b\u578b\u68c0\u67e5\u3002 \u5982\u679c\u60a8\u60f3\u5f3a\u5236 mypy \u68c0\u67e5\u4e3b\u4f53\uff0c\u8bf7\u4f7f\u7528 <code>--check-untyped-defs</code> \u6807\u5fd7\uff08<code>\u66f4\u591a\u8be6\u7ec6\u4fe1\u606f\u8bf7\u53c2\u89c1\u6b64\u5904</code>\uff09\u3002</p> <p>\u8fd9\u4e9b\u53d8\u4f53\u8fd8\u5fc5\u987b\u4e0e\u5b9e\u73b0\u7c7b\u578b\u63d0\u793a\u517c\u5bb9\u3002 \u5728 \u201cMyList\u201d \u793a\u4f8b\u4e2d\uff0cmypy \u5c06\u68c0\u67e5\u53c2\u6570\u7c7b\u578b\u201cint\u201d\u548c\u8fd4\u56de\u7c7b\u578b\u201cT\u201d\u662f\u5426\u4e0e\u7b2c\u4e00\u4e2a\u53d8\u4f53\u7684\u201cUnion[int, slice]\u201d\u548c\u201cUnion[T, Sequence]\u201d\u517c\u5bb9\u3002 \u5bf9\u4e8e\u7b2c\u4e8c\u4e2a\u53d8\u4f53\uff0c\u5b83\u9a8c\u8bc1\u53c2\u6570\u7c7b\u578b\u201cslice\u201d\u548c\u8fd4\u56de\u7c7b\u578b\u201cSequence[T]\u201d\u4e0e\u201cUnion[int, slice]\u201d\u548c\u201cUnion[T, Sequence]\u201d\u517c\u5bb9\u3002</p> <p>Note</p> <p>\u4e0a\u9762\u8bb0\u5f55\u7684\u91cd\u8f7d\u8bed\u4e49\u662f\u4ece mypy 0.620 \u5f00\u59cb\u7684\u65b0\u8bed\u4e49\u3002</p> <p>\u4ee5\u524d\uff0cmypy \u7528\u4e8e\u5bf9\u6240\u6709\u91cd\u8f7d\u53d8\u4f53\u6267\u884c\u7c7b\u578b\u64e6\u9664\u3002 \u4f8b\u5982\uff0c\u4e0a\u4e00\u8282\u4e2d\u7684 \u201csummarize\u201d \u793a\u4f8b\u8fc7\u53bb\u662f\u975e\u6cd5\u7684\uff0c\u56e0\u4e3a\u201clist[str]\u201d\u548c\u201clist[int]\u201d\u90fd\u88ab\u5220\u9664\u4e3a\u201clist[Any]\u201d\u3002 mypy 0.620 \u4e2d\u5220\u9664\u4e86\u6b64\u9650\u5236\u3002</p> <p>Mypy \u4e4b\u524d\u8fd8\u4f7f\u7528\u4e0d\u540c\u7684\u7b97\u6cd5\u6765\u9009\u62e9\u6700\u4f73\u5339\u914d\u53d8\u4f53\u3002 \u5982\u679c\u6b64\u7b97\u6cd5\u672a\u80fd\u627e\u5230\u5339\u914d\u9879\uff0c\u5219\u9ed8\u8ba4\u8fd4\u56de\u201cAny\u201d\u3002 \u65b0\u7b97\u6cd5\u4f7f\u7528\u201c\u9009\u62e9\u7b2c\u4e00\u4e2a\u5339\u914d\u201d\u89c4\u5219\uff0c\u5e76\u4e14\u4ec5\u5f53\u8f93\u5165\u53c2\u6570\u4e5f\u5305\u542b\u201cAny\u201d\u65f6\u624d\u4f1a\u56de\u9000\u5230\u8fd4\u56de\u201cAny\u201d\u3002</p> <p>The body of an implementation is type-checked against the type hints provided on the implementation. For example, in the <code>MyList</code> example up above, the code in the body is checked with argument list <code>index: Union[int, slice]</code> and a return type of <code>Union[T, Sequence[T]]</code>. If there are no annotations on the implementation, then the body is not type checked. If you want to force mypy to check the body anyways, use the <code>--check-untyped-defs</code> flag (<code>more details here</code>).</p> <p>The variants must also also be compatible with the implementation type hints. In the <code>MyList</code> example, mypy will check that the parameter type <code>int</code> and the return type <code>T</code> are compatible with <code>Union[int, slice]</code> and <code>Union[T, Sequence]</code> for the first variant. For the second variant it verifies the parameter type <code>slice</code> and the return type <code>Sequence[T]</code> are compatible with <code>Union[int, slice]</code> and <code>Union[T, Sequence]</code>.</p> <p>Note</p> <p>The overload semantics documented above are new as of mypy 0.620.</p> <p>Previously, mypy used to perform type erasure on all overload variants. For example, the <code>summarize</code> example from the previous section used to be illegal because <code>list[str]</code> and <code>list[int]</code> both erased to just <code>list[Any]</code>. This restriction was removed in mypy 0.620.</p> <p>Mypy also previously used to select the best matching variant using a different algorithm. If this algorithm failed to find a match, it would default to returning <code>Any</code>. The new algorithm uses the \"pick the first match\" rule and will fall back to returning <code>Any</code> only if the input arguments also contain <code>Any</code>.</p>"},{"location":"mypy/more_types/#\u6761\u4ef6\u91cd\u8f7d","title":"\u6761\u4ef6\u91cd\u8f7d","text":"<p>Conditional overloads</p> \u4e2d\u6587\u82f1\u6587 <p>\u6709\u65f6\u6709\u6761\u4ef6\u5730\u5b9a\u4e49\u91cd\u8f7d\u5f88\u6709\u7528\u3002 \u5e38\u89c1\u7528\u4f8b\u5305\u62ec\u8fd0\u884c\u65f6\u4e0d\u53ef\u7528\u7684\u7c7b\u578b\u6216\u4ec5\u5b58\u5728\u4e8e\u7279\u5b9a Python \u7248\u672c\u4e2d\u7684\u7c7b\u578b\u3002 \u6240\u6709\u73b0\u6709\u7684\u8d85\u8f7d\u89c4\u5219\u4ecd\u7136\u9002\u7528\u3002 \u4f8b\u5982\uff0c\u5fc5\u987b\u81f3\u5c11\u6709\u4e24\u4e2a\u91cd\u8f7d\u3002</p> <p>Note</p> <p>Mypy \u53ea\u80fd\u63a8\u65ad\u6709\u9650\u6570\u91cf\u7684\u6761\u4ef6\u3002 \u76ee\u524d\u652f\u6301\u7684\u5305\u62ec <code>TYPE_CHECKING</code>, <code>MYPY</code>, <code>version_and_platform_checks</code>, <code>--always-true</code>, \u548c <code>--always-false</code> \u7b49.</p> <pre><code>from typing import TYPE_CHECKING, Any, overload\n\nif TYPE_CHECKING:\n    class A: ...\n    class B: ...\n\n\nif TYPE_CHECKING:\n    @overload\n    def func(var: A) -&gt; A: ...\n\n    @overload\n    def func(var: B) -&gt; B: ...\n\ndef func(var: Any) -&gt; Any:\n    return var\n\nreveal_type(func(A()))  # Revealed type is \"A\"\n</code></pre> <pre><code># flags: --python-version 3.10\nimport sys\nfrom typing import Any, overload\n\nclass A: ...\nclass B: ...\nclass C: ...\nclass D: ...\n\n\nif sys.version_info &lt; (3, 7):\n    @overload\n    def func(var: A) -&gt; A: ...\n\nelif sys.version_info &gt;= (3, 10):\n    @overload\n    def func(var: B) -&gt; B: ...\n\nelse:\n    @overload\n    def func(var: C) -&gt; C: ...\n\n@overload\ndef func(var: D) -&gt; D: ...\n\ndef func(var: Any) -&gt; Any:\n    return var\n\n\nreveal_type(func(B()))  # Revealed type is \"B\"\nreveal_type(func(C()))  # No overload variant of \"func\" matches argument type \"C\"\n    # Possible overload variants:\n    #     def func(var: B) -&gt; B\n    #     def func(var: D) -&gt; D\n    # Revealed type is \"Any\"\n</code></pre> <p>Note</p> <p>\u5728\u6700\u540e\u4e00\u4e2a\u793a\u4f8b\u4e2d\uff0cmypy \u4f7f\u7528 <code>--python-version 3.10</code> \u6267\u884c.</p> <p>\u56e0\u6b64\uff0c\u6761\u4ef6\u201csys.version_info &gt;= (3, 10)\u201d\u5c06\u5339\u914d\uff0c\u5e76\u4e14\u5c06\u6dfb\u52a0\u201cB\u201d\u7684\u91cd\u8f7d\u3002</p> <p><code>A</code> \u548c <code>C</code> \u7684\u91cd\u8f7d\u88ab\u5ffd\u7565\uff01</p> <p>\u201cD\u201d\u7684\u91cd\u8f7d\u6ca1\u6709\u6761\u4ef6\u5b9a\u4e49\uff0c\u56e0\u6b64\u4e5f\u88ab\u6dfb\u52a0\u3002</p> <p>\u5f53 mypy \u65e0\u6cd5\u63a8\u65ad\u6761\u4ef6\u59cb\u7ec8\u4e3a\u201cTrue\u201d\u6216\u59cb\u7ec8\u4e3a\u201cFalse\u201d\u65f6\uff0c\u4f1a\u53d1\u51fa\u9519\u8bef\u3002</p> <pre><code>from typing import Any, overload\n\nclass A: ...\nclass B: ...\n\n\ndef g(bool_var: bool) -&gt; None:\n    if bool_var:  # Condition can't be inferred, unable to merge overloads\n        @overload\n        def func(var: A) -&gt; A: ...\n\n        @overload\n        def func(var: B) -&gt; B: ...\n\n    def func(var: Any) -&gt; Any: ...\n\n    reveal_type(func(A()))  # Revealed type is \"Any\"\n</code></pre> <p>Sometimes it is useful to define overloads conditionally. Common use cases include types that are unavailable at runtime or that only exist in a certain Python version. All existing overload rules still apply. For example, there must be at least two overloads.</p> <p>Note</p> <p>Mypy can only infer a limited number of conditions. Supported ones currently include <code>TYPE_CHECKING</code>, <code>MYPY</code>, <code>version_and_platform_checks</code>, <code>--always-true</code>, and <code>--always-false</code> values.</p> <pre><code>from typing import TYPE_CHECKING, Any, overload\n\nif TYPE_CHECKING:\n    class A: ...\n    class B: ...\n\n\nif TYPE_CHECKING:\n    @overload\n    def func(var: A) -&gt; A: ...\n\n    @overload\n    def func(var: B) -&gt; B: ...\n\ndef func(var: Any) -&gt; Any:\n    return var\n\nreveal_type(func(A()))  # Revealed type is \"A\"\n</code></pre> <pre><code># flags: --python-version 3.10\nimport sys\nfrom typing import Any, overload\n\nclass A: ...\nclass B: ...\nclass C: ...\nclass D: ...\n\n\nif sys.version_info &lt; (3, 7):\n    @overload\n    def func(var: A) -&gt; A: ...\n\nelif sys.version_info &gt;= (3, 10):\n    @overload\n    def func(var: B) -&gt; B: ...\n\nelse:\n    @overload\n    def func(var: C) -&gt; C: ...\n\n@overload\ndef func(var: D) -&gt; D: ...\n\ndef func(var: Any) -&gt; Any:\n    return var\n\n\nreveal_type(func(B()))  # Revealed type is \"B\"\nreveal_type(func(C()))  # No overload variant of \"func\" matches argument type \"C\"\n    # Possible overload variants:\n    #     def func(var: B) -&gt; B\n    #     def func(var: D) -&gt; D\n    # Revealed type is \"Any\"\n</code></pre> <p>Note</p> <p>In the last example, mypy is executed with <code>--python-version 3.10</code>.</p> <p>Therefore, the condition <code>sys.version_info &gt;= (3, 10)</code> will match and the overload for <code>B</code> will be added.</p> <p>The overloads for <code>A</code> and <code>C</code> are ignored!</p> <p>The overload for <code>D</code> is not defined conditionally and thus is also added.</p> <p>When mypy cannot infer a condition to be always <code>True</code> or always <code>False</code>, an error is emitted.</p> <pre><code>from typing import Any, overload\n\nclass A: ...\nclass B: ...\n\n\ndef g(bool_var: bool) -&gt; None:\n    if bool_var:  # Condition can't be inferred, unable to merge overloads\n        @overload\n        def func(var: A) -&gt; A: ...\n\n        @overload\n        def func(var: B) -&gt; B: ...\n\n    def func(var: Any) -&gt; Any: ...\n\n    reveal_type(func(A()))  # Revealed type is \"Any\"\n</code></pre>"},{"location":"mypy/more_types/#self\u7c7b\u578b\u7684\u9ad8\u7ea7\u7528\u6cd5","title":"self\u7c7b\u578b\u7684\u9ad8\u7ea7\u7528\u6cd5","text":"<p>Advanced uses of self-types</p> \u4e2d\u6587\u82f1\u6587 <p>\u901a\u5e38\uff0cmypy \u4e0d\u9700\u8981\u4e3a\u5b9e\u4f8b\u548c\u7c7b\u65b9\u6cd5\u7684\u7b2c\u4e00\u4e2a\u53c2\u6570\u6dfb\u52a0\u6ce8\u91ca\u3002 \u7136\u800c\uff0c\u5bf9\u4e8e\u67d0\u4e9b\u7f16\u7a0b\u6a21\u5f0f\uff0c\u5b83\u4eec\u53ef\u80fd\u9700\u8981\u5177\u6709\u66f4\u7cbe\u786e\u7684\u9759\u6001\u7c7b\u578b\u3002</p> <p>Normally, mypy doesn't require annotations for the first arguments of instance and class methods. However, they may be needed to have more precise static typing for certain programming patterns.</p>"},{"location":"mypy/more_types/#\u6cdb\u578b\u7c7b\u4e2d\u7684\u53d7\u9650\u65b9\u6cd5","title":"\u6cdb\u578b\u7c7b\u4e2d\u7684\u53d7\u9650\u65b9\u6cd5","text":"<p>Restricted methods in generic classes</p> \u4e2d\u6587\u82f1\u6587 <p>\u5728\u6cdb\u578b\u7c7b\u4e2d\uff0c\u67d0\u4e9b\u65b9\u6cd5\u53ef\u80fd\u53ea\u5141\u8bb8\u4e3a\u7c7b\u578b\u53c2\u6570\u7684\u67d0\u4e9b\u503c\u8c03\u7528\uff1a</p> <pre><code>T = TypeVar('T')\n\nclass Tag(Generic[T]):\n    item: T\n    def uppercase_item(self: Tag[str]) -&gt; str:\n        return self.item.upper()\n\ndef label(ti: Tag[int], ts: Tag[str]) -&gt; None:\n    ti.uppercase_item()  # E: Invalid self argument \"Tag[int]\" to attribute function\n                        # \"uppercase_item\" with type \"Callable[[Tag[str]], str]\"\n    ts.uppercase_item()  # This is OK\n</code></pre> <p>\u5728\u7c7b\u578b\u53c2\u6570\u672c\u8eab\u662f\u6cdb\u578b\u7684\u60c5\u51b5\u4e0b\uff0c\u6b64\u6a21\u5f0f\u8fd8\u5141\u8bb8\u5339\u914d\u5d4c\u5957\u7c7b\u578b\uff1a</p> <pre><code>T = TypeVar('T', covariant=True)\nS = TypeVar('S')\n\nclass Storage(Generic[T]):\n    def __init__(self, content: T) -&gt; None:\n        self.content = content\n    def first_chunk(self: Storage[Sequence[S]]) -&gt; S:\n        return self.content[0]\n\npage: Storage[list[str]]\npage.first_chunk()  # OK, type is \"str\"\n\nStorage(0).first_chunk()  # Error: Invalid self argument \"Storage[int]\" to attribute function\n                        # \"first_chunk\" with type \"Callable[[Storage[Sequence[S]]], S]\"\n</code></pre> <p>\u6700\u540e\uff0c\u53ef\u4ee5\u4f7f\u7528\u81ea\u8eab\u7c7b\u578b\u7684\u91cd\u8f7d\u6765\u8868\u8fbe\u4e00\u4e9b\u68d8\u624b\u65b9\u6cd5\u7684\u7cbe\u786e\u7c7b\u578b\uff1a</p> <pre><code>T = TypeVar('T')\n\nclass Tag(Generic[T]):\n    @overload\n    def export(self: Tag[str]) -&gt; str: ...\n    @overload\n    def export(self, converter: Callable[[T], str]) -&gt; str: ...\n\n    def export(self, converter=None):\n        if isinstance(self.item, str):\n            return self.item\n        return converter(self.item)\n</code></pre> <p>\u7279\u522b\u662f\uff0c\u5728\u81ea\u7c7b\u578b\u4e0a\u91cd\u8f7d\u7684 <code>__init__</code> \u65b9\u6cd5\u53ef\u80fd\u6709\u52a9\u4e8e\u6ce8\u91ca\u7c7b\u578b\u53c2\u6570\u4f9d\u8d56\u7684\u6cdb\u578b\u7c7b\u6784\u9020\u51fd\u6570 \u4ee5\u4e0d\u5e73\u51e1\u7684\u65b9\u5f0f\u4e86\u89e3\u6784\u9020\u51fd\u6570\u53c2\u6570\uff0c\u8bf7\u53c2\u89c1\u4f8b\u5982 <code>Popen</code>\u3002</p> <p>In generic classes some methods may be allowed to be called only for certain values of type arguments:</p> <pre><code>T = TypeVar('T')\n\nclass Tag(Generic[T]):\n    item: T\n    def uppercase_item(self: Tag[str]) -&gt; str:\n        return self.item.upper()\n\ndef label(ti: Tag[int], ts: Tag[str]) -&gt; None:\n    ti.uppercase_item()  # E: Invalid self argument \"Tag[int]\" to attribute function\n                        # \"uppercase_item\" with type \"Callable[[Tag[str]], str]\"\n    ts.uppercase_item()  # This is OK\n</code></pre> <p>This pattern also allows matching on nested types in situations where the type argument is itself generic:</p> <pre><code>T = TypeVar('T', covariant=True)\nS = TypeVar('S')\n\nclass Storage(Generic[T]):\n    def __init__(self, content: T) -&gt; None:\n        self.content = content\n    def first_chunk(self: Storage[Sequence[S]]) -&gt; S:\n        return self.content[0]\n\npage: Storage[list[str]]\npage.first_chunk()  # OK, type is \"str\"\n\nStorage(0).first_chunk()  # Error: Invalid self argument \"Storage[int]\" to attribute function\n                        # \"first_chunk\" with type \"Callable[[Storage[Sequence[S]]], S]\"\n</code></pre> <p>Finally, one can use overloads on self-type to express precise types of some tricky methods:</p> <pre><code>T = TypeVar('T')\n\nclass Tag(Generic[T]):\n    @overload\n    def export(self: Tag[str]) -&gt; str: ...\n    @overload\n    def export(self, converter: Callable[[T], str]) -&gt; str: ...\n\n    def export(self, converter=None):\n        if isinstance(self.item, str):\n            return self.item\n        return converter(self.item)\n</code></pre> <p>In particular, an <code>__init__</code> method overloaded on self-type may be useful to annotate generic class constructors where type arguments depend on constructor parameters in a non-trivial way, see e.g. <code>Popen</code>.</p>"},{"location":"mypy/more_types/#mixin-\u7c7b","title":"Mixin \u7c7b","text":"<p>Mixin classes</p> \u4e2d\u6587\u82f1\u6587 <p>\u5728 mixin \u65b9\u6cd5\u4e2d\u4f7f\u7528\u4e3b\u673a\u7c7b\u534f\u8bae\u4f5c\u4e3a\u81ea\u7c7b\u578b\u53ef\u4ee5\u4e3a mixin \u7c7b\u7684\u9759\u6001\u7c7b\u578b\u63d0\u4f9b\u66f4\u591a\u7684\u4ee3\u7801\u53ef\u91cd\u7528\u6027\u3002 \u4f8b\u5982\uff0c\u53ef\u4ee5\u5b9a\u4e49\u4e00\u4e2a\u534f\u8bae\u6765\u5b9a\u4e49\u4e3b\u673a\u7c7b\u7684\u901a\u7528\u529f\u80fd\uff0c\u800c\u4e0d\u662f\u5411\u6bcf\u4e2a mixin \u6dfb\u52a0\u6240\u9700\u7684\u62bd\u8c61\u65b9\u6cd5\uff1a</p> <pre><code>class Lockable(Protocol):\n    @property\n    def lock(self) -&gt; Lock: ...\n\nclass AtomicCloseMixin:\n    def atomic_close(self: Lockable) -&gt; int:\n        with self.lock:\n            # perform actions\n\nclass AtomicOpenMixin:\n    def atomic_open(self: Lockable) -&gt; int:\n        with self.lock:\n            # perform actions\n\nclass File(AtomicCloseMixin, AtomicOpenMixin):\n    def __init__(self) -&gt; None:\n        self.lock = Lock()\n\nclass Bad(AtomicCloseMixin):\n    pass\n\nf = File()\nb: Bad\nf.atomic_close()  # OK\nb.atomic_close()  # Error: Invalid self type for \"atomic_close\"\n</code></pre> <p>\u8bf7\u6ce8\u610f\uff0c\u53ea\u8981\u663e\u5f0f\u81ea\u7c7b\u578b\u4e0d\u662f\u5f53\u524d\u7c7b\u7684\u8d85\u7c7b\u578b\uff0c\u5c31\u5fc5\u987b\u6210\u4e3a\u534f\u8bae\u3002 \u5728\u8fd9\u79cd\u60c5\u51b5\u4e0b\uff0cmypy \u5c06\u4ec5\u5728\u8c03\u7528\u7ad9\u70b9\u68c0\u67e5\u81ea\u6211\u7c7b\u578b\u7684\u6709\u6548\u6027\u3002</p> <p>Using host class protocol as a self-type in mixin methods allows more code re-usability for static typing of mixin classes. For example, one can define a protocol that defines common functionality for host classes instead of adding required abstract methods to every mixin:</p> <pre><code>class Lockable(Protocol):\n    @property\n    def lock(self) -&gt; Lock: ...\n\nclass AtomicCloseMixin:\n    def atomic_close(self: Lockable) -&gt; int:\n        with self.lock:\n            # perform actions\n\nclass AtomicOpenMixin:\n    def atomic_open(self: Lockable) -&gt; int:\n        with self.lock:\n            # perform actions\n\nclass File(AtomicCloseMixin, AtomicOpenMixin):\n    def __init__(self) -&gt; None:\n        self.lock = Lock()\n\nclass Bad(AtomicCloseMixin):\n    pass\n\nf = File()\nb: Bad\nf.atomic_close()  # OK\nb.atomic_close()  # Error: Invalid self type for \"atomic_close\"\n</code></pre> <p>Note that the explicit self-type is required to be a protocol whenever it is not a supertype of the current class. In this case mypy will check the validity of the self-type only at the call site.</p>"},{"location":"mypy/more_types/#\u66ff\u4ee3\u6784\u9020\u51fd\u6570\u7684\u7cbe\u786e\u7c7b\u578b","title":"\u66ff\u4ee3\u6784\u9020\u51fd\u6570\u7684\u7cbe\u786e\u7c7b\u578b","text":"<p>Precise typing of alternative constructors</p> \u4e2d\u6587\u82f1\u6587 <p>\u67d0\u4e9b\u7c7b\u53ef\u80fd\u5b9a\u4e49\u66ff\u4ee3\u6784\u9020\u51fd\u6570\u3002 \u5982\u679c\u8fd9\u4e9b\u7c7b\u662f\u901a\u7528\u7684\uff0c\u5219\u81ea\u7c7b\u578b\u5141\u8bb8\u4e3a\u5b83\u4eec\u63d0\u4f9b\u7cbe\u786e\u7684\u7b7e\u540d\uff1a</p> <pre><code>T = TypeVar('T')\n\nclass Base(Generic[T]):\n    Q = TypeVar('Q', bound='Base[T]')\n\n    def __init__(self, item: T) -&gt; None:\n        self.item = item\n\n    @classmethod\n    def make_pair(cls: Type[Q], item: T) -&gt; tuple[Q, Q]:\n        return cls(item), cls(item)\n\nclass Sub(Base[T]):\n    ...\n\npair = Sub.make_pair('yes')  # Type is \"tuple[Sub[str], Sub[str]]\"\nbad = Sub[int].make_pair('no')  # Error: Argument 1 to \"make_pair\" of \"Base\"\n                                # has incompatible type \"str\"; expected \"int\"\n</code></pre> <p>Some classes may define alternative constructors. If these classes are generic, self-type allows giving them precise signatures:</p> <pre><code>T = TypeVar('T')\n\nclass Base(Generic[T]):\n    Q = TypeVar('Q', bound='Base[T]')\n\n    def __init__(self, item: T) -&gt; None:\n        self.item = item\n\n    @classmethod\n    def make_pair(cls: Type[Q], item: T) -&gt; tuple[Q, Q]:\n        return cls(item), cls(item)\n\nclass Sub(Base[T]):\n    ...\n\npair = Sub.make_pair('yes')  # Type is \"tuple[Sub[str], Sub[str]]\"\nbad = Sub[int].make_pair('no')  # Error: Argument 1 to \"make_pair\" of \"Base\"\n                                # has incompatible type \"str\"; expected \"int\"\n</code></pre>"},{"location":"mypy/more_types/#\u5f02\u6b65\u540c\u6b65\u7684\u7c7b\u578b\u68c0\u67e5","title":"\u5f02\u6b65/\u540c\u6b65\u7684\u7c7b\u578b\u68c0\u67e5","text":"<p>Typing async/await</p> \u4e2d\u6587\u82f1\u6587 <p>Mypy \u5141\u8bb8\u60a8\u8f93\u5165\u4f7f\u7528\u201casync/await\u201d\u8bed\u6cd5\u7684\u534f\u7a0b\u3002 \u6709\u5173\u534f\u7a0b\u7684\u66f4\u591a\u4fe1\u606f\uff0c\u8bf7\u53c2\u9605 <code>PEP - 492</code> \u548c asyncio \u6587\u6863\u3002</p> <p>\u4f7f\u7528\u201casync def\u201d\u5b9a\u4e49\u7684\u51fd\u6570\u7684\u7c7b\u578b\u4e0e\u666e\u901a\u51fd\u6570\u7c7b\u4f3c\u3002 \u8fd4\u56de\u7c7b\u578b\u6ce8\u91ca\u5e94\u8be5\u4e0e\u60a8\u5e0c\u671b\u5728\u201cawait\u201d\u534f\u7a0b\u65f6\u8fd4\u56de\u7684\u503c\u7684\u7c7b\u578b\u76f8\u540c\u3002</p> <pre><code>import asyncio\n\nasync def format_string(tag: str, count: int) -&gt; str:\n    return f'T-minus {count} ({tag})'\n\nasync def countdown(tag: str, count: int) -&gt; str:\n    while count &gt; 0:\n        my_str = await format_string(tag, count)  # type is inferred to be str\n        print(my_str)\n        await asyncio.sleep(0.1)\n        count -= 1\n    return \"Blastoff!\"\n\nasyncio.run(countdown(\"Millennium Falcon\", 5))\n</code></pre> <p>\u8c03\u7528 <code>async def</code> \u51fd\u6570 \u65e0\u9700\u7b49\u5f85 \u7684\u7ed3\u679c\u5c06\u81ea\u52a8\u63a8\u65ad\u4e3a <code>Coroutine[Any, Any, T]</code> \u7c7b\u578b\u7684\u503c \uff0c\u5b83\u662f <code>Awaitable[T]</code> \u7684\u5b50\u7c7b\u578b\uff1a</p> <pre><code>my_coroutine = countdown(\"Millennium Falcon\", 5)\nreveal_type(my_coroutine)  # Revealed type is \"typing.Coroutine[Any, Any, builtins.str]\"\n</code></pre> <p>Mypy lets you type coroutines that use the <code>async/await</code> syntax. For more information regarding coroutines, see <code>PEP - 492</code> and the asyncio documentation.</p> <p>Functions defined using <code>async def</code> are typed similar to normal functions. The return type annotation should be the same as the type of the value you expect to get back when <code>await</code>-ing the coroutine.</p> <pre><code>import asyncio\n\nasync def format_string(tag: str, count: int) -&gt; str:\n    return f'T-minus {count} ({tag})'\n\nasync def countdown(tag: str, count: int) -&gt; str:\n    while count &gt; 0:\n        my_str = await format_string(tag, count)  # type is inferred to be str\n        print(my_str)\n        await asyncio.sleep(0.1)\n        count -= 1\n    return \"Blastoff!\"\n\nasyncio.run(countdown(\"Millennium Falcon\", 5))\n</code></pre> <p>The result of calling an <code>async def</code> function without awaiting will automatically be inferred to be a value of type <code>Coroutine[Any, Any, T]</code>, which is a subtype of <code>Awaitable[T]</code>:</p> <pre><code>my_coroutine = countdown(\"Millennium Falcon\", 5)\nreveal_type(my_coroutine)  # Revealed type is \"typing.Coroutine[Any, Any, builtins.str]\"\n</code></pre>"},{"location":"mypy/more_types/#\u5f02\u6b65\u8fed\u4ee3\u5668","title":"\u5f02\u6b65\u8fed\u4ee3\u5668","text":"<p>Asynchronous iterators</p> \u4e2d\u6587\u82f1\u6587 <p>\u5982\u679c\u60a8\u6709\u5f02\u6b65\u8fed\u4ee3\u5668\uff0c\u5219\u53ef\u4ee5\u5728\u6ce8\u91ca\u4e2d\u4f7f\u7528 <code>AsyncIterator</code> \u7c7b\u578b\uff1a</p> <pre><code>from typing import Optional, AsyncIterator\nimport asyncio\n\nclass arange:\n    def __init__(self, start: int, stop: int, step: int) -&gt; None:\n        self.start = start\n        self.stop = stop\n        self.step = step\n        self.count = start - step\n\n    def __aiter__(self) -&gt; AsyncIterator[int]:\n        return self\n\n    async def __anext__(self) -&gt; int:\n        self.count += self.step\n        if self.count == self.stop:\n            raise StopAsyncIteration\n        else:\n            return self.count\n\nasync def run_countdown(tag: str, countdown: AsyncIterator[int]) -&gt; str:\n    async for i in countdown:\n        print(f'T-minus {i} ({tag})')\n        await asyncio.sleep(0.1)\n    return \"Blastoff!\"\n\nasyncio.run(run_countdown(\"Serenity\", arange(5, 0, -1)))\n</code></pre> <p>\u5f02\u6b65\u751f\u6210\u5668\uff08\u5728 <code>PEP 525</code> \u4e2d\u5f15\u5165\uff09\u662f\u521b\u5efa\u5f02\u6b65\u8fed\u4ee3\u5668\u7684\u7b80\u5355\u65b9\u6cd5\uff1a</p> <pre><code>from typing import AsyncGenerator, Optional\nimport asyncio\n\n# \u4e5f\u53ef\u4ee5\u8f93\u5165\u6b64\u4f5c\u4e3a\u8fd4\u56de AsyncIterator[int]\nasync def arange(start: int, stop: int, step: int) -&gt; AsyncGenerator[int, None]:\n    current = start\n    while (step &gt; 0 and current &lt; stop) or (step &lt; 0 and current &gt; stop):\n        yield current\n        current += step\n\nasyncio.run(run_countdown(\"Battlestar Galactica\", arange(5, 0, -1)))\n</code></pre> <p>\u4e00\u4e2a\u5e38\u89c1\u7684\u6df7\u6dc6\u662f\u201casync def\u201d\u51fd\u6570\u4e2d\u201cyield\u201d\u8bed\u53e5\u7684\u5b58\u5728\u4f1a\u5f71\u54cd\u51fd\u6570\u7684\u7c7b\u578b\uff1a</p> <pre><code>from typing import AsyncIterator\n\nasync def arange(stop: int) -&gt; AsyncIterator[int]:\n    # \u8c03\u7528\u65f6\uff0carange \u4e3a\u60a8\u63d0\u4f9b\u4e00\u4e2a\u5f02\u6b65\u8fed\u4ee3\u5668\uff0c\u76f8\u5f53\u4e8e Callable[[int], AsyncIterator[int]]\n    i = 0\n    while i &lt; stop:\n        yield i\n        i += 1\n\nasync def coroutine(stop: int) -&gt; AsyncIterator[int]:\n    # \u8c03\u7528\u65f6\uff0c\u534f\u7a0b\u4f1a\u4e3a\u60a8\u63d0\u4f9b\u4e00\u4e9b\u53ef\u4ee5\u7b49\u5f85\u4ee5\u83b7\u5f97\u5f02\u6b65\u8fed\u4ee3\u5668\u7684\u4e1c\u897f\uff0c\u76f8\u5f53\u4e8e Callable[[int], Coroutine[Any, Any, AsyncIterator[int]]]\n    return arange(stop)\n\nasync def main() -&gt; None:\n    reveal_type(arange(5))  # Revealed type is \"typing.AsyncIterator[builtins.int]\"\n    reveal_type(coroutine(5))  # Revealed type is \"typing.Coroutine[Any, Any, typing.AsyncIterator[builtins.int]]\"\n\n    await arange(5)  # Error: Incompatible types in \"await\" (actual type \"AsyncIterator[int]\", expected type \"Awaitable[Any]\")\n    reveal_type(await coroutine(5))  # Revealed type is \"typing.AsyncIterator[builtins.int]\"\n</code></pre> <p>\u5f53\u5c1d\u8bd5\u5b9a\u4e49\u57fa\u7c7b\u3001\u534f\u8bae\u6216\u91cd\u8f7d\u65f6\uff0c\u6709\u65f6\u4f1a\u51fa\u73b0\u8fd9\u79cd\u60c5\u51b5\uff1a</p> <pre><code>from typing import AsyncIterator, Protocol, overload\n\nclass LauncherIncorrect(Protocol):\n    # \u56e0\u4e3a launch \u6ca1\u6709 Yield\uff0c\u6240\u4ee5\u5b83\u7684\u7c7b\u578b\u4e3a Callable[[], Coroutine[Any, Any, AsyncIterator[int]]] \u800c\u4e0d\u662f Callable[[], AsyncIterator[int]]\n    async def launch(self) -&gt; AsyncIterator[int]:\n        raise NotImplementedError\n\nclass LauncherCorrect(Protocol):\n    def launch(self) -&gt; AsyncIterator[int]:\n        raise NotImplementedError\n\nclass LauncherAlsoCorrect(Protocol):\n    async def launch(self) -&gt; AsyncIterator[int]:\n        raise NotImplementedError\n        if False:\n            yield 0\n\n# \u91cd\u8f7d\u7684\u7c7b\u578b\u4e0e\u5b9e\u73b0\u65e0\u5173\u3002\n# \u7279\u522b\u662f\uff0c\u5b83\u4eec\u7684\u7c7b\u578b\u4e0d\u53d7\u5b9e\u73b0\u662f\u5426\u5305\u542b\u201cyield\u201d\u7684\u5f71\u54cd\u3002\n# \u4f7f\u7528 `def` \u53ef\u4ee5\u6e05\u695a\u5730\u8868\u660e\u7c7b\u578b\u662f Callable[..., AsyncIterator[int]]\uff0c\n# \u800c\u4f7f\u7528 `async def` \u5b83\u5c06\u662f Callable[..., Coroutine[Any, Any, AsyncIterator[int]]]\n@overload\ndef launch(*, count: int = ...) -&gt; AsyncIterator[int]: ...\n@overload\ndef launch(*, time: float = ...) -&gt; AsyncIterator[int]: ...\n\nasync def launch(*, count: int = 0, time: float = 0) -&gt; AsyncIterator[int]:\n    # launch \u7684\u5b9e\u73b0\u662f\u4e00\u4e2a\u5f02\u6b65\u751f\u6210\u5668\u5e76\u5305\u542b\u4e00\u4e2ayield\n    yield 0\n</code></pre> <p>If you have an asynchronous iterator, you can use the <code>AsyncIterator</code> type in your annotations:</p> <pre><code>from typing import Optional, AsyncIterator\nimport asyncio\n\nclass arange:\n    def __init__(self, start: int, stop: int, step: int) -&gt; None:\n        self.start = start\n        self.stop = stop\n        self.step = step\n        self.count = start - step\n\n    def __aiter__(self) -&gt; AsyncIterator[int]:\n        return self\n\n    async def __anext__(self) -&gt; int:\n        self.count += self.step\n        if self.count == self.stop:\n            raise StopAsyncIteration\n        else:\n            return self.count\n\nasync def run_countdown(tag: str, countdown: AsyncIterator[int]) -&gt; str:\n    async for i in countdown:\n        print(f'T-minus {i} ({tag})')\n        await asyncio.sleep(0.1)\n    return \"Blastoff!\"\n\nasyncio.run(run_countdown(\"Serenity\", arange(5, 0, -1)))\n</code></pre> <p>Async generators (introduced in <code>PEP 525</code>) are an easy way to create async iterators:</p> <pre><code>from typing import AsyncGenerator, Optional\nimport asyncio\n\n# Could also type this as returning AsyncIterator[int]\nasync def arange(start: int, stop: int, step: int) -&gt; AsyncGenerator[int, None]:\n    current = start\n    while (step &gt; 0 and current &lt; stop) or (step &lt; 0 and current &gt; stop):\n        yield current\n        current += step\n\nasyncio.run(run_countdown(\"Battlestar Galactica\", arange(5, 0, -1)))\n</code></pre> <p>One common confusion is that the presence of a <code>yield</code> statement in an <code>async def</code> function has an effect on the type of the function:</p> <pre><code>from typing import AsyncIterator\n\nasync def arange(stop: int) -&gt; AsyncIterator[int]:\n    # When called, arange gives you an async iterator\n    # Equivalent to Callable[[int], AsyncIterator[int]]\n    i = 0\n    while i &lt; stop:\n        yield i\n        i += 1\n\nasync def coroutine(stop: int) -&gt; AsyncIterator[int]:\n    # When called, coroutine gives you something you can await to get an async iterator\n    # Equivalent to Callable[[int], Coroutine[Any, Any, AsyncIterator[int]]]\n    return arange(stop)\n\nasync def main() -&gt; None:\n    reveal_type(arange(5))  # Revealed type is \"typing.AsyncIterator[builtins.int]\"\n    reveal_type(coroutine(5))  # Revealed type is \"typing.Coroutine[Any, Any, typing.AsyncIterator[builtins.int]]\"\n\n    await arange(5)  # Error: Incompatible types in \"await\" (actual type \"AsyncIterator[int]\", expected type \"Awaitable[Any]\")\n    reveal_type(await coroutine(5))  # Revealed type is \"typing.AsyncIterator[builtins.int]\"\n</code></pre> <p>This can sometimes come up when trying to define base classes, Protocols or overloads:</p> <pre><code>from typing import AsyncIterator, Protocol, overload\n\nclass LauncherIncorrect(Protocol):\n    # Because launch does not have yield, this has type\n    # Callable[[], Coroutine[Any, Any, AsyncIterator[int]]]\n    # instead of\n    # Callable[[], AsyncIterator[int]]\n    async def launch(self) -&gt; AsyncIterator[int]:\n        raise NotImplementedError\n\nclass LauncherCorrect(Protocol):\n    def launch(self) -&gt; AsyncIterator[int]:\n        raise NotImplementedError\n\nclass LauncherAlsoCorrect(Protocol):\n    async def launch(self) -&gt; AsyncIterator[int]:\n        raise NotImplementedError\n        if False:\n            yield 0\n\n# The type of the overloads is independent of the implementation.\n# In particular, their type is not affected by whether or not the\n# implementation contains a `yield`.\n# Use of `def`` makes it clear the type is Callable[..., AsyncIterator[int]],\n# whereas with `async def` it would be Callable[..., Coroutine[Any, Any, AsyncIterator[int]]]\n@overload\ndef launch(*, count: int = ...) -&gt; AsyncIterator[int]: ...\n@overload\ndef launch(*, time: float = ...) -&gt; AsyncIterator[int]: ...\n\nasync def launch(*, count: int = 0, time: float = 0) -&gt; AsyncIterator[int]:\n    # The implementation of launch is an async generator and contains a yield\n    yield 0\n</code></pre>"},{"location":"mypy/protocol_and_struct_subtyping/","title":"\u534f\u8bae\u53ca\u5176\u5b50\u7c7b\u578b","text":"\u4e2d\u6587\u82f1\u6587 <p>Python \u7c7b\u578b\u7cfb\u7edf\u652f\u6301\u4e24\u79cd\u786e\u5b9a\u4e24\u4e2a\u5bf9\u8c61\u4f5c\u4e3a\u7c7b\u578b\u662f\u5426\u517c\u5bb9\u7684\u65b9\u6cd5\uff1a\u540d\u4e49\u5b50\u7c7b\u578b\u548c\u7ed3\u6784\u5b50\u7c7b\u578b\u3002</p> <p>\u540d\u4e49\u4e0a\u7684\u5b50\u7c7b\u578b\u4e25\u683c\u57fa\u4e8e\u7c7b\u5c42\u6b21\u7ed3\u6784\u3002 \u5982\u679c\u7c7b\u201cDog\u201d\u7ee7\u627f\u7c7b\u201cAnimal\u201d\uff0c\u90a3\u4e48\u5b83\u662f\u201cAnimal\u201d\u7684\u5b50\u7c7b\u578b\u3002 \u5f53\u9700\u8981\u201cAnimal\u201d\u5b9e\u4f8b\u65f6\uff0c\u53ef\u4ee5\u4f7f\u7528\u201cDog\u201d\u5b9e\u4f8b\u3002 \u8fd9\u79cd\u5f62\u5f0f\u7684\u5b50\u7c7b\u578b\u5316\u662f Python \u7c7b\u578b\u7cfb\u7edf\u4e3b\u8981\u4f7f\u7528\u7684\uff1a\u5b83\u5f88\u5bb9\u6613\u7406\u89e3\u5e76\u751f\u6210\u6e05\u6670\u7b80\u6d01\u7684\u9519\u8bef\u6d88\u606f\uff0c\u5e76\u4e14\u4e0e\u672c\u673a {py:func}<code>isinstance</code> \u68c0\u67e5\u7684\u5de5\u4f5c\u65b9\u5f0f\u76f8\u5339\u914d - \u57fa\u4e8e\u7c7b\u5c42\u6b21\u7ed3\u6784\u3002</p> <p>\u7ed3\u6784\u5b50\u7c7b\u578b\u57fa\u4e8e\u53ef\u4ee5\u5bf9\u5bf9\u8c61\u6267\u884c\u7684\u64cd\u4f5c\u3002 \u5982\u679c\u7c7b\u201cDog\u201d\u5177\u6709\u7c7b\u201cAnimal\u201d\u7684\u6240\u6709\u5c5e\u6027\u548c\u65b9\u6cd5\uff0c\u5e76\u4e14\u5177\u6709\u517c\u5bb9\u7684\u7c7b\u578b\uff0c\u5219\u7c7b\u201cDog\u201d\u662f\u7c7b\u201cAnimal\u201d\u7684\u7ed3\u6784\u5b50\u7c7b\u578b\u3002</p> <p>\u7ed3\u6784\u5b50\u7c7b\u578b\u53ef\u4ee5\u770b\u4f5c\u662f\u9e2d\u5b50\u7c7b\u578b\u7684\u9759\u6001\u7b49\u4ef7\u7269\uff0c\u8fd9\u662f Python \u7a0b\u5e8f\u5458\u6240\u719f\u77e5\u7684\u3002 \u6709\u5173 Python \u4e2d\u534f\u8bae\u548c\u7ed3\u6784\u5b50\u7c7b\u578b\u7684\u8be6\u7ec6\u89c4\u8303\uff0c\u8bf7\u53c2\u9605 <code>PEP 544</code>\u3002</p> <p>Protocols and structural subtyping</p> <p>The Python type system supports two ways of deciding whether two objects are compatible as types: nominal subtyping and structural subtyping.</p> <p>Nominal subtyping is strictly based on the class hierarchy. If class <code>Dog</code> inherits class <code>Animal</code>, it's a subtype of <code>Animal</code>. Instances of <code>Dog</code> can be used when <code>Animal</code> instances are expected. This form of subtyping subtyping is what Python's type system predominantly uses: it's easy to understand and produces clear and concise error messages, and matches how the native <code>isinstance</code> check works -- based on class hierarchy.</p> <p>Structural subtyping is based on the operations that can be performed with an object. Class <code>Dog</code> is a structural subtype of class <code>Animal</code> if the former has all attributes and methods of the latter, and with compatible types.</p> <p>Structural subtyping can be seen as a static equivalent of duck typing, which is well known to Python programmers. See <code>PEP 544</code> for the detailed specification of protocols and structural subtyping in Python.</p>"},{"location":"mypy/protocol_and_struct_subtyping/#\u9884\u5b9a\u4e49\u534f\u8bae","title":"\u9884\u5b9a\u4e49\u534f\u8bae","text":"\u4e2d\u6587\u82f1\u6587 <p><code>typing</code> \u6a21\u5757\u5b9a\u4e49\u4e86\u4e0e\u5e38\u89c1 Python \u534f\u8bae\u76f8\u5bf9\u5e94\u7684\u5404\u79cd\u534f\u8bae\u7c7b\uff0c\u4f8b\u5982 <code>Iterable[T]</code>\u3002 \u5982\u679c\u4e00\u4e2a\u7c7b\u5b9a\u4e49\u4e86\u5408\u9002\u7684 <code>__iter__</code> \u65b9\u6cd5\uff0cmypy \u5c31\u4f1a\u7406\u89e3\u5b83\u5b9e\u73b0\u4e86\u53ef\u8fed\u4ee3\u534f\u8bae\u5e76\u4e14\u4e0e <code>Iterable[T]</code> \u517c\u5bb9\u3002 \u4f8b\u5982\uff0c\u4e0b\u9762\u7684<code>IntList</code>\u662f\u53ef\u8fed\u4ee3\u7684\uff0c\u7c7b\u578b\u662f<code>int</code>\u503c\uff1a</p> <pre><code>from typing import Iterator, Iterable, Optional\n\nclass IntList:\n    def __init__(self, value: int, next: Optional['IntList']) -&gt; None:\n        self.value = value\n        self.next = next\n\n    def __iter__(self) -&gt; Iterator[int]:\n        current = self\n        while current:\n            yield current.value\n            current = current.next\n\ndef print_numbered(items: Iterable[int]) -&gt; None:\n    for n, x in enumerate(items):\n        print(n + 1, x)\n\nx = IntList(3, IntList(5, None))\nprint_numbered(x)  # OK\nprint_numbered([4, 5])  # Also OK\n</code></pre> <p><code>\u9884\u5b9a\u4e49\u534f\u8bae\u53c2\u8003</code> \u5217\u51fa\u4e86 <code>typing</code> \u4e2d\u5b9a\u4e49\u7684\u6240\u6709\u534f\u8bae\u4ee5\u53ca\u60a8\u9700\u8981\u5b9a\u4e49\u4ee5\u5b9e\u73b0\u6bcf\u4e2a\u534f\u8bae\u7684\u76f8\u5e94\u65b9\u6cd5\u7684\u7b7e\u540d\u3002</p> <p>Predefined protocols</p> <p>The <code>typing</code> module defines various protocol classes that correspond to common Python protocols, such as <code>Iterable[T]</code>. If a class defines a suitable <code>__iter__</code> method, mypy understands that it implements the iterable protocol and is compatible with <code>Iterable[T]</code>. For example, <code>IntList</code> below is iterable, over <code>int</code> values:</p> <pre><code>from typing import Iterator, Iterable, Optional\n\nclass IntList:\n    def __init__(self, value: int, next: Optional['IntList']) -&gt; None:\n        self.value = value\n        self.next = next\n\n    def __iter__(self) -&gt; Iterator[int]:\n        current = self\n        while current:\n            yield current.value\n            current = current.next\n\ndef print_numbered(items: Iterable[int]) -&gt; None:\n    for n, x in enumerate(items):\n        print(n + 1, x)\n\nx = IntList(3, IntList(5, None))\nprint_numbered(x)  # OK\nprint_numbered([4, 5])  # Also OK\n</code></pre> <p><code>predefined_protocols_reference</code> lists all protocols defined in <code>typing</code> and the signatures of the corresponding methods you need to define to implement each protocol.</p>"},{"location":"mypy/protocol_and_struct_subtyping/#\u7b80\u5355\u7684\u81ea\u5b9a\u4e49\u534f\u8bae","title":"\u7b80\u5355\u7684\u81ea\u5b9a\u4e49\u534f\u8bae","text":"\u4e2d\u6587\u82f1\u6587 <p>\u60a8\u53ef\u4ee5\u901a\u8fc7\u7ee7\u627f\u7279\u6b8a\u7684 <code>Protocol</code> \u7c7b\u6765\u5b9a\u4e49\u81ea\u5df1\u7684\u534f\u8bae\u7c7b\uff1a</p> <pre><code>from typing import Iterable\nfrom typing_extensions import Protocol\n\nclass SupportsClose(Protocol):\n    #\u7a7a\u65b9\u6cd5\u4f53 (explicit '...')\n    def close(self) -&gt; None: ...\n\nclass Resource:  # No SupportsClose base class!\n\n    def close(self) -&gt; None:\n        self.resource.release()\n\n    # ... \u5176\u4ed6\u65b9\u6cd5 ...\n\ndef close_all(items: Iterable[SupportsClose]) -&gt; None:\n    for item in items:\n        item.close()\n\nclose_all([Resource(), open('some/file')])  # OK\n</code></pre> <p><code>Resource</code> \u662f <code>SupportsClose</code> \u534f\u8bae\u7684\u5b50\u7c7b\u578b\uff0c\u56e0\u4e3a\u5b83\u5b9a\u4e49\u4e86\u517c\u5bb9\u7684 <code>close</code> \u65b9\u6cd5\u3002 <code>open</code> \u8fd4\u56de\u7684\u5e38\u89c4\u6587\u4ef6\u5bf9\u8c61\u540c\u6837\u4e0e\u534f\u8bae\u517c\u5bb9\uff0c\u56e0\u4e3a\u5b83\u4eec\u652f\u6301 <code>close()</code>\u3002</p> <p>Simple user-defined protocols</p> <p>You can define your own protocol class by inheriting the special <code>Protocol</code> class:</p> <pre><code>from typing import Iterable\nfrom typing_extensions import Protocol\n\nclass SupportsClose(Protocol):\n    # Empty method body (explicit '...')\n    def close(self) -&gt; None: ...\n\nclass Resource:  # No SupportsClose base class!\n\n    def close(self) -&gt; None:\n    self.resource.release()\n\n    # ... other methods ...\n\ndef close_all(items: Iterable[SupportsClose]) -&gt; None:\n    for item in items:\n        item.close()\n\nclose_all([Resource(), open('some/file')])  # OK\n</code></pre> <p><code>Resource</code> is a subtype of the <code>SupportsClose</code> protocol since it defines a compatible <code>close</code> method. Regular file objects returned by <code>open</code> are similarly compatible with the protocol, as they support <code>close()</code>.</p>"},{"location":"mypy/protocol_and_struct_subtyping/#\u5b9a\u4e49\u5b50\u534f\u8bae\u548c\u5b50\u7c7b\u5316\u534f\u8bae","title":"\u5b9a\u4e49\u5b50\u534f\u8bae\u548c\u5b50\u7c7b\u5316\u534f\u8bae","text":"\u4e2d\u6587\u82f1\u6587 <p>\u60a8\u8fd8\u53ef\u4ee5\u5b9a\u4e49\u5b50\u534f\u8bae\u3002 \u53ef\u4ee5\u4f7f\u7528\u591a\u91cd\u7ee7\u627f\u6765\u6269\u5c55\u548c\u5408\u5e76\u73b0\u6709\u534f\u8bae\u3002 \u4f8b\u5b50\uff1a</p> <pre><code># ... \u7ee7\u7eed\u4e0a\u4e00\u4e2a\u793a\u4f8b\n\nclass SupportsRead(Protocol):\n    def read(self, amount: int) -&gt; bytes: ...\n\nclass TaggedReadableResource(SupportsClose, SupportsRead, Protocol):\n    label: str\n\nclass AdvancedResource(Resource):\n    def __init__(self, label: str) -&gt; None:\n        self.label = label\n\n    def read(self, amount: int) -&gt; bytes:\n        # some implementation\n        ...\n\nresource: TaggedReadableResource\nresource = AdvancedResource('handle with care')  # OK\n</code></pre> <p>\u8bf7\u6ce8\u610f\uff0c\u4ece\u73b0\u6709\u534f\u8bae\u7ee7\u627f\u4e0d\u4f1a\u81ea\u52a8\u5c06\u5b50\u7c7b\u8f6c\u6362\u4e3a\u534f\u8bae - \u5b83\u53ea\u662f\u521b\u5efa\u4e00\u4e2a\u5b9e\u73b0\u7ed9\u5b9a\u534f\u8bae\uff08\u6216\u591a\u4e2a\u534f\u8bae\uff09\u7684\u5e38\u89c4\uff08\u975e\u534f\u8bae\uff09\u7c7b\u6216 ABC\u3002 \u5982\u679c\u60a8\u5b9a\u4e49\u534f\u8bae\uff0c\u5219 <code>Protocol</code> \u57fa\u7c7b\u5fc5\u987b\u59cb\u7ec8\u663e\u5f0f\u5b58\u5728\uff1a</p> <pre><code>class NotAProtocol(SupportsClose):  # \u8fd9\u4e0d\u662f\u4e00\u4e2a\u534f\u8bae\n    new_attr: int\n\nclass Concrete:\nnew_attr: int = 0\n\ndef close(self) -&gt; None:\n    ...\n\n# Error: nominal subtyping used by default\n# Error: \u9ed8\u8ba4\u4f7f\u7528\u7684\u540d\u4e49\u5b50\u7c7b\u578b\nx: NotAProtocol = Concrete()  # Error!\n</code></pre> <p>\u60a8\u8fd8\u53ef\u4ee5\u5728\u534f\u8bae\u4e2d\u5305\u542b\u65b9\u6cd5\u7684\u9ed8\u8ba4\u5b9e\u73b0\u3002 \u5982\u679c\u60a8\u660e\u786e\u5730\u5b50\u7c7b\u5316\u8fd9\u4e9b\u534f\u8bae\uff0c\u60a8\u53ef\u4ee5\u7ee7\u627f\u8fd9\u4e9b\u9ed8\u8ba4\u5b9e\u73b0\u3002</p> <p>\u663e\u5f0f\u5305\u542b\u534f\u8bae\u4f5c\u4e3a\u57fa\u7c7b\u4e5f\u662f\u8bb0\u5f55\u60a8\u7684\u7c7b\u5b9e\u73b0\u7279\u5b9a\u534f\u8bae\u7684\u4e00\u79cd\u65b9\u5f0f\uff0c\u5e76\u4e14\u5b83\u5f3a\u5236 mypy \u9a8c\u8bc1\u60a8\u7684\u7c7b\u5b9e\u73b0\u5b9e\u9645\u4e0a\u4e0e\u8be5\u534f\u8bae\u517c\u5bb9\u3002 \u7279\u522b\u662f\uff0c\u7701\u7565\u5c5e\u6027\u6216\u65b9\u6cd5\u4f53\u7684\u503c\u5c06\u4f7f\u5176\u9690\u5f0f\u62bd\u8c61\uff1a</p> <pre><code>class SomeProto(Protocol):\n    attr: int  # \u6ce8\u610f\uff0c\u6ca1\u6709\u53f3\u624b\u8fb9 \uff08Note, no right hand side\uff09\n    def method(self) -&gt; str: ...  # \u4ece\u5b57\u9762\u4e0a\u770b\u53ea\u662f...\u8fd9\u91cc \uff08Literally just ... here\uff09\n\nclass ExplicitSubclass(SomeProto):\n    pass\n\nExplicitSubclass()  # error: Cannot instantiate abstract class 'ExplicitSubclass'\n                    # with abstract attributes 'attr' and 'method'\n                    # error\uff1a\u65e0\u6cd5\u4f7f\u7528\u62bd\u8c61\u5c5e\u6027\u201cattr\u201d\u548c\u201cmethod\u201d\u5b9e\u4f8b\u5316\u62bd\u8c61\u7c7b\u201cExplicitSubclass\u201d\n</code></pre> <p>\u7c7b\u4f3c\u5730\uff0c\u663e\u5f0f\u5206\u914d\u7ed9\u534f\u8bae\u5b9e\u4f8b\u53ef\u4ee5\u662f\u8981\u6c42\u7c7b\u578b\u68c0\u67e5\u5668\u9a8c\u8bc1\u60a8\u7684\u7c7b\u662f\u5426\u5b9e\u73b0\u534f\u8bae\u7684\u4e00\u79cd\u65b9\u6cd5\uff1a</p> <pre><code>_proto: SomeProto = cast(ExplicitSubclass, None)\n</code></pre> <p>Defining subprotocols and subclassing protocols</p> <p>You can also define subprotocols. Existing protocols can be extended and merged using multiple inheritance. Example:</p> <pre><code># ... continuing from the previous example\n\nclass SupportsRead(Protocol):\n    def read(self, amount: int) -&gt; bytes: ...\n\nclass TaggedReadableResource(SupportsClose, SupportsRead, Protocol):\n    label: str\n\nclass AdvancedResource(Resource):\n    def __init__(self, label: str) -&gt; None:\n        self.label = label\n\n    def read(self, amount: int) -&gt; bytes:\n        # some implementation\n        ...\n\nresource: TaggedReadableResource\nresource = AdvancedResource('handle with care')  # OK\n</code></pre> <p>Note that inheriting from an existing protocol does not automatically turn the subclass into a protocol -- it just creates a regular (non-protocol) class or ABC that implements the given protocol (or protocols). The <code>Protocol</code> base class must always be explicitly present if you are defining a protocol:</p> <pre><code>class NotAProtocol(SupportsClose):  # This is NOT a protocol\n    new_attr: int\n\nclass Concrete:\nnew_attr: int = 0\n\ndef close(self) -&gt; None:\n    ...\n\n# Error: nominal subtyping used by default\nx: NotAProtocol = Concrete()  # Error!\n</code></pre> <p>You can also include default implementations of methods in protocols. If you explicitly subclass these protocols you can inherit these default implementations.</p> <p>Explicitly including a protocol as a base class is also a way of documenting that your class implements a particular protocol, and it forces mypy to verify that your class implementation is actually compatible with the protocol. In particular, omitting a value for an attribute or a method body will make it implicitly abstract:</p> <pre><code>class SomeProto(Protocol):\n    attr: int  # Note, no right hand side\n    def method(self) -&gt; str: ...  # Literally just ... here\n\nclass ExplicitSubclass(SomeProto):\n    pass\n\nExplicitSubclass()  # error: Cannot instantiate abstract class 'ExplicitSubclass'\n                    # with abstract attributes 'attr' and 'method'\n</code></pre> <p>Similarly, explicitly assigning to a protocol instance can be a way to ask the type checker to verify that your class implements a protocol:</p> <pre><code>_proto: SomeProto = cast(ExplicitSubclass, None)\n</code></pre>"},{"location":"mypy/protocol_and_struct_subtyping/#\u534f\u8bae\u5c5e\u6027\u7684\u4e0d\u53d8\u6027","title":"\u534f\u8bae\u5c5e\u6027\u7684\u4e0d\u53d8\u6027","text":"\u4e2d\u6587\u82f1\u6587 <p>\u534f\u8bae\u7684\u4e00\u4e2a\u5e38\u89c1\u95ee\u9898\u662f\u534f\u8bae\u5c5e\u6027\u662f\u4e0d\u53d8\u7684\u3002 \u4f8b\u5982\uff1a</p> <pre><code>class Box(Protocol):\n    content: object\n\nclass IntBox:\n    content: int\n\ndef takes_box(box: Box) -&gt; None: ...\n\ntakes_box(IntBox())  # error: Argument 1 to \"takes_box\" has incompatible type \uff08\u4e0d\u517c\u5bb9\u7c7b\u578b\uff09 \"IntBox\"; expected \"Box\"\n                    # note:  Following member(s) of \"IntBox\" have conflicts:\n                    # note:      content: expected \"object\", got \"int\"\n</code></pre> <p>\u8fd9\u662f\u56e0\u4e3a <code>Box</code> \u5c06 <code>content</code> \u5b9a\u4e49\u4e3a\u53ef\u53d8\u5c5e\u6027\u3002 \u8fd9\u5c31\u662f\u4e3a\u4ec0\u4e48\u8fd9\u662f\u6709\u95ee\u9898\u7684\uff1a</p> <pre><code>def takes_box_evil(box: Box) -&gt; None:\n    box.content = \"asdf\"  # \u8fd9\u5f88\u7cdf\u7cd5\uff0c\u56e0\u4e3a box.content \u5e94\u8be5\u662f\u4e00\u4e2a\u5bf9\u8c61\n\nmy_int_box = IntBox()\ntakes_box_evil(my_int_box)\nmy_int_box.content + 1  # Oops, TypeError!\n</code></pre> <p>\u53ef\u4ee5\u901a\u8fc7\u4f7f\u7528 <code>@property</code> \u5728 <code>Box</code> \u534f\u8bae\u4e2d\u5c06 <code>content</code> \u58f0\u660e\u4e3a\u53ea\u8bfb\u6765\u89e3\u51b3\u6b64\u95ee\u9898\uff1a</p> <pre><code>class Box(Protocol):\n    @property\n    def content(self) -&gt; object: ...\n\nclass IntBox:\n    content: int\n\ndef takes_box(box: Box) -&gt; None: ...\n\ntakes_box(IntBox(42))  # OK\n</code></pre> <p>Invariance of protocol attributes</p> <p>A common issue with protocols is that protocol attributes are invariant. For example:</p> <pre><code>class Box(Protocol):\n    content: object\n\nclass IntBox:\n    content: int\n\ndef takes_box(box: Box) -&gt; None: ...\n\ntakes_box(IntBox())  # error: Argument 1 to \"takes_box\" has incompatible type \"IntBox\"; expected \"Box\"\n                    # note:  Following member(s) of \"IntBox\" have conflicts:\n                    # note:      content: expected \"object\", got \"int\"\n</code></pre> <p>This is because <code>Box</code> defines <code>content</code> as a mutable attribute. Here's why this is problematic:</p> <pre><code>def takes_box_evil(box: Box) -&gt; None:\n    box.content = \"asdf\"  # This is bad, since box.content is supposed to be an object\n\nmy_int_box = IntBox()\ntakes_box_evil(my_int_box)\nmy_int_box.content + 1  # Oops, TypeError!\n</code></pre> <p>This can be fixed by declaring <code>content</code> to be read-only in the <code>Box</code> protocol using <code>@property</code>:</p> <pre><code>class Box(Protocol):\n    @property\n    def content(self) -&gt; object: ...\n\nclass IntBox:\n    content: int\n\ndef takes_box(box: Box) -&gt; None: ...\n\ntakes_box(IntBox(42))  # OK\n</code></pre>"},{"location":"mypy/protocol_and_struct_subtyping/#\u9012\u5f52\u534f\u8bae","title":"\u9012\u5f52\u534f\u8bae","text":"\u4e2d\u6587\u82f1\u6587 <p>\u534f\u8bae\u53ef\u4ee5\u662f\u9012\u5f52\u7684\uff08\u81ea\u5f15\u7528\uff09\u548c\u76f8\u4e92\u9012\u5f52\u7684\u3002 \u8fd9\u5bf9\u4e8e\u58f0\u660e\u62bd\u8c61\u9012\u5f52\u96c6\u5408\uff08\u4f8b\u5982\u6811\u548c\u94fe\u8868\uff09\u5f88\u6709\u7528\uff1a</p> <pre><code>from typing import TypeVar, Optional\nfrom typing_extensions import Protocol\n\nclass TreeLike(Protocol):\n    value: int\n\n    @property\n    def left(self) -&gt; Optional['TreeLike']: ...\n\n    @property\n    def right(self) -&gt; Optional['TreeLike']: ...\n\nclass SimpleTree:\n    def __init__(self, value: int) -&gt; None:\n        self.value = value\n        self.left: Optional['SimpleTree'] = None\n        self.right: Optional['SimpleTree'] = None\n\nroot: TreeLike = SimpleTree(0)  # OK\n</code></pre> <p>Recursive protocols</p> <p>Protocols can be recursive (self-referential) and mutually recursive. This is useful for declaring abstract recursive collections such as trees and linked lists:</p> <pre><code>from typing import TypeVar, Optional\nfrom typing_extensions import Protocol\n\nclass TreeLike(Protocol):\n    value: int\n\n    @property\n    def left(self) -&gt; Optional['TreeLike']: ...\n\n    @property\n    def right(self) -&gt; Optional['TreeLike']: ...\n\nclass SimpleTree:\n    def __init__(self, value: int) -&gt; None:\n        self.value = value\n        self.left: Optional['SimpleTree'] = None\n        self.right: Optional['SimpleTree'] = None\n\nroot: TreeLike = SimpleTree(0)  # OK\n</code></pre>"},{"location":"mypy/protocol_and_struct_subtyping/#isinstance-\u548c\u534f\u8bae\u4e00\u8d77\u4f7f\u7528","title":"isinstance() \u548c\u534f\u8bae\u4e00\u8d77\u4f7f\u7528","text":"\u4e2d\u6587\u82f1\u6587 <p>\u5982\u679c\u4f7f\u7528<code>@runtime_checkable</code>\u7c7b\u88c5\u9970\u5668\u88c5\u9970\u534f\u8bae\u7c7b\uff0c\u5219\u53ef\u4ee5\u5c06\u5176\u4e0e <code>isinstance</code> \u4e00\u8d77\u4f7f\u7528\u3002 \u88c5\u9970\u5668\u6dfb\u52a0\u4e86\u5bf9\u8fd0\u884c\u65f6\u7ed3\u6784\u68c0\u67e5\u7684\u57fa\u672c\u652f\u6301\uff1a</p> <pre><code>from typing_extensions import Protocol, runtime_checkable\n\n@runtime_checkable\nclass Portable(Protocol):\n    handles: int\n\nclass Mug:\n    def __init__(self) -&gt; None:\n        self.handles = 1\n\ndef use(handles: int) -&gt; None: ...\n\nmug = Mug()\nif isinstance(mug, Portable):  # Works at runtime!\nuse(mug.handles)\n</code></pre> <p><code>isinstance</code> \u4e5f\u9002\u7528\u4e8e <code>\u9884\u5b9a\u4e49\u534f\u8bae</code> \u5728 <code>typing</code> \u4e2d\uff0c\u4f8b\u5982 <code>Iterable</code>\u3002</p> <p>Warning</p> <p>\u4f7f\u7528\u534f\u8bae\u7684 <code>isinstance</code> \u5728\u8fd0\u884c\u65f6\u5e76\u4e0d\u5b8c\u5168\u5b89\u5168\u3002 \u4f8b\u5982\uff0c\u4e0d\u68c0\u67e5\u65b9\u6cd5\u7684\u7b7e\u540d\u3002 \u8fd0\u884c\u65f6\u5b9e\u73b0\u4ec5\u68c0\u67e5\u6240\u6709\u534f\u8bae\u6210\u5458\u662f\u5426\u5b58\u5728\uff0c\u800c\u4e0d\u68c0\u67e5\u5b83\u4eec\u662f\u5426\u5177\u6709\u6b63\u786e\u7684\u7c7b\u578b\u3002 \u4f7f\u7528\u534f\u8bae\u7684 <code>issubclass</code> \u53ea\u4f1a\u68c0\u67e5\u65b9\u6cd5\u662f\u5426\u5b58\u5728\u3002</p> <p>Note</p> <p>\u4f7f\u7528\u534f\u8bae\u7684 <code>isinstance</code> \u4e5f\u53ef\u80fd\u6162\u5f97\u60ca\u4eba\u3002 \u5728\u8bb8\u591a\u60c5\u51b5\u4e0b\uff0c\u4f7f\u7528 <code>hasattr</code> \u6765\u68c0\u67e5\u5c5e\u6027\u662f\u5426\u5b58\u5728\u4f1a\u66f4\u597d\u3002</p> <p>Using isinstance() with protocols</p> <p>You can use a protocol class with isinstance() if you decorate it with the @runtime_checkable class decorator. The decorator adds rudimentary support for runtime structural checks:</p> <pre><code>from typing_extensions import Protocol, runtime_checkable\n\n@runtime_checkable\nclass Portable(Protocol):\n    handles: int\n\nclass Mug:\n    def __init__(self) -&gt; None:\n        self.handles = 1\n\ndef use(handles: int) -&gt; None: ...\n\nmug = Mug()\nif isinstance(mug, Portable):  # Works at runtime!\nuse(mug.handles)\n</code></pre> <p>isinstance() also works with the predefined protocols in typing such as Iterable.</p> <p>Warning</p> <p>\u4f7f\u7528\u534f\u8bae\u7684 <code>isinstance</code> \u5728\u8fd0\u884c\u65f6\u5e76\u4e0d\u5b8c\u5168\u5b89\u5168\u3002 \u4f8b\u5982\uff0c\u4e0d\u68c0\u67e5\u65b9\u6cd5\u7684\u7b7e\u540d\u3002 \u8fd0\u884c\u65f6\u5b9e\u73b0\u4ec5\u68c0\u67e5\u6240\u6709\u534f\u8bae\u6210\u5458\u662f\u5426\u5b58\u5728\uff0c\u800c\u4e0d\u68c0\u67e5\u5b83\u4eec\u662f\u5426\u5177\u6709\u6b63\u786e\u7684\u7c7b\u578b\u3002 \u4f7f\u7528\u534f\u8bae\u7684 <code>issubclass</code> \u53ea\u4f1a\u68c0\u67e5\u65b9\u6cd5\u662f\u5426\u5b58\u5728\u3002</p> <p>Note</p> <p>\u4f7f\u7528\u534f\u8bae\u7684 <code>isinstance</code> \u4e5f\u53ef\u80fd\u6162\u5f97\u60ca\u4eba\u3002 \u5728\u8bb8\u591a\u60c5\u51b5\u4e0b\uff0c\u4f7f\u7528 <code>hasattr</code> \u6765\u68c0\u67e5\u5c5e\u6027\u662f\u5426\u5b58\u5728\u4f1a\u66f4\u597d\u3002</p>"},{"location":"mypy/protocol_and_struct_subtyping/#\u56de\u8c03\u534f\u8bae","title":"\u56de\u8c03\u534f\u8bae","text":"\u4e2d\u6587\u82f1\u6587 <p>\u534f\u8bae\u53ef\u7528\u4e8e\u5b9a\u4e49\u7075\u6d3b\u7684\u56de\u8c03\u7c7b\u578b\uff0c\u8fd9\u4e9b\u7c7b\u578b\u5f88\u96be\uff08\u751a\u81f3\u4e0d\u53ef\u80fd\uff09\u4f7f\u7528 [<code>Callable[...]</code>](https://docs.python.org/3/library/typing.html#types.Callable\uff09\u8bed\u6cd5\uff0c\u4f8b\u5982\u53ef\u53d8\u53c2\u6570\u3001\u91cd\u8f7d\u548c\u590d\u6742\u7684\u6cdb\u578b\u56de\u8c03\u3002 \u5b83\u4eec\u662f\u7528\u7279\u6b8a\u7684 <code>__call__</code> \u6210\u5458\u5b9a\u4e49\u7684\uff1a</p> <pre><code>from typing import Optional, Iterable\nfrom typing_extensions import Protocol\n\nclass Combiner(Protocol):\n    def __call__(self, *vals: bytes, maxlen: Optional[int] = None) -&gt; list[bytes]: ...\n\ndef batch_proc(data: Iterable[bytes], cb_results: Combiner) -&gt; bytes:\n    for item in data:\n        ...\n\ndef good_cb(*vals: bytes, maxlen: Optional[int] = None) -&gt; list[bytes]:\n    ...\ndef bad_cb(*vals: bytes, maxitems: Optional[int]) -&gt; list[bytes]:\n    ...\n\nbatch_proc([], good_cb)  # OK\nbatch_proc([], bad_cb)   # Error! Argument 2 has incompatible type because of\n                        # different name and kind in the callback\n</code></pre> <p>\u56de\u8c03\u534f\u8bae\u548c <code>typing.Callable</code> \u5927\u90e8\u5206\u7c7b\u578b\u53ef\u4ee5\u4e92\u6362\u4f7f\u7528\u3002 <code>__call__</code> \u65b9\u6cd5\u4e2d\u7684\u53c2\u6570\u540d\u79f0\u5fc5\u987b\u76f8\u540c\uff0c\u9664\u975e\u4f7f\u7528\u53cc\u4e0b\u5212\u7ebf\u524d\u7f00\u3002 \u4f8b\u5982\uff1a</p> <pre><code>from typing import Callable, TypeVar\nfrom typing_extensions import Protocol\n\nT = TypeVar('T')\n\nclass Copy(Protocol):\n    def __call__(self, __origin: T) -&gt; T: ...\n\ncopy_a: Callable[[T], T]\ncopy_b: Copy\n\ncopy_a = copy_b  # OK\ncopy_b = copy_a  # Also OK\n</code></pre> <p>Callback protocols</p> <p>Protocols can be used to define flexible callback types that are hard (or even impossible) to express using the <code>Callable[...]</code> syntax, such as variadic, overloaded, and complex generic callbacks. They are defined with a special <code>__call__</code> member:</p> <pre><code>from typing import Optional, Iterable\nfrom typing_extensions import Protocol\n\nclass Combiner(Protocol):\n    def __call__(self, *vals: bytes, maxlen: Optional[int] = None) -&gt; list[bytes]: ...\n\ndef batch_proc(data: Iterable[bytes], cb_results: Combiner) -&gt; bytes:\n    for item in data:\n        ...\n\ndef good_cb(*vals: bytes, maxlen: Optional[int] = None) -&gt; list[bytes]:\n    ...\ndef bad_cb(*vals: bytes, maxitems: Optional[int]) -&gt; list[bytes]:\n    ...\n\nbatch_proc([], good_cb)  # OK\nbatch_proc([], bad_cb)   # Error! Argument 2 has incompatible type because of\n                        # different name and kind in the callback\n</code></pre> <p>Callback protocols and <code>typing.Callable</code> types can be used mostly interchangeably. Argument names in <code>__call__</code> methods must be identical, unless a double underscore prefix is used. For example:</p> <pre><code>from typing import Callable, TypeVar\nfrom typing_extensions import Protocol\n\nT = TypeVar('T')\n\nclass Copy(Protocol):\n    def __call__(self, __origin: T) -&gt; T: ...\n\ncopy_a: Callable[[T], T]\ncopy_b: Copy\n\ncopy_a = copy_b  # OK\ncopy_b = copy_a  # Also OK\n</code></pre>"},{"location":"mypy/protocol_and_struct_subtyping/#\u9884\u5b9a\u4e49\u534f\u8bae\u53c2\u8003","title":"\u9884\u5b9a\u4e49\u534f\u8bae\u53c2\u8003","text":""},{"location":"mypy/protocol_and_struct_subtyping/#\u8fed\u4ee3\u534f\u8bae","title":"\u8fed\u4ee3\u534f\u8bae","text":"<p>Iteration protocols</p> \u4e2d\u6587\u82f1\u6587 <p>\u8fed\u4ee3\u534f\u8bae\u5728\u8bb8\u591a\u60c5\u51b5\u4e0b\u90fd\u5f88\u6709\u7528\u3002 \u4f8b\u5982\uff0c\u5b83\u4eec\u5141\u8bb8\u5728 for \u5faa\u73af\u4e2d\u8fed\u4ee3\u5bf9\u8c61\u3002</p> <p>The iteration protocols are useful in many contexts. For example, they allow iteration of objects in for loops.</p>"},{"location":"mypy/protocol_and_struct_subtyping/#\u53ef\u8fed\u4ee3\u6cdb\u578b","title":"\u53ef\u8fed\u4ee3\u6cdb\u578b","text":"<p>Iterable[T]</p> \u4e2d\u6587\u82f1\u6587 <p><code>\u4e0a\u9762\u7684\u4f8b\u5b50</code>\u6709\u4e00\u4e2a <code>__iter__</code> \u65b9\u6cd5\u7684\u7b80\u5355\u5b9e\u73b0\u3002</p> <pre><code>def __iter__(self) -&gt; Iterator[T]\n</code></pre> <p>\u53e6\u8bf7\u53c2\u9605<code>typing.Iterable</code>\u3002</p> <p>The <code>example above</code> has a simple implementation of an <code>__iter__</code> method.</p> <pre><code>def __iter__(self) -&gt; Iterator[T]\n</code></pre> <p>See also <code>typing.Iterable</code>.</p>"},{"location":"mypy/protocol_and_struct_subtyping/#\u8fed\u4ee3\u5668\u6cdb\u578b","title":"\u8fed\u4ee3\u5668\u6cdb\u578b","text":"<p>Iterator[T]</p> \u4e2d\u6587\u82f1\u6587 <pre><code>def __next__(self) -&gt; T\ndef __iter__(self) -&gt; Iterator[T]\n</code></pre> <p>\u4e5f\u53ef\u4ee5\u770b\u770b <code>typing.Iterator</code>.</p> <pre><code>def __next__(self) -&gt; T\ndef __iter__(self) -&gt; Iterator[T]\n</code></pre> <p>See also <code>typing.Iterator</code>.</p>"},{"location":"mypy/protocol_and_struct_subtyping/#\u96c6\u5408\u534f\u8bae","title":"\u96c6\u5408\u534f\u8bae","text":"<p>Collection protocols</p> \u4e2d\u6587\u82f1\u6587 <p>\u5176\u4e2d\u8bb8\u591a\u662f\u901a\u8fc7\u5185\u7f6e\u5bb9\u5668\u7c7b\u578b\u5b9e\u73b0\u7684\uff0c\u4f8b\u5982 <code>list</code> \u548c [<code>dict</code>](https:// docs.python.org/3/library/stdtypes.html#dict\uff09\uff0c\u8fd9\u4e9b\u5bf9\u4e8e\u7528\u6237\u5b9a\u4e49\u7684\u96c6\u5408\u5bf9\u8c61\u4e5f\u5f88\u6709\u7528\u3002</p> <p>Collection protocols</p> <p>Many of these are implemented by built-in container types such as <code>list</code> and <code>dict</code>, and these are also useful for user-defined collection objects.</p>"},{"location":"mypy/protocol_and_struct_subtyping/#sized","title":"Sized","text":"\u4e2d\u6587\u82f1\u6587 <p>\u8fd9\u662f\u652f\u6301 <code>len(x)</code> \u7684\u5bf9\u8c61\u7c7b\u578b\u3002</p> <pre><code>def __len__(self) -&gt; int\n</code></pre> <p>\u4e5f\u53ef\u4ee5\u770b\u770b <code>typing.Sized</code>.</p> <p>This is a type for objects that support <code>len(x)</code>.</p> <pre><code>def __len__(self) -&gt; int\n</code></pre> <p>See also <code>typing.Sized</code>.</p>"},{"location":"mypy/protocol_and_struct_subtyping/#\u6cdb\u578b\u5bb9\u5668","title":"\u6cdb\u578b\u5bb9\u5668","text":"<p>Container[T]</p> \u4e2d\u6587\u82f1\u6587 <p>\u8fd9\u662f\u652f\u6301 <code>in</code> \u8fd0\u7b97\u7b26\u7684\u5bf9\u8c61\u7c7b\u578b\u3002</p> <pre><code>def __contains__(self, x: object) -&gt; bool\n</code></pre> <p>\u540c\u6837\u53c2\u8003 <code>Container</code>.</p> <p>This is a type for objects that support the <code>in</code> operator.</p> <pre><code>def __contains__(self, x: object) -&gt; bool\n</code></pre> <p>See also <code>Container</code>.</p>"},{"location":"mypy/protocol_and_struct_subtyping/#\u96c6\u5408\u6cdb\u578b","title":"\u96c6\u5408\u6cdb\u578b","text":"<p>Collection[T]</p> \u4e2d\u6587\u82f1\u6587 <pre><code>def __len__(self) -&gt; int\ndef __iter__(self) -&gt; Iterator[T]\ndef __contains__(self, x: object) -&gt; bool\n</code></pre> <p>\u540c\u6837\u53c2\u8003 <code>Collection</code>.</p> <pre><code>def __len__(self) -&gt; int\ndef __iter__(self) -&gt; Iterator[T]\ndef __contains__(self, x: object) -&gt; bool\n</code></pre> <p>See also <code>Collection</code>.</p>"},{"location":"mypy/protocol_and_struct_subtyping/#\u4e00\u6b21\u6027\u534f\u8bae","title":"\u4e00\u6b21\u6027\u534f\u8bae","text":"<p>One-off protocols</p> \u4e2d\u6587\u82f1\u6587 <p>\u8fd9\u4e9b\u534f\u8bae\u901a\u5e38\u4ec5\u9002\u7528\u4e8e\u5355\u4e2a\u6807\u51c6\u5e93\u51fd\u6570\u6216\u7c7b\u3002</p> <p>These protocols are typically only useful with a single standard library function or class.</p>"},{"location":"mypy/protocol_and_struct_subtyping/#\u5012\u5e8f\u6cdb\u578b","title":"\u5012\u5e8f\u6cdb\u578b","text":"<p>Reversible[T]</p> \u4e2d\u6587\u82f1\u6587 <p>\u8fd9\u662f\u652f\u6301 <code>reversed(x)</code> \u7684\u5bf9\u8c61\u7c7b\u578b\u3002</p> <pre><code>def __reversed__(self) -&gt; Iterator[T]\n</code></pre> <p>\u540c\u6837\u53c2\u8003 <code>Reversible</code>.</p> <p>This is a type for objects that support <code>reversed(x)</code>.</p> <pre><code>def __reversed__(self) -&gt; Iterator[T]\n</code></pre> <p>See also <code>Reversible</code>.</p>"},{"location":"mypy/protocol_and_struct_subtyping/#\u7edd\u5bf9\u503c\u6cdb\u578b","title":"\u7edd\u5bf9\u503c\u6cdb\u578b","text":"<p>SupportsAbs[T]</p> \u4e2d\u6587\u82f1\u6587 <p>\u8fd9\u662f\u652f\u6301 <code>abs(x)</code> \u7684\u5bf9\u8c61\u7c7b\u578b\u3002 <code>T</code> \u662f <code>abs(x)</code> \u8fd4\u56de\u7684\u503c\u7684\u7c7b\u578b\u3002</p> <pre><code>def __abs__(self) -&gt; T\n</code></pre> <p>\u540c\u6837\u53c2\u8003 <code>SupportsAbs</code>.</p> <p>This is a type for objects that support <code>abs(x)</code>. <code>T</code> is the type of value returned by <code>abs(x)</code>.</p> <pre><code>def __abs__(self) -&gt; T\n</code></pre> <p>See also <code>SupportsAbs</code>.</p>"},{"location":"mypy/protocol_and_struct_subtyping/#\u652f\u6301\u5b57\u8282","title":"\u652f\u6301\u5b57\u8282","text":"<p>SupportsBytes</p> \u4e2d\u6587\u82f1\u6587 <p>\u8fd9\u662f\u652f\u6301 <code>bytes(x)</code> \u7684\u5bf9\u8c61\u7c7b\u578b\u3002</p> <pre><code>def __bytes__(self) -&gt; bytes\n</code></pre> <p>\u53e6\u8bf7\u53c2\u9605 <code>SupportsBytes</code>\u3002</p> <p>This is a type for objects that support <code>bytes(x)</code>.</p> <pre><code>def __bytes__(self) -&gt; bytes\n</code></pre> <p>See also <code>SupportsBytes</code>.</p>"},{"location":"mypy/protocol_and_struct_subtyping/#\u652f\u6301\u590d\u6570","title":"\u652f\u6301\u590d\u6570","text":"<p>SupportsComplex</p> \u4e2d\u6587\u82f1\u6587 <p>\u8fd9\u662f\u652f\u6301 <code>complex(x)</code> \u7684\u5bf9\u8c61\u7c7b\u578b\u3002 \u8bf7\u6ce8\u610f\uff0c\u4e0d\u652f\u6301\u7b97\u672f\u8fd0\u7b97\u3002</p> <pre><code>def __complex__(self) -&gt; complex\n</code></pre> <p>\u53e6\u8bf7\u53c2\u9605 <code>SupportsComplex</code>.</p> <p>This is a type for objects that support <code>complex(x)</code>. Note that no arithmetic operations are supported.</p> <pre><code>def __complex__(self) -&gt; complex\n</code></pre> <p>See also <code>SupportsComplex</code>.</p>"},{"location":"mypy/protocol_and_struct_subtyping/#\u652f\u6301\u6d6e\u70b9\u6570","title":"\u652f\u6301\u6d6e\u70b9\u6570","text":"<p>SupportsFloat</p> \u4e2d\u6587\u82f1\u6587 <p>\u8fd9\u662f\u652f\u6301 <code>float(x)</code> \u7684\u5bf9\u8c61\u7c7b\u578b\u3002 \u8bf7\u6ce8\u610f\uff0c\u4e0d\u652f\u6301\u7b97\u672f\u8fd0\u7b97\u3002</p> <pre><code>def __float__(self) -&gt; float\n</code></pre> <p>\u53e6\u8bf7\u53c2\u9605 <code>SupportsFloat</code>.</p> <p>This is a type for objects that support <code>float(x)</code>. Note that no arithmetic operations are supported.</p> <pre><code>def __float__(self) -&gt; float\n</code></pre> <p>See also <code>SupportsFloat</code>.</p>"},{"location":"mypy/protocol_and_struct_subtyping/#\u652f\u6301\u6574\u6570","title":"\u652f\u6301\u6574\u6570","text":"<p>SupportsInt</p> \u4e2d\u6587\u82f1\u6587 <p>\u8fd9\u662f\u652f\u6301 <code>int(x)</code> \u7684\u5bf9\u8c61\u7c7b\u578b\u3002 \u8bf7\u6ce8\u610f\uff0c\u4e0d\u652f\u6301\u7b97\u672f\u8fd0\u7b97\u3002</p> <pre><code>def __int__(self) -&gt; int\n</code></pre> <p>\u53e6\u8bf7\u53c2\u9605 <code>SupportsInt</code>.</p> <p>This is a type for objects that support <code>int(x)</code>. Note that no arithmetic operations are supported.</p> <pre><code>def __int__(self) -&gt; int\n</code></pre> <p>See also <code>SupportsInt</code>.</p>"},{"location":"mypy/protocol_and_struct_subtyping/#\u652f\u6301round\u6cdb\u578b","title":"\u652f\u6301Round\u6cdb\u578b","text":"<p>SupportsRound[T]</p> \u4e2d\u6587\u82f1\u6587 <p>\u8fd9\u662f\u652f\u6301 <code>round(x)</code> \u7684\u5bf9\u8c61\u7c7b\u578b\u3002</p> <pre><code>def __round__(self) -&gt; T\n</code></pre> <p>\u53e6\u8bf7\u53c2\u9605 <code>SupportsRound</code>.</p> <p>This is a type for objects that support <code>round(x)</code>.</p> <pre><code>def __round__(self) -&gt; T\n</code></pre> <p>See also <code>SupportsRound</code>.</p>"},{"location":"mypy/protocol_and_struct_subtyping/#\u5f02\u6b65\u534f\u8bae","title":"\u5f02\u6b65\u534f\u8bae","text":"<p>Async protocols</p> \u4e2d\u6587\u82f1\u6587 <p>\u8fd9\u4e9b\u534f\u8bae\u5728\u5f02\u6b65\u4ee3\u7801\u4e2d\u5f88\u6709\u7528\u3002 \u8bf7\u53c2\u9605 <code>async-and-await</code> \u4e86\u89e3\u66f4\u591a\u4fe1\u606f\u3002</p> <p>These protocols can be useful in async code. See <code>async-and-await</code> for more information.</p>"},{"location":"mypy/protocol_and_struct_subtyping/#\u53ef\u7b49\u5f85\u6cdb\u578b\u5bf9\u8c61","title":"\u53ef\u7b49\u5f85\u6cdb\u578b\u5bf9\u8c61","text":"<p>Awaitable[T]</p> \u4e2d\u6587\u82f1\u6587 <pre><code>def __await__(self) -&gt; Generator[Any, None, T]\n</code></pre> <p>\u53e6\u8bf7\u53c2\u9605 <code>Awaitable</code>.</p> <pre><code>def __await__(self) -&gt; Generator[Any, None, T]\n</code></pre> <p>See also <code>Awaitable</code>.</p>"},{"location":"mypy/protocol_and_struct_subtyping/#\u5f02\u6b65\u53ef\u8fed\u4ee3\u6cdb\u578b\u5bf9\u8c61","title":"\u5f02\u6b65\u53ef\u8fed\u4ee3\u6cdb\u578b\u5bf9\u8c61","text":"<p>AsyncIterable[T]</p> \u4e2d\u6587\u82f1\u6587 <pre><code>def __aiter__(self) -&gt; AsyncIterator[T]\n</code></pre> <p>\u53e6\u8bf7\u53c2\u9605 <code>AsyncIterable</code>.</p> <pre><code>def __aiter__(self) -&gt; AsyncIterator[T]\n</code></pre> <p>See also <code>AsyncIterable</code>.</p>"},{"location":"mypy/protocol_and_struct_subtyping/#\u5f02\u6b65\u8fed\u4ee3\u5668\u6cdb\u578b\u5bf9\u8c61","title":"\u5f02\u6b65\u8fed\u4ee3\u5668\u6cdb\u578b\u5bf9\u8c61","text":"<p>AsyncIterator[T]</p> \u4e2d\u6587\u82f1\u6587 <pre><code>def __anext__(self) -&gt; Awaitable[T]\ndef __aiter__(self) -&gt; AsyncIterator[T]\n</code></pre> <p>\u53e6\u8bf7\u53c2\u9605 <code>AsyncIterator</code>.</p> <pre><code>def __anext__(self) -&gt; Awaitable[T]\ndef __aiter__(self) -&gt; AsyncIterator[T]\n</code></pre> <p>See also <code>AsyncIterator</code>.</p>"},{"location":"mypy/protocol_and_struct_subtyping/#\u4e0a\u4e0b\u6587\u7ba1\u7406\u5668\u534f\u8bae","title":"\u4e0a\u4e0b\u6587\u7ba1\u7406\u5668\u534f\u8bae","text":"<p>Context manager protocols</p> \u4e2d\u6587\u82f1\u6587 <p>\u4e0a\u4e0b\u6587\u7ba1\u7406\u5668\u6709\u4e24\u79cd\u534f\u8bae\u2014\u2014\u4e00\u79cd\u7528\u4e8e\u5e38\u89c4\u4e0a\u4e0b\u6587\u7ba1\u7406\u5668\uff0c\u53e6\u4e00\u79cd\u7528\u4e8e\u5f02\u6b65\u4e0a\u4e0b\u6587\u7ba1\u7406\u5668\u3002 \u8fd9\u4e9b\u5141\u8bb8\u5b9a\u4e49\u53ef\u5728<code>with</code>\u548c<code>async with</code>\u8bed\u53e5\u4e2d\u4f7f\u7528\u7684\u5bf9\u8c61\u3002</p> <p>There are two protocols for context managers -- one for regular context managers and one for async ones. These allow defining objects that can be used in <code>with</code> and <code>async with</code> statements.</p>"},{"location":"mypy/protocol_and_struct_subtyping/#\u4e0a\u4e0b\u6587\u7ba1\u7406\u5668\u6cdb\u578b","title":"\u4e0a\u4e0b\u6587\u7ba1\u7406\u5668\u6cdb\u578b","text":"<p>ContextManager[T]</p> \u4e2d\u6587\u82f1\u6587 <pre><code>def __enter__(self) -&gt; T\ndef __exit__(self,\n            exc_type: Optional[Type[BaseException]],\n            exc_value: Optional[BaseException],\n            traceback: Optional[TracebackType]) -&gt; Optional[bool]\n</code></pre> <p>\u53e6\u8bf7\u53c2\u9605 <code>ContextManager</code>.</p> <pre><code>def __enter__(self) -&gt; T\ndef __exit__(self,\n            exc_type: Optional[Type[BaseException]],\n            exc_value: Optional[BaseException],\n            traceback: Optional[TracebackType]) -&gt; Optional[bool]\n</code></pre> <p>See also <code>ContextManager</code>.</p>"},{"location":"mypy/protocol_and_struct_subtyping/#\u5f02\u6b65\u4e0a\u4e0b\u6587\u6cdb\u578b\u7ba1\u7406\u5668","title":"\u5f02\u6b65\u4e0a\u4e0b\u6587\u6cdb\u578b\u7ba1\u7406\u5668","text":"<p>AsyncContextManager[T]</p> \u4e2d\u6587\u82f1\u6587 <pre><code>def __aenter__(self) -&gt; Awaitable[T]\ndef __aexit__(self,\n            exc_type: Optional[Type[BaseException]],\n            exc_value: Optional[BaseException],\n            traceback: Optional[TracebackType]) -&gt; Awaitable[Optional[bool]]\n</code></pre> <p>\u53e6\u8bf7\u53c2\u9605 <code>AsyncContextManager</code>\u3002</p> <pre><code>def __aenter__(self) -&gt; Awaitable[T]\ndef __aexit__(self,\n            exc_type: Optional[Type[BaseException]],\n            exc_value: Optional[BaseException],\n            traceback: Optional[TracebackType]) -&gt; Awaitable[Optional[bool]]\n</code></pre> <p>See also <code>AsyncContextManager</code>.</p>"},{"location":"mypy/stub_files/","title":"\u5b58\u6839\u6587\u4ef6","text":"\u4e2d\u6587\u82f1\u6587 <p>\u5b58\u6839\u6587\u4ef6 \u662f\u4e00\u4e2a\u5305\u542b Python \u6a21\u5757\u516c\u5171\u63a5\u53e3\u6846\u67b6\u7684\u6587\u4ef6\uff0c\u5305\u62ec\u7c7b\u3001\u53d8\u91cf\u3001\u51fd\u6570\u2014\u2014\u6700\u91cd\u8981\u7684\u662f\u5b83\u4eec\u7684\u7c7b\u578b\u3002</p> <p>Mypy \u4f7f\u7528\u5b58\u50a8\u5728 typeshed \u5b58\u50a8\u5e93\u4e2d\u7684\u5b58\u6839\u6587\u4ef6\u6765\u786e\u5b9a\u6807\u51c6\u5e93\u548c\u7b2c\u4e09\u65b9\u5e93\u51fd\u6570\u3001\u7c7b\u548c\u5176\u4ed6\u5b9a\u4e49\u7684\u7c7b\u578b\u3002 \u60a8\u8fd8\u53ef\u4ee5\u521b\u5efa\u81ea\u5df1\u7684\u5b58\u6839\uff0c\u7528\u4e8e\u5bf9\u4ee3\u7801\u8fdb\u884c\u7c7b\u578b\u68c0\u67e5\u3002</p> <p>Stub files</p> <p>A stub file is a file containing a skeleton of the public interface of that Python module, including classes, variables, functions -- and most importantly, their types.</p> <p>Mypy uses stub files stored in the typeshed repository to determine the types of standard library and third-party library functions, classes, and other definitions. You can also create your own stubs that will be used to type check your code.</p>"},{"location":"mypy/stub_files/#\u521b\u5efa\u4e00\u4e2a\u5b58\u6839","title":"\u521b\u5efa\u4e00\u4e2a\u5b58\u6839","text":"<p>Creating a stub</p> \u4e2d\u6587\u82f1\u6587 <p>\u4ee5\u4e0b\u662f\u5982\u4f55\u521b\u5efa\u5b58\u6839\u6587\u4ef6\u7684\u6982\u8ff0\uff1a</p> <ul> <li> <p>\u4e3a\u5e93\uff08\u6216\u4efb\u610f\u6a21\u5757\uff09\u7f16\u5199\u5b58\u6839\u6587\u4ef6\uff0c\u5e76\u5c06\u5176\u4f5c\u4e3a<code>.pyi</code>\u6587\u4ef6\u5b58\u50a8\u5728\u4e0e\u5e93\u6a21\u5757\u76f8\u540c\u7684\u76ee\u5f55\u4e2d\u3002</p> </li> <li> <p>\u6216\u8005\uff0c\u5c06\u5b58\u6839\uff08<code>.pyi</code> \u6587\u4ef6\uff09\u653e\u5728\u4e3a\u5b58\u6839\u4fdd\u7559\u7684\u76ee\u5f55\u4e2d\uff08\u4f8b\u5982\uff0c<code>myproject/stubs</code>\uff09\u3002 \u5728\u8fd9\u79cd\u60c5\u51b5\u4e0b\uff0c\u60a8\u5fc5\u987b\u8bbe\u7f6e\u73af\u5883\u53d8\u91cf<code>MYPYPATH</code>\u6765\u5f15\u7528\u8be5\u76ee\u5f55\u3002 \u4f8b\u5982\uff1a</p> <pre><code>export MYPYPATH=~/work/myproject/stubs\n</code></pre> </li> </ul> <p>\u5bf9\u6a21\u5757\u4f7f\u7528\u6b63\u5e38\u7684 Python \u6587\u4ef6\u540d\u7ea6\u5b9a\uff0c\u4f8b\u5982 \u6a21\u5757<code>csv</code>\u7684<code>csv.pyi</code>\u3002 \u4f7f\u7528\u5305\u542b<code>__init__.pyi</code>\u7684\u5b50\u76ee\u5f55\u4f5c\u4e3a\u5305\u3002 \u8bf7\u6ce8\u610f\uff0c\u5fc5\u987b\u5b89\u88c5 <code>PEP 561</code> \u4ec5\u5b58\u6839\u8f6f\u4ef6\u5305\uff0c\u5e76\u4e14\u4e0d\u80fd\u901a\u8fc7 <code>MYPYPATH</code> \u6307\u5411(\u8bf7\u53c2\u9605 <code>PEP 561 \u652f\u6301</code>)\u3002</p> <p>\u5982\u679c\u76ee\u5f55\u5305\u542b\u540c\u4e00\u6a21\u5757\u7684<code>.py</code>\u548c<code>.pyi</code>\u6587\u4ef6\uff0c\u5219<code>.pyi</code>\u6587\u4ef6\u4f18\u5148\u3002 \u8fd9\u6837\uff0c\u5373\u4f7f\u60a8\u4e0d\u60f3\u4fee\u6539\u6e90\u4ee3\u7801\uff0c\u4e5f\u53ef\u4ee5\u8f7b\u677e\u5730\u4e3a\u6a21\u5757\u6dfb\u52a0\u6ce8\u91ca\u3002 \u4f8b\u5982\uff0c\u5982\u679c\u60a8\u5728\u7a0b\u5e8f\u4e2d\u4f7f\u7528\u7b2c 3 \u65b9\u5f00\u6e90\u5e93\uff08\u5e76\u4e14 typeshed \u4e2d\u8fd8\u6ca1\u6709\u5b58\u6839\uff09\uff0c\u8fd9\u53ef\u80fd\u5f88\u6709\u7528\u3002</p> <p>\u5c31\u662f\u8fd9\u6837\uff01</p> <p>\u73b0\u5728\u60a8\u53ef\u4ee5\u5728 mypy \u7a0b\u5e8f\u4e2d\u8bbf\u95ee\u8be5\u6a21\u5757\u5e76\u8f93\u5165\u4f7f\u7528\u8be5\u5e93\u7684\u68c0\u67e5\u4ee3\u7801\u3002 \u5982\u679c\u60a8\u4e3a\u5e93\u6a21\u5757\u7f16\u5199\u5b58\u6839\uff0c\u8bf7\u8003\u8651\u5c06\u5176\u8d21\u732e\u7ed9 typeshed \u5b58\u50a8\u5e93\uff0c\u4ee5\u4f9b\u4f7f\u7528 mypy \u7684\u5176\u4ed6\u7a0b\u5e8f\u5458\u4f7f\u7528\u3002</p> <p>Mypy \u8fd8\u9644\u5e26\u4e86\u4e24\u4e2a\u5de5\u5177\uff0c\u53ef\u4ee5\u66f4\u8f7b\u677e\u5730\u521b\u5efa\u548c\u7ef4\u62a4\u5b58\u6839\uff1a<code>\u81ea\u52a8\u5b58\u6839\u751f\u6210 (stubgen)</code> \u548c [<code>\u81ea\u52a8\u5b58\u6839\u6d4b\u8bd5\uff08stubtest\uff09</code>]\uff08https://mypy.readthedocs.io/en/latest/stubtest.html#stubtest\uff09\u3002</p> <p>\u4ee5\u4e0b\u90e8\u5206\u4ecb\u7ecd\u4e86\u53ef\u4ee5\u5728\u7a0b\u5e8f\u548c\u5b58\u6839\u6587\u4ef6\u4e2d\u4f7f\u7528\u7684\u7c7b\u578b\u6ce8\u91ca\u7c7b\u578b\u3002</p> <p>Note</p> <p>\u60a8\u53ef\u80fd\u60f3\u5c06<code>MYPYPATH</code>\u6307\u5411\u6807\u51c6\u5e93\u6216\u5b89\u88c5\u7b2c 3 \u65b9\u8f6f\u4ef6\u5305\u7684 <code>site-packages</code>\u76ee\u5f55\u3002 \u8fd9\u51e0\u4e4e\u603b\u662f\u4e00\u4e2a\u574f\u4e3b\u610f\u2014\u2014\u60a8\u53ef\u80fd\u4f1a\u6536\u5230\u5927\u91cf\u5173\u4e8e\u60a8\u6ca1\u6709\u7f16\u5199\u7684\u4ee3\u7801\u7684\u9519\u8bef\u6d88\u606f\uff0c\u5e76\u4e14 mypy \u8fd8\u65e0\u6cd5\u5f88\u597d\u5730\u5206\u6790\uff0c\u5e76\u4e14\u5728\u6700\u574f\u7684\u60c5\u51b5\u4e0b\uff0cmypy \u53ef\u80fd\u4f1a\u7531\u4e8e\u67d0\u4e9b\u5b83\u6ca1\u60f3\u5230\u7684\u7b2c 3 \u65b9\u5305\u6784\u6784\u5efa\u800c\u5d29\u6e83, </p> <p>Here is an overview of how to create a stub file:</p> <ul> <li> <p>Write a stub file for the library (or an arbitrary module) and store it as a <code>.pyi</code> file in the same directory as the library module.</p> </li> <li> <p>Alternatively, put your stubs (<code>.pyi</code> files) in a directory reserved for stubs (e.g., {file}<code>myproject/stubs</code>). In this case you have to set the environment variable <code>MYPYPATH</code> to refer to the directory.  For example:</p> </li> </ul> <pre><code>export MYPYPATH=~/work/myproject/stubs\n</code></pre> <p>Use the normal Python file name conventions for modules, e.g. {file}<code>csv.pyi</code> for module <code>csv</code>. Use a subdirectory with <code>__init__.pyi</code> for packages. Note that <code>PEP 561</code> stub-only packages must be installed, and may not be pointed at through the <code>MYPYPATH</code> (see <code>PEP 561 support</code>).</p> <p>If a directory contains both a <code>.py</code> and a <code>.pyi</code> file for the same module, the <code>.pyi</code> file takes precedence. This way you can easily add annotations for a module even if you don't want to modify the source code. This can be useful, for example, if you use 3<sup>rd</sup> party open source libraries in your program (and there are no stubs in typeshed yet).</p> <p>That's it!</p> <p>Now you can access the module in mypy programs and type check code that uses the library. If you write a stub for a library module, consider making it available for other programmers that use mypy by contributing it back to the typeshed repo.</p> <p>Mypy also ships with two tools for making it easier to create and maintain stubs: <code>Automatic stub generation (stubgen)</code> and <code>Automatic stub testing (stubtest)</code>.</p> <p>The following sections explain the kinds of type annotations you can use in your programs and stub files.</p> <p>Note</p> <p>You may be tempted to point <code>MYPYPATH</code> to the standard library or to the {file}<code>site-packages</code> directory where your 3<sup>rd</sup> party packages are installed. This is almost always a bad idea -- you will likely get tons of error messages about code you didn't write and that mypy can't analyze all that well yet, and in the worst case scenario mypy may crash due to some construct in a 3<sup>rd</sup> party package that it didn't expect.</p>"},{"location":"mypy/stub_files/#\u5b58\u6839\u6587\u4ef6\u8bed\u6cd5","title":"\u5b58\u6839\u6587\u4ef6\u8bed\u6cd5","text":"\u4e2d\u6587\u82f1\u6587 <p>\u5b58\u6839\u6587\u4ef6\u662f\u7528\u666e\u901a\u7684 Python \u8bed\u6cd5\u7f16\u5199\u7684\uff0c\u4f46\u901a\u5e38\u4f1a\u7701\u7565\u8fd0\u884c\u65f6\u903b\u8f91\uff0c\u4f8b\u5982\u53d8\u91cf\u521d\u59cb\u503c\u8bbe\u5b9a\u9879\u3001\u51fd\u6570\u4f53\u548c\u9ed8\u8ba4\u53c2\u6570\u3002</p> <p>\u5982\u679c\u4e0d\u53ef\u80fd\u5b8c\u5168\u7701\u7565\u67d0\u4e9b\u8fd0\u884c\u65f6\u903b\u8f91\uff0c\u5efa\u8bae\u7684\u7ea6\u5b9a\u662f\u7528\u7701\u7565\u53f7\u8868\u8fbe\u5f0f\uff08<code>...</code>\uff09\u66ff\u6362\u6216\u5220\u9664\u5b83\u4eec\u3002 \u4e0b\u9762\u7684\u6bcf\u4e2a\u7701\u7565\u53f7\u5b9e\u9645\u4e0a\u90fd\u4ee5\u4e09\u4e2a\u70b9\u7684\u5f62\u5f0f\u5199\u5728\u5b58\u6839\u6587\u4ef6\u4e2d\uff1a</p> <pre><code># \u5e26\u6ce8\u91ca\u7684\u53d8\u91cf\u4e0d\u9700\u8981\u8d4b\u503c\u3002\n# \u56e0\u6b64\u6309\u7167\u60ef\u4f8b\uff0c\u6211\u4eec\u5728\u5b58\u6839\u6587\u4ef6\u4e2d\u7701\u7565\u5b83\u4eec\u3002\nx: int\n\n# \u51fd\u6570\u4f53\u65e0\u6cd5\u5b8c\u5168\u53bb\u9664\u3002 \u6309\u7167\u60ef\u4f8b\uff0c\n# \u6211\u4eec\u5c06\u5b83\u4eec\u66ff\u6362\u4e3a\u201c...\u201d\u800c\u4e0d\u662f\u201cpass\u201d\u8bed\u53e5\u3002\ndef func_1(code: str) -&gt; int: ...\n\n# \u6211\u4eec\u53ef\u4ee5\u5bf9\u9ed8\u8ba4\u53c2\u6570\u6267\u884c\u76f8\u540c\u7684\u64cd\u4f5c\u3002\ndef func_2(a: int, b: int = ...) -&gt; int: ...\n</code></pre> <p>Note</p> <p>\u7701\u7565\u53f7<code>...</code>\u5728<code>\u53ef\u8c03\u7528\u7c7b\u578b</code>\u548c<code>\u5143\u7ec4\u7c7b\u578b</code>\u4e2d\u4e5f\u6709\u4e0d\u540c\u7684\u542b\u4e49\u3002</p> <p>Stub files are written in normal Python syntax, but generally leaving out runtime logic like variable initializers, function bodies, and default arguments.</p> <p>If it is not possible to completely leave out some piece of runtime logic, the recommended convention is to replace or elide them with ellipsis expressions (<code>...</code>). Each ellipsis below is literally written in the stub file as three dots:</p> <pre><code># Variables with annotations do not need to be assigned a value.\n# So by convention, we omit them in the stub file.\nx: int\n\n# Function bodies cannot be completely removed. By convention,\n# we replace them with `...` instead of the `pass` statement.\ndef func_1(code: str) -&gt; int: ...\n\n# We can do the same with default arguments.\ndef func_2(a: int, b: int = ...) -&gt; int: ...\n</code></pre> <p>Note</p> <p>The ellipsis <code>...</code> is also used with a different meaning in <code>callable types</code> and <code>tuple types</code>.</p>"},{"location":"mypy/stub_files/#\u5728\u8fd0\u884c\u65f6\u4f7f\u7528\u5b58\u6839\u6587\u4ef6\u8bed\u6cd5","title":"\u5728\u8fd0\u884c\u65f6\u4f7f\u7528\u5b58\u6839\u6587\u4ef6\u8bed\u6cd5","text":"<p>Using stub file syntax at runtime</p> \u4e2d\u6587\u82f1\u6587 <p>\u60a8\u6709\u65f6\u53ef\u80fd\u8fd8\u9700\u8981\u7701\u7565\u5e38\u89c4 Python \u4ee3\u7801\u4e2d\u7684\u5b9e\u9645\u903b\u8f91\u2014\u2014\u4f8b\u5982\uff0c\u5728\u4f7f\u7528 <code>\u51fd\u6570\u91cd\u8f7d</code> \u6216 <code>\u81ea\u5b9a\u4e49\u534f\u8bae</code>\u7f16\u5199\u65b9\u6cd5\u65f6.</p> <p>\u63a8\u8350\u7684\u98ce\u683c\u662f\u4f7f\u7528\u7701\u7565\u53f7\u6765\u6267\u884c\u6b64\u64cd\u4f5c\uff0c\u5c31\u50cf\u5728\u5b58\u6839\u6587\u4ef6\u4e2d\u4e00\u6837\u3002 \u5728\u4ee3\u7801\u7684\u7528\u6237\u53ef\u80fd\u610f\u5916\u8c03\u7528\u6ca1\u6709\u5b9e\u9645\u529f\u80fd\u7684\u51fd\u6570\u7684\u60c5\u51b5\u4e0b\uff0c\u629b\u51fa <code>NotImplementedError</code> \u4e5f\u88ab\u8ba4\u4e3a\u662f\u53ef\u4ee5\u63a5\u53d7\u7684\u3002 \u903b\u8f91\u3002</p> <p>\u53ea\u8981\u51fd\u6570\u4f53\u4e0d\u5305\u542b\u8fd0\u884c\u65f6\u903b\u8f91\uff0c\u60a8\u4e5f\u53ef\u4ee5\u7701\u7565\u9ed8\u8ba4\u53c2\u6570\uff1a\u51fd\u6570\u4f53\u4ec5\u5305\u542b\u5355\u4e2a\u7701\u7565\u53f7\u3001pass \u8bed\u53e5\u6216<code>raise NotImplementedError()</code>\u3002 \u51fd\u6570\u4f53\u5305\u542b\u6587\u6863\u5b57\u7b26\u4e32\u4e5f\u662f\u53ef\u4ee5\u63a5\u53d7\u7684\u3002 \u4f8b\u5982\uff1a</p> <pre><code>from typing_extensions import Protocol\n\nclass Resource(Protocol):\n    def ok_1(self, foo: list[str] = ...) -&gt; None: ...\n\n    def ok_2(self, foo: list[str] = ...) -&gt; None:\n        raise NotImplementedError()\n\n    def ok_3(self, foo: list[str] = ...) -&gt; None:\n        \"\"\"Some docstring\"\"\"\n        pass\n\n    # Error: Incompatible default for argument \"foo\" (default has type \"ellipsis\", argument has type \"list[str]\")\n    def not_ok(self, foo: list[str] = ...) -&gt; None:\n        print(foo)\n</code></pre> <p>You may also occasionally need to elide actual logic in regular Python code -- for example, when writing methods in <code>overload variants</code> or <code>custom protocols</code>.</p> <p>The recommended style is to use ellipses to do so, just like in stub files. It is also considered stylistically acceptable to throw a <code>NotImplementedError</code> in cases where the user of the code may accidentally call functions with no actual logic.</p> <p>You can also elide default arguments as long as the function body also contains no runtime logic: the function body only contains a single ellipsis, the pass statement, or a <code>raise NotImplementedError()</code>. It is also acceptable for the function body to contain a docstring. For example:</p> <pre><code>from typing_extensions import Protocol\n\nclass Resource(Protocol):\n    def ok_1(self, foo: list[str] = ...) -&gt; None: ...\n\n    def ok_2(self, foo: list[str] = ...) -&gt; None:\n        raise NotImplementedError()\n\n    def ok_3(self, foo: list[str] = ...) -&gt; None:\n        \"\"\"Some docstring\"\"\"\n        pass\n\n    # Error: Incompatible default for argument \"foo\" (default has\n    # type \"ellipsis\", argument has type \"list[str]\")\n    def not_ok(self, foo: list[str] = ...) -&gt; None:\n        print(foo)\n</code></pre>"},{"location":"mypy/type_inference_type_annotations/","title":"\u7c7b\u578b\u63a8\u65ad\u548c\u7c7b\u578b\u6ce8\u89e3","text":"<p>Type inference and type annotations</p>"},{"location":"mypy/type_inference_type_annotations/#\u7c7b\u578b\u63a8\u65ad","title":"\u7c7b\u578b\u63a8\u65ad","text":"\u4e2d\u6587\u82f1\u6587 <p>\u5bf9\u4e8e\u5927\u591a\u6570\u53d8\u91cf\uff0c\u5982\u679c\u60a8\u6ca1\u6709\u663e\u5f0f\u6307\u5b9a\u5176\u7c7b\u578b\uff0cmypy \u5c06\u6839\u636e\u6700\u521d\u5206\u914d\u7ed9\u53d8\u91cf\u7684\u7c7b\u578b\u63a8\u65ad\u51fa\u6b63\u786e\u7684\u7c7b\u578b\u3002</p> <pre><code># \u5c3d\u7ba1\u6ca1\u6709\u6ce8\u91ca\uff0cMypy \u4ecd\u4f1a\u63a8\u65ad\u8fd9\u4e9b\u53d8\u91cf\u7684\u7c7b\u578b\ni = 1\nreveal_type(i)  # \u663e\u793a\u7684\u7c7b\u578b\u662f \u201cbuiltins.int\u201d\nl = [1, 2]\nreveal_type(l)  # \u663e\u793a\u7c7b\u578b\u4e3a \u201cbuiltins.list[builtins.int]\u201d\n</code></pre> <p>\u7b14\u8bb0</p> <p>\u8bf7\u6ce8\u610f\uff0cmypy \u4e0d\u4f1a\u5728\u52a8\u6001\u7c7b\u578b\u51fd\u6570\uff08\u6ca1\u6709\u51fd\u6570\u7c7b\u578b\u6ce8\u91ca\u7684\u51fd\u6570\uff09\u4e2d\u4f7f\u7528\u7c7b\u578b\u63a8\u65ad - \u5728\u6b64\u7c7b\u51fd\u6570\u4e2d\uff0c\u6bcf\u4e2a\u5c40\u90e8\u53d8\u91cf\u7c7b\u578b\u9ed8\u8ba4\u4e3a\u201cAny\u201d\u3002 \u6709\u5173\u66f4\u591a\u8be6\u7ec6\u4fe1\u606f\uff0c\u8bf7\u53c2\u9605<code>dynamic-typing</code>\u3002</p> <pre><code>def untyped_function():\n    i = 1\n    reveal_type(i) # \u63ed\u793a\u7684\u7c7b\u578b\u662f \"Any\"\n                   # \u201creveal_type\u201d\u5728\u672a\u7ecf\u68c0\u67e5\u7684\u51fd\u6570\u4e2d\u59cb\u7ec8\u8f93\u51fa\u201cAny\u201d\n</code></pre> <p>Type inference</p> <p>For most variables, if you do not explicitly specify its type, mypy will infer the correct type based on what is initially assigned to the variable.</p> <pre><code># Mypy will infer the type of these variables, despite no annotations\ni = 1\nreveal_type(i)  # Revealed type is \"builtins.int\"\nl = [1, 2]\nreveal_type(l)  # Revealed type is \"builtins.list[builtins.int]\"\n</code></pre> <p>Note</p> <p>Note that mypy will not use type inference in dynamically typed functions (those without a function type annotation) \u2014 every local variable type defaults to <code>Any</code> in such functions. For more details, see <code>dynamic-typing</code>.</p> <pre><code>def untyped_function():\n    i = 1\n    reveal_type(i) # Revealed type is \"Any\"\n                   # 'reveal_type' always outputs 'Any' in unchecked functions\n</code></pre>"},{"location":"mypy/type_inference_type_annotations/#\u53d8\u91cf\u7684\u663e\u5f0f\u7c7b\u578b","title":"\u53d8\u91cf\u7684\u663e\u5f0f\u7c7b\u578b","text":"\u4e2d\u6587\u82f1\u6587 <p>\u60a8\u53ef\u4ee5\u4f7f\u7528\u53d8\u91cf\u7c7b\u578b\u6ce8\u91ca\u8986\u76d6\u53d8\u91cf\u7684\u63a8\u65ad\u7c7b\u578b\uff1a</p> <pre><code>from typing import Union\n\nx: Union[int, str] = 1\n</code></pre> <p>\u5982\u679c\u6ca1\u6709\u7c7b\u578b\u6ce8\u91ca\uff0c\u201cx\u201d \u7684\u7c7b\u578b\u5c06\u53ea\u662f \u201cint\u201d \u3002 \u6211\u4eec\u4f7f\u7528\u6ce8\u91ca\u7ed9\u5b83\u4e00\u4e2a\u66f4\u901a\u7528\u7684\u7c7b\u578b \u201cUnion[int, str]\u201d\uff08\u8be5\u7c7b\u578b\u610f\u5473\u7740\u8be5\u503c\u53ef\u4ee5\u662f \u201cint\u201d \u6216 \u201cstr\u201d \uff09\u3002</p> <p>\u8003\u8651\u8fd9\u4e2a\u95ee\u9898\u7684\u6700\u4f73\u65b9\u6cd5\u662f\u7c7b\u578b\u6ce8\u91ca\u8bbe\u7f6e\u53d8\u91cf\u7684\u7c7b\u578b\uff0c\u800c\u4e0d\u662f\u8868\u8fbe\u5f0f\u7684\u7c7b\u578b\u3002 \u4f8b\u5982\uff0cmypy \u4f1a\u62b1\u6028\u4ee5\u4e0b\u4ee3\u7801\uff1a</p> <pre><code>x: Union[int, str] = 1.1  # error: \u8d4b\u503c\u4e2d\u7684\u7c7b\u578b\u4e0d\u517c\u5bb9\uff08\u8868\u8fbe\u5f0f\u7684\u7c7b\u578b\u4e3a\u201cfloat\u201d\uff0c\u53d8\u91cf\u7684\u7c7b\u578b\u4e3a\u201cUnion[int, str]\u201d\uff09\n</code></pre> <p>Note</p> <p>\u8981\u663e\u5f0f\u8986\u76d6\u8868\u8fbe\u5f0f\u7684\u7c7b\u578b\uff0c\u60a8\u53ef\u4ee5\u4f7f\u7528 [<code>cast(\\&lt;type\\&gt;, \\&lt;expression\\&gt;) &lt;typing.cast&gt;</code>](https://docs.python.org/3/library/typing.html#typing.cast\uff09\u3002 \u6709\u5173\u8be6\u7ec6\u4fe1\u606f\uff0c\u8bf7\u53c2\u9605 <code>casts</code>\u3002</p> <p>\u8bf7\u6ce8\u610f\uff0c\u60a8\u53ef\u4ee5\u663e\u5f0f\u58f0\u660e\u53d8\u91cf\u7684\u7c7b\u578b\u800c\u4e0d\u4e3a\u5176\u6307\u5b9a\u521d\u59cb\u503c\uff1a</p> <pre><code>    # \u6211\u4eec\u53ea\u89e3\u538b\u4e24\u4e2a\u503c\uff0c\u56e0\u6b64 mypy \u6ca1\u6709\u53f3\u4fa7\u503c\u6765\u63a8\u65ad\u201ccs\u201d\u7684\u7c7b\u578b\uff1a\n    a, b, *cs = 1, 2  # error: \u9700\u8981\u201ccs\u201d\u7684\u7c7b\u578b\u6ce8\u89e3\n\n    rs: list[int]  # no assignment!\n    p, q, *rs = 1, 2  # OK\n</code></pre> <p>Explicit types for variables</p> <p>You can override the inferred type of a variable by using a variable type annotation:</p> <pre><code>from typing import Union\n\nx: Union[int, str] = 1\n</code></pre> <p>Without the type annotation, the type of <code>x</code> would be just <code>int</code>. We use an annotation to give it a more general type <code>Union[int, str]</code> (this type means that the value can be either an <code>int</code> or a <code>str</code>).</p> <p>The best way to think about this is that the type annotation sets the type of the variable, not the type of the expression. For instance, mypy will complain about the following code:</p> <pre><code>x: Union[int, str] = 1.1  # error: Incompatible types in assignment\n                          # (expression has type \"float\", variable has type \"Union[int, str]\")\n</code></pre> <p>Note</p> <p>To explicitly override the type of an expression you can use <code>cast(\\&lt;type\\&gt;, \\&lt;expression\\&gt;) &lt;typing.cast&gt;</code>. See <code>casts</code> for details.</p> <p>Note that you can explicitly declare the type of a variable without giving it an initial value:</p> <pre><code>    # We only unpack two values, so there's no right-hand side value\n    # for mypy to infer the type of \"cs\" from:\n    a, b, *cs = 1, 2  # error: Need type annotation for \"cs\"\n\n    rs: list[int]  # no assignment!\n    p, q, *rs = 1, 2  # OK\n</code></pre>"},{"location":"mypy/type_inference_type_annotations/#\u96c6\u5408\u7684\u663e\u5f0f\u7c7b\u578b","title":"\u96c6\u5408\u7684\u663e\u5f0f\u7c7b\u578b","text":"\u4e2d\u6587\u82f1\u6587 <p>\u7c7b\u578b\u68c0\u67e5\u5668\u4e0d\u80fd\u603b\u662f\u63a8\u65ad\u51fa\u5217\u8868\u6216\u5b57\u5178\u7684\u7c7b\u578b\u3002 \u5f53\u521b\u5efa\u7a7a\u5217\u8868\u6216\u5b57\u5178\u5e76\u5c06\u5176\u5206\u914d\u7ed9\u6ca1\u6709\u663e\u5f0f\u53d8\u91cf\u7c7b\u578b\u7684\u65b0\u53d8\u91cf\u65f6\uff0c\u901a\u5e38\u4f1a\u51fa\u73b0\u8fd9\u79cd\u60c5\u51b5\u3002 \u8fd9\u662f\u4e00\u4e2a\u793a\u4f8b\uff0c\u5176\u4e2d mypy \u5728\u6ca1\u6709\u5e2e\u52a9\u7684\u60c5\u51b5\u4e0b\u65e0\u6cd5\u63a8\u65ad\u7c7b\u578b\uff1a</p> <pre><code>l = []  # Error: \u9700\u8981\u53d8\u91cf \"l\" \u7684\u7c7b\u578b\u6ce8\u89e3\n</code></pre> <p>\u5728\u8fd9\u4e9b\u60c5\u51b5\u4e0b\uff0c\u60a8\u53ef\u4ee5\u4f7f\u7528\u7c7b\u578b\u6ce8\u91ca\u663e\u5f0f\u6307\u5b9a\u7c7b\u578b\uff1a</p> <pre><code>l: list[int] = []       # \u521b\u5efa int \u7684\u7a7a\u5217\u8868\nd: dict[str, int] = {}  # \u521b\u5efa\u7a7a\u5b57\u5178\uff08str -&gt; int\uff09\n</code></pre> <p>Note</p> <p>\u5728\u5185\u7f6e\u96c6\u5408\u4e0a\u4f7f\u7528\u7c7b\u578b\u53c2\u6570\uff08\u4f8b\u5982\u201clist[int]\u201d\uff09\uff0c\u4f8b\u5982 <code>list</code>\u3001<code>dict</code>\u3001<code>tuple</code> \u548c <code>set</code> \u4ec5\u9002\u7528\u4e8e Python 3.9 \u53ca\u66f4\u9ad8\u7248\u672c\u3002 \u5bf9\u4e8ePython 3.8\u53ca\u66f4\u65e9\u7248\u672c\uff0c\u60a8\u5fc5\u987b\u4f7f\u7528<code>List</code>\uff08\u4f8b\u5982<code>List[int]</code>\uff09\uff0c<code>Dict</code>\uff0c\u7b49\u7b49\u3002</p> <p>Explicit types for collections</p> <p>The type checker cannot always infer the type of a list or a dictionary. This often arises when creating an empty list or dictionary and assigning it to a new variable that doesn't have an explicit variable type. Here is an example where mypy can't infer the type without some help:</p> <pre><code>l = []  # Error: Need type annotation for \"l\"\n</code></pre> <p>In these cases you can give the type explicitly using a type annotation:</p> <pre><code>l: list[int] = []       # Create empty list of int\nd: dict[str, int] = {}  # Create empty dictionary (str -&gt; int)\n</code></pre> <p>Note</p> <p>Using type arguments (e.g. <code>list[int]</code>) on builtin collections like <code>list</code>,  <code>dict</code>, <code>tuple</code>, and  <code>set</code> only works in Python 3.9 and later. For Python 3.8 and earlier, you must use <code>List</code> (e.g. <code>List[int]</code>), <code>Dict</code>, and so on.</p>"},{"location":"mypy/type_inference_type_annotations/#\u5bb9\u5668\u7c7b\u578b\u7684\u517c\u5bb9\u6027","title":"\u5bb9\u5668\u7c7b\u578b\u7684\u517c\u5bb9\u6027","text":"\u4e2d\u6587\u82f1\u6587 <p>\u5feb\u901f\u8bf4\u660e\uff1a\u5bb9\u5668\u7c7b\u578b\u6709\u65f6\u53ef\u80fd\u4e0d\u76f4\u89c2\u3002 \u6211\u4eec\u5c06\u5728<code>variance</code>\u4e2d\u8be6\u7ec6\u8ba8\u8bba\u8fd9\u4e00\u70b9\u3002 \u4f8b\u5982\uff0c\u4ee5\u4e0b\u7a0b\u5e8f\u4f1a\u751f\u6210 mypy \u9519\u8bef\uff0c\u56e0\u4e3a mypy \u5c06 <code>list[int]</code> \u89c6\u4e3a\u4e0e <code>list[object]</code> \u4e0d\u517c\u5bb9\uff1a</p> <pre><code>def f(l: list[object], k: list[int]) -&gt; None:\n    l = k  # error: \u8d4b\u503c\u4e2d\u7684\u7c7b\u578b\u4e0d\u517c\u5bb9\n</code></pre> <p>\u4e0d\u5141\u8bb8\u4e0a\u8ff0\u8d4b\u503c\u7684\u539f\u56e0\u662f\u5141\u8bb8\u8d4b\u503c\u53ef\u80fd\u4f1a\u5bfc\u81f4\u975e int \u503c\u5b58\u50a8\u5728 \u201cint\u201d \u5217\u8868\u4e2d\uff1a</p> <pre><code>def f(l: list[object], k: list[int]) -&gt; None:\n   l = k\n   l.append('x')\n   print(k[-1])  # \u54ce\u54df; list[int] \u4e2d\u7684\u5b57\u7b26\u4e32\n</code></pre> <p>\u5176\u4ed6\u5bb9\u5668\u7c7b\u578b\uff0c\u5982 <code>dict</code> \u548c <code>set</code> /stdtypes.html#set) \u7684\u884c\u4e3a\u7c7b\u4f3c\u3002</p> <p>\u60a8\u4ecd\u7136\u53ef\u4ee5\u8fd0\u884c\u4e0a\u9762\u7684\u7a0b\u5e8f\uff1b \u5b83\u6253\u5370 \u201cx\u201d\u3002 \u8fd9\u8bf4\u660e\u9759\u6001\u7c7b\u578b\u4e0d\u4f1a\u5f71\u54cd\u7a0b\u5e8f\u7684\u8fd0\u884c\u65f6\u884c\u4e3a\u3002 \u60a8\u53ef\u4ee5\u8fd0\u884c\u7c7b\u578b\u68c0\u67e5\u5931\u8d25\u7684\u7a0b\u5e8f\uff0c\u8fd9\u5728\u6267\u884c\u5927\u578b\u91cd\u6784\u65f6\u901a\u5e38\u975e\u5e38\u65b9\u4fbf\u3002 \u56e0\u6b64\uff0c\u60a8\u59cb\u7ec8\u53ef\u4ee5\u201c\u89e3\u51b3\u201d\u7c7b\u578b\u7cfb\u7edf\uff0c\u5e76\u4e14\u5b83\u5e76\u4e0d\u4f1a\u771f\u6b63\u9650\u5236\u60a8\u5728\u7a0b\u5e8f\u4e2d\u53ef\u4ee5\u6267\u884c\u7684\u64cd\u4f5c\u3002</p> <p>Compatibility of container types</p> <p>A quick note: container types can sometimes be unintuitive. We'll discuss this more in <code>variance</code>. For example, the following program generates a mypy error, because mypy treats <code>list[int]</code> as incompatible with <code>list[object]</code>:</p> <pre><code>def f(l: list[object], k: list[int]) -&gt; None:\n    l = k  # error: Incompatible types in assignment\n</code></pre> <p>The reason why the above assignment is disallowed is that allowing the assignment could result in non-int values stored in a list of <code>int</code>:</p> <pre><code>def f(l: list[object], k: list[int]) -&gt; None:\n   l = k\n   l.append('x')\n   print(k[-1])  # Ouch; a string in list[int]\n</code></pre> <p>Other container types like <code>dict</code> and <code>set</code> behave similarly.</p> <p>You can still run the above program; it prints <code>x</code>. This illustrates the fact that static types do not affect the runtime behavior of programs. You can run programs with type check failures, which is often very handy when performing a large refactoring. Thus you can always 'work around' the type system, and it doesn't really limit what you can do in your program.</p>"},{"location":"mypy/type_inference_type_annotations/#\u7c7b\u578b\u63a8\u65ad\u4e2d\u7684\u4e0a\u4e0b\u6587","title":"\u7c7b\u578b\u63a8\u65ad\u4e2d\u7684\u4e0a\u4e0b\u6587","text":"\u4e2d\u6587\u82f1\u6587 <p>\u7c7b\u578b\u63a8\u65ad\u662f\u53cc\u5411\u7684\u5e76\u8003\u8651\u4e0a\u4e0b\u6587\u3002</p> <p>Mypy \u5728\u63a8\u65ad\u53f3\u4fa7\u8868\u8fbe\u5f0f\u7684\u7c7b\u578b\u65f6\u4f1a\u8003\u8651\u8d4b\u503c\u5de6\u4fa7\u53d8\u91cf\u7684\u7c7b\u578b\u3002 \u4f8b\u5982\uff0c\u4ee5\u4e0b\u5185\u5bb9\u5c06\u7c7b\u578b\u68c0\u67e5\uff1a</p> <pre><code>def f(l: list[object]) -&gt; None:\n    l = [1, 2]  # \u63a8\u65ad [1, 2] \u7684\u7c7b\u578b\u4e3a list[object]\uff0c\u800c\u4e0d\u662f list[int]\n</code></pre> <p>\u503c\u8868\u8fbe\u5f0f \u201c[1, 2]\u201d \u4f7f\u7528\u9644\u52a0\u4e0a\u4e0b\u6587\u8fdb\u884c\u7c7b\u578b\u68c0\u67e5\uff0c\u8be5\u4e0a\u4e0b\u6587\u88ab\u5206\u914d\u7ed9 \u201clist[object]\u201d \u7c7b\u578b\u7684\u53d8\u91cf\u3002 \u8fd9\u7528\u4e8e\u5c06\u8868\u8fbe\u5f0f\u7684\u7c7b\u578b\u63a8\u65ad\u4e3a \u201clist[object]\u201d \u3002</p> <p>\u58f0\u660e\u7684\u53c2\u6570\u7c7b\u578b\u4e5f\u7528\u4e8e\u7c7b\u578b\u4e0a\u4e0b\u6587\u3002 \u5728\u8fd9\u4e2a\u7a0b\u5e8f\u4e2d\uff0cmypy \u77e5\u9053\u7a7a\u5217\u8868 <code>[]</code> \u5e94\u8be5\u5177\u6709\u7c7b\u578b <code>list[int]</code>\uff0c\u57fa\u4e8e <code>foo</code> \u4e2d <code>arg</code> \u7684\u58f0\u660e\u7c7b\u578b\uff1a</p> <pre><code>def foo(arg: list[int]) -&gt; None:\n    print('Items:', ''.join(str(a) for a in arg))\n\nfoo([])  # OK\n</code></pre> <p>\u4f46\u662f\uff0c\u4e0a\u4e0b\u6587\u4ec5\u5728\u5355\u4e2a\u8bed\u53e5\u4e2d\u8d77\u4f5c\u7528\u3002 \u8fd9\u91cc mypy \u9700\u8981\u7a7a\u5217\u8868\u7684\u6ce8\u91ca\uff0c\u56e0\u4e3a\u4e0a\u4e0b\u6587\u4ec5\u5728\u4ee5\u4e0b\u8bed\u53e5\u4e2d\u53ef\u7528\uff1a</p> <pre><code>def foo(arg: list[int]) -&gt; None:\n    print('Items:', ', '.join(arg))\n\na = []  # Error: \u9700\u8981\u201ca\u201d\u7684\u7c7b\u578b\u6ce8\u89e3\nfoo(a)\n</code></pre> <p>\u901a\u8fc7\u6dfb\u52a0\u7c7b\u578b\u6ce8\u89e3\u53ef\u4ee5\u8f7b\u677e\u89e3\u51b3\u8be5\u95ee\u9898\uff1a</p> <pre><code>...\na: list[int] = []  # OK\nfoo(a)\n</code></pre> <p>Context in type inference</p> <p>Type inference is bidirectional and takes context into account.</p> <p>Mypy will take into account the type of the variable on the left-hand side of an assignment when inferring the type of the expression on the right-hand side. For example, the following will type check:</p> <pre><code>def f(l: list[object]) -&gt; None:\n    l = [1, 2]  # Infer type list[object] for [1, 2], not list[int]\n</code></pre> <p>The value expression <code>[1, 2]</code> is type checked with the additional context that it is being assigned to a variable of type <code>list[object]</code>. This is used to infer the type of the expression as <code>list[object]</code>.</p> <p>Declared argument types are also used for type context. In this program mypy knows that the empty list <code>[]</code> should have type <code>list[int]</code> based on the declared type of <code>arg</code> in <code>foo</code>:</p> <pre><code>def foo(arg: list[int]) -&gt; None:\n    print('Items:', ''.join(str(a) for a in arg))\n\nfoo([])  # OK\n</code></pre> <p>However, context only works within a single statement. Here mypy requires an annotation for the empty list, since the context would only be available in the following statement:</p> <pre><code>def foo(arg: list[int]) -&gt; None:\n    print('Items:', ', '.join(arg))\n\na = []  # Error: Need type annotation for \"a\"\nfoo(a)\n</code></pre> <p>Working around the issue is easy by adding a type annotation:</p> <pre><code>...\na: list[int] = []  # OK\nfoo(a)\n</code></pre>"},{"location":"mypy/type_inference_type_annotations/#\u6d88\u9664\u7c7b\u578b\u9519\u8bef","title":"\u6d88\u9664\u7c7b\u578b\u9519\u8bef","text":"\u4e2d\u6587\u82f1\u6587 <p>\u60a8\u53ef\u80fd\u5e0c\u671b\u7981\u7528\u7279\u5b9a\u884c\u6216\u4ee3\u7801\u5e93\u4e2d\u7279\u5b9a\u6587\u4ef6\u5185\u7684\u7c7b\u578b\u68c0\u67e5\u3002 \u4e3a\u6b64\uff0c\u60a8\u53ef\u4ee5\u4f7f\u7528 <code># type:ignore</code> \u6ce8\u91ca\u3002</p> <p>\u4f8b\u5982\uff0c\u5728\u6700\u65b0\u66f4\u65b0\u4e2d\uff0c\u60a8\u4f7f\u7528\u7684 Web \u6846\u67b6\u73b0\u5728\u53ef\u4ee5\u5c06\u6574\u6570\u53c2\u6570\u4f20\u9012\u7ed9\u201crun()\u201d\uff0c\u4ece\u800c\u5728\u8be5\u7aef\u53e3\u4e0a\u7684\u672c\u5730\u4e3b\u673a\u4e0a\u542f\u52a8\u5b83\u3002 \u5c31\u50cf\u8fd9\u6837\uff1a</p> <pre><code># \u542f\u52a8\u5e94\u7528\u7a0b\u5e8f http://localhost:8000\napp.run(8000)\n</code></pre> <p>\u7136\u800c\uff0c\u5f00\u53d1\u4eba\u5458\u5fd8\u8bb0\u66f4\u65b0\u201crun\u201d\u7684\u7c7b\u578b\u6ce8\u91ca\uff0c\u56e0\u6b64 mypy \u4ecd\u7136\u8ba4\u4e3a\u201crun\u201d\u53ea\u9700\u8981\u201cstr\u201d\u7c7b\u578b\u3002 \u8fd9\u4f1a\u7ed9\u4f60\u5e26\u6765\u4ee5\u4e0b\u9519\u8bef\uff1a</p> <pre><code>error: Argument 1 to \"run\" of \"A\" has incompatible type \"int\"; expected \"str\"\n</code></pre> <p>\u5982\u679c\u60a8\u81ea\u5df1\u65e0\u6cd5\u76f4\u63a5\u4fee\u590d Web \u6846\u67b6\uff0c\u60a8\u53ef\u4ee5\u901a\u8fc7\u6dfb\u52a0 <code># type:ignore</code> \u6765\u4e34\u65f6\u7981\u7528\u8be5\u884c\u7684\u7c7b\u578b\u68c0\u67e5\uff1a</p> <pre><code># \u542f\u52a8\u5e94\u7528\u7a0b\u5e8f http://localhost:8000\napp.run(8000)  # type: ignore\n</code></pre> <p>\u8fd9\u5c06\u6291\u5236\u8be5\u7279\u5b9a\u884c\u4e0a\u51fa\u73b0\u7684\u4efb\u4f55 mypy \u9519\u8bef\u3002</p> <p>\u60a8\u53ef\u80fd\u5e94\u8be5\u5728<code># type:ignore</code>\u6ce8\u91ca\u4e0a\u6dfb\u52a0\u66f4\u591a\u4fe1\u606f\uff0c\u4ee5\u89e3\u91ca\u4e3a\u4ec0\u4e48\u9996\u5148\u6dfb\u52a0\u5ffd\u7565\u3002 \u8fd9\u53ef\u80fd\u662f\u6307\u5411\u8d1f\u8d23\u7c7b\u578b\u5b58\u6839\u7684\u5b58\u50a8\u5e93\u4e2d\u7684\u95ee\u9898\u7684\u94fe\u63a5\uff0c\u4e5f\u53ef\u80fd\u662f\u5bf9\u8be5\u9519\u8bef\u7684\u7b80\u77ed\u89e3\u91ca\u3002 \u4e3a\u6b64\uff0c\u8bf7\u4f7f\u7528\u4ee5\u4e0b\u683c\u5f0f\uff1a</p> <pre><code># \u542f\u52a8\u5e94\u7528\u7a0b\u5e8f http://localhost:8000\napp.run(8000)  # type: ignore  # `run()` in v2.0 accepts an `int`, as a port\n</code></pre> <p>Silencing type errors</p> <p>You might want to disable type checking on specific lines, or within specific files in your codebase. To do that, you can use a <code># type: ignore</code> comment.</p> <p>For example, say in its latest update, the web framework you use can now take an integer argument to <code>run()</code>, which starts it on localhost on that port. Like so:</p> <pre><code># Starting app on http://localhost:8000\napp.run(8000)\n</code></pre> <p>However, the devs forgot to update their type annotations for <code>run</code>, so mypy still thinks <code>run</code> only expects <code>str</code> types. This would give you the following error:</p> <pre><code>error: Argument 1 to \"run\" of \"A\" has incompatible type \"int\"; expected \"str\"\n</code></pre> <p>If you cannot directly fix the web framework yourself, you can temporarily disable type checking on that line, by adding a <code># type: ignore</code>:</p> <pre><code># Starting app on http://localhost:8000\napp.run(8000)  # type: ignore\n</code></pre> <p>This will suppress any mypy errors that would have raised on that specific line.</p> <p>You should probably add some more information on the <code># type: ignore</code> comment, to explain why the ignore was added in the first place. This could be a link to an issue on the repository responsible for the type stubs, or it could be a short explanation of the bug. To do that, use this format:</p> <pre><code># Starting app on http://localhost:8000\napp.run(8000)  # type: ignore  # `run()` in v2.0 accepts an `int`, as a port\n</code></pre>"},{"location":"mypy/type_inference_type_annotations/#\u8f93\u5165\u5ffd\u7565\u9519\u8bef\u4ee3\u7801","title":"\u8f93\u5165\u5ffd\u7565\u9519\u8bef\u4ee3\u7801","text":"\u4e2d\u6587\u82f1\u6587 <p>\u9ed8\u8ba4\u60c5\u51b5\u4e0b\uff0cmypy \u663e\u793a\u6bcf\u4e2a\u9519\u8bef\u7684\u9519\u8bef\u4ee3\u7801\uff1a</p> <pre><code>error: \"str\" has no attribute \"trim\"  [attr-defined]\n</code></pre> <p>\u53ef\u4ee5\u5728\u5ffd\u7565\u6ce8\u91ca\u4e2d\u6dfb\u52a0\u7279\u5b9a\u7684\u9519\u8bef\u4ee3\u7801\uff08\u4f8b\u5982 <code># type:ignore[attr-defined]</code>\uff09\u4ee5\u9610\u660e\u6b63\u5728\u6c89\u9ed8\u7684\u5185\u5bb9\u3002 \u60a8\u53ef\u4ee5\u5728\u6b64\u5904`\u627e\u5230\u6709\u5173\u9519\u8bef\u4ee3\u7801\u7684\u66f4\u591a\u4fe1\u606f\u3002</p> <p>Type ignore error codes</p> <p>By default, mypy displays an error code for each error:</p> <pre><code>error: \"str\" has no attribute \"trim\"  [attr-defined]\n</code></pre> <p>It is possible to add a specific error-code in your ignore comment (e.g. <code># type: ignore[attr-defined]</code>) to clarify what's being silenced. You can find more information about error codes <code>here</code>.</p>"},{"location":"mypy/type_inference_type_annotations/#\u5176\u4ed6\u6d88\u9664\u9519\u8bef\u7684\u65b9\u6cd5","title":"\u5176\u4ed6\u6d88\u9664\u9519\u8bef\u7684\u65b9\u6cd5","text":"\u4e2d\u6587\u82f1\u6587 <p>\u60a8\u53ef\u4ee5\u901a\u8fc7\u4f7f\u7528\u201cAny\u201d\u52a8\u6001\u952e\u5165\u7279\u5b9a\u53d8\u91cf\u6765\u8ba9 mypy \u6d88\u9664\u6709\u5173\u7279\u5b9a\u53d8\u91cf\u7684\u9519\u8bef\u3002 \u6709\u5173\u66f4\u591a\u4fe1\u606f\uff0c\u8bf7\u53c2\u9605<code>dynamic-typing</code>\u3002</p> <pre><code>from typing import Any\n\ndef f(x: Any, y: str) -&gt; None:\n    x = 'hello'\n    x += 1  # OK\n</code></pre> <p>\u60a8\u53ef\u4ee5\u901a\u8fc7\u5728\u6587\u4ef6\u9876\u90e8\u6dfb\u52a0 <code># mypy:ignore-errors</code> \u6765\u5ffd\u7565\u6587\u4ef6\u4e2d\u7684\u6240\u6709 mypy \u9519\u8bef\uff1a</p> <pre><code># mypy: ignore-errors\n# \u8fd9\u662f\u4e00\u4e2a\u6d4b\u8bd5\u6587\u4ef6\uff0c\u8df3\u8fc7\u5176\u4e2d\u7684\u7c7b\u578b\u68c0\u67e5\u3002\nimport unittest\n...\n</code></pre> <p>\u60a8\u8fd8\u53ef\u4ee5\u5728 <code>mypy \u914d\u7f6e\u6587\u4ef6</code> \u4e2d\u6307\u5b9a\u6bcf\u4e2a\u6a21\u5757\u7684\u914d\u7f6e\u9009\u9879\u3002 \u4f8b\u5982\uff1a</p> <pre><code># Don't report errors in the 'package_to_fix_later' package\n[mypy-package_to_fix_later.*]\nignore_errors = True\n\n# Disable specific error codes in the 'tests' package\n# Also don't require type annotations\n[mypy-tests.*]\ndisable_error_code = var-annotated, has-type\nallow_untyped_defs = True\n\n# Silence import errors from the 'library_missing_types' package\n[mypy-library_missing_types.*]\nignore_missing_imports = True\n</code></pre> <p>Finally, adding a <code>@typing.no_type_check</code> decorator to a class, method or function causes mypy to avoid type checking that class, method or function and to treat it as not having any type annotations.</p> <pre><code>@typing.no_type_check\ndef foo() -&gt; str:\n   return 12345  # No error!\n</code></pre> <p>Other ways to silence errors</p> <p>You can get mypy to silence errors about a specific variable by dynamically typing it with <code>Any</code>. See <code>dynamic-typing</code> for more information.</p> <pre><code>from typing import Any\n\ndef f(x: Any, y: str) -&gt; None:\n    x = 'hello'\n    x += 1  # OK\n</code></pre> <p>You can ignore all mypy errors in a file by adding a <code># mypy: ignore-errors</code> at the top of the file:</p> <pre><code># mypy: ignore-errors\n# This is a test file, skipping type checking in it.\nimport unittest\n...\n</code></pre> <p>You can also specify per-module configuration options in your <code>The mypy configuration file</code>. For example:</p> <pre><code># Don't report errors in the 'package_to_fix_later' package\n[mypy-package_to_fix_later.*]\nignore_errors = True\n\n# Disable specific error codes in the 'tests' package\n# Also don't require type annotations\n[mypy-tests.*]\ndisable_error_code = var-annotated, has-type\nallow_untyped_defs = True\n\n# Silence import errors from the 'library_missing_types' package\n[mypy-library_missing_types.*]\nignore_missing_imports = True\n</code></pre> <p>Finally, adding a <code>@typing.no_type_check</code> decorator to a class, method or function causes mypy to avoid type checking that class, method or function and to treat it as not having any type annotations.</p> <pre><code>@typing.no_type_check\ndef foo() -&gt; str:\n   return 12345  # No error!\n</code></pre>"},{"location":"mypy/type_narrowing/","title":"\u7c7b\u578b\u6536\u7f29","text":"\u4e2d\u6587\u82f1\u6587 <p>\u672c\u8282\u4e13\u95e8\u4ecb\u7ecd mypy \u652f\u6301\u7684\u51e0\u79cd\u7c7b\u578b\u6536\u7f29\u6280\u672f\u3002</p> <p>\u7c7b\u578b\u7f29\u5c0f\u662f\u6307\u60a8\u8ba9\u7c7b\u578b\u68c0\u67e5\u5668\u76f8\u4fe1\u66f4\u5e7f\u6cdb\u7684\u7c7b\u578b\u5b9e\u9645\u4e0a\u66f4\u5177\u4f53\uff0c\u4f8b\u5982\uff0c<code>Shape</code> \u7c7b\u578b\u7684\u5bf9\u8c61\u5b9e\u9645\u4e0a\u662f\u66f4\u7a84\u7684 <code>Square</code> \u7c7b\u578b\u3002</p> <p>Type narrowing</p> <p>This section is dedicated to  several type narrowing techniques which are supported by mypy.</p> <p>Type narrowing is when you convince a type checker that a broader type is actually more specific, for instance, that an object of type <code>Shape</code> is actually of the narrower type <code>Square</code>.</p>"},{"location":"mypy/type_narrowing/#\u7c7b\u578b\u6536\u7f29\u8868\u8fbe\u5f0f","title":"\u7c7b\u578b\u6536\u7f29\u8868\u8fbe\u5f0f","text":"<p>Type narrowing expressions</p> \u4e2d\u6587\u82f1\u6587 <p>\u7f29\u5c0f\u7c7b\u578b\u8303\u56f4\u7684\u6700\u7b80\u5355\u65b9\u6cd5\u662f\u4f7f\u7528\u53d7\u652f\u6301\u7684\u8868\u8fbe\u5f0f\u4e4b\u4e00\uff1a</p> <ul> <li><code>isinstance</code> \u5c31\u50cf <code>isinstance(obj, float)</code> \u4f1a\u5c06 <code>obj</code> \u7f29\u5c0f\u4e3a <code>float</code> \u7c7b\u578b</li> <li><code>issubclass</code> \u5c31\u50cf <code>issubclass(cls, MyClass)</code> \u4f1a\u5c06<code>cls</code> \u7f29\u5c0f\u4e3a <code>Type[MyClass]</code> \u7c7b\u578b</li> <li><code>type</code> \u5c31\u50cf <code>type(obj) is int</code> \u4f1a\u5c06 <code>obj</code> \u7f29\u5c0f\u4e3a <code>int</code> \u7c7b\u578b</li> <li><code>callable</code> \u5c31\u50cf <code>callable(obj)</code> \u5c06\u5bf9\u8c61\u7f29\u5c0f\u4e3a\u53ef\u8c03\u7528\u7c7b\u578b</li> </ul> <p>\u7c7b\u578b\u7f29\u5c0f\u662f\u6839\u636e\u4e0a\u4e0b\u6587\u800c\u5b9a\u7684\u3002 \u4f8b\u5982\uff0c\u6839\u636e\u6761\u4ef6\uff0cmypy \u5c06\u4ec5\u5728<code>if</code>\u5206\u652f\u5185\u7f29\u5c0f\u8868\u8fbe\u5f0f\uff1a</p> <pre><code>def function(arg: object):\n    if isinstance(arg, int):\n        # \u7c7b\u578b\u4ec5\u5728\u201cif\u201d\u5206\u652f\u5185\u7f29\u5c0f\n        reveal_type(arg)  # \u663e\u793a\u7c7b\u578b\uff1a\u201cbuiltins.int\u201d\n    elif isinstance(arg, str) or isinstance(arg, bool):\n        # \u5728\u8fd9\u4e2a elif \u5206\u652f\u4e2d\uff0c\u7c7b\u578b\u4ee5\u4e0d\u540c\u7684\u65b9\u5f0f\u7f29\u5c0f\uff1a\n        reveal_type(arg)  # \u663e\u793a\u7c7b\u578b\uff1a\u201cbuiltins.str |builtins.bool\u201d\n\n        # \u540e\u7eed\u7684\u7f29\u5c0f\u64cd\u4f5c\u5c06\u8fdb\u4e00\u6b65\u7f29\u5c0f\u7c7b\u578b\n        if isinstance(arg, bool):\n            reveal_type(arg)  # \u663e\u793a\u7c7b\u578b: \"builtins.bool\"\n\n    # \u56de\u5230\u201cif\u201d\u8bed\u53e5\u4e4b\u5916\uff0c\u7c7b\u578b\u6ca1\u6709\u7f29\u5c0f\uff1a\n    reveal_type(arg)  # \u663e\u793a\u7c7b\u578b: \"builtins.object\"\n</code></pre> <p>Mypy \u7406\u89e3<code>return</code>\u6216\u5f02\u5e38\u5f15\u53d1\u5bf9\u5bf9\u8c61\u7c7b\u578b\u7684\u5f71\u54cd\uff1a</p> <pre><code>def function(arg: int | str):\n    if isinstance(arg, int):\n        return\n\n    # \u6b64\u65f6 `arg` \u4e0d\u80fd\u662f `int`\uff1a\n    reveal_type(arg)  # \u663e\u793a\u7c7b\u578b: \"builtins.str\"\n</code></pre> <p>\u6211\u4eec\u8fd8\u53ef\u4ee5\u4f7f\u7528<code>assert</code>\u6765\u7f29\u5c0f\u76f8\u540c\u4e0a\u4e0b\u6587\u4e2d\u7684\u7c7b\u578b\uff1a</p> <pre><code>def function(arg: Any):\n    assert isinstance(arg, int)\n    reveal_type(arg)  # \u663e\u793a\u7c7b\u578b: \"builtins.int\"\n</code></pre> <p>Note</p> <p>\u4f7f\u7528 <code>--warn-unreachable</code> \u5c06\u7c7b\u578b\u7f29\u5c0f\u5230\u67d0\u4e9b\u4e0d\u53ef\u80fd\u7684\u72b6\u6001\u5c06\u88ab\u89c6\u4e3a\u9519\u8bef\u3002</p> <pre><code>def function(arg: int):\n    # error: \u201cint\u201d\u548c\u201cstr\u201d\u7684\u5b50\u7c7b\u4e0d\u80fd\u5b58\u5728\uff1a\n    # \u4f1a\u6709\u4e0d\u517c\u5bb9\u7684\u65b9\u6cd5\u7b7e\u540d\n    assert isinstance(arg, str)\n\n    # error: \u58f0\u660e\u65e0\u6cd5\u8bbf\u95ee(Statement is unreachable)\n    print(\"so mypy concludes the assert will always trigger\")\n</code></pre> <p>\u5982\u679c\u6ca1\u6709<code>--warn-unreachable</code>\uff0cmypy \u5c06\u4e0d\u4f1a\u68c0\u67e5\u5b83\u8ba4\u4e3a\u65e0\u6cd5\u8bbf\u95ee\u7684\u4ee3\u7801\u3002 \u6709\u5173\u66f4\u591a\u4fe1\u606f\uff0c\u8bf7\u53c2\u9605<code>\u65e0\u6cd5\u8bbf\u95ee\u7684\u4ee3\u7801</code>\u3002</p> <pre><code>x: int = 1\nassert isinstance(x, str)\nreveal_type(x)  # \u663e\u793a\u7c7b\u578b \"builtins.int\"\nprint(x + '!')  # \u4f7f\u7528`mypy`\u8fdb\u884c\u7c7b\u578b\u68c0\u67e5\uff0c\u4f46\u5728\u8fd0\u884c\u65f6\u5931\u8d25\u3002\n</code></pre> <p>The simplest way to narrow a type is to use one of the supported expressions:</p> <ul> <li><code>isinstance</code> like in <code>isinstance(obj, float)</code> will narrow <code>obj</code> to have <code>float</code> type</li> <li><code>issubclass</code> like in <code>issubclass(cls, MyClass)</code> will narrow <code>cls</code> to be <code>Type[MyClass]</code></li> <li><code>type</code> like in <code>type(obj) is int</code> will narrow <code>obj</code> to have <code>int</code> type</li> <li><code>callable</code> like in <code>callable(obj)</code> will narrow object to callable type</li> </ul> <p>Type narrowing is contextual. For example, based on the condition, mypy will narrow an expression only within an <code>if</code> branch:</p> <pre><code>def function(arg: object):\n    if isinstance(arg, int):\n        # Type is narrowed within the ``if`` branch only\n        reveal_type(arg)  # Revealed type: \"builtins.int\"\n    elif isinstance(arg, str) or isinstance(arg, bool):\n        # Type is narrowed differently within this ``elif`` branch:\n        reveal_type(arg)  # Revealed type: \"builtins.str | builtins.bool\"\n\n        # Subsequent narrowing operations will narrow the type further\n        if isinstance(arg, bool):\n            reveal_type(arg)  # Revealed type: \"builtins.bool\"\n\n    # Back outside of the ``if`` statement, the type isn't narrowed:\n    reveal_type(arg)  # Revealed type: \"builtins.object\"\n</code></pre> <p>Mypy understands the implications <code>return</code> or exception raising can have for what type an object could be:</p> <pre><code>def function(arg: int | str):\n    if isinstance(arg, int):\n        return\n\n    # `arg` can't be `int` at this point:\n    reveal_type(arg)  # Revealed type: \"builtins.str\"\n</code></pre> <p>We can also use <code>assert</code> to narrow types in the same context:</p> <pre><code>def function(arg: Any):\n    assert isinstance(arg, int)\n    reveal_type(arg)  # Revealed type: \"builtins.int\"\n</code></pre> <p>Note</p> <p>With <code>--warn-unreachable</code> narrowing types to some impossible state will be treated as an error.</p> <pre><code>def function(arg: int):\n    # error: Subclass of \"int\" and \"str\" cannot exist:\n    # would have incompatible method signatures\n    assert isinstance(arg, str)\n\n    # error: Statement is unreachable\n    print(\"so mypy concludes the assert will always trigger\")\n</code></pre> <p>Without <code>--warn-unreachable</code> mypy will simply not check code it deems to be unreachable. See <code>unreachable code</code> for more information.</p> <pre><code>x: int = 1\nassert isinstance(x, str)\nreveal_type(x)  # Revealed type is \"builtins.int\"\nprint(x + '!')  # Typechecks with `mypy`, but fails in runtime.\n</code></pre>"},{"location":"mypy/type_narrowing/#\u662f\u5426\u4e3a\u5b50\u7c7b","title":"\u662f\u5426\u4e3a\u5b50\u7c7b","text":"<p>issubclass</p> \u4e2d\u6587\u82f1\u6587 <p>Mypy \u8fd8\u53ef\u4ee5\u4f7f\u7528 <code>issubclass</code> \u5728\u5904\u7406\u7c7b\u578b\u548c\u5143\u7c7b\u65f6\u8fdb\u884c\u66f4\u597d\u7684\u7c7b\u578b\u63a8\u65ad\uff1a</p> <pre><code>class MyCalcMeta(type):\n    @classmethod\n    def calc(cls) -&gt; int:\n        ...\n\ndef f(o: object) -&gt; None:\n    t = type(o)  # \u6211\u4eec\u5fc5\u987b\u5728\u8fd9\u91cc\u4f7f\u7528\u4e00\u4e2a\u53d8\u91cf\n    reveal_type(t)  # \u63ed\u793a\u7684\u7c7b\u578b\u662f \"builtins.type\"\n\n    if issubclass(t, MyCalcMeta):  # `issubclass(type(o), MyCalcMeta)` \u4e0d\u8d77\u4f5c\u7528\n        reveal_type(t)  # \u63ed\u793a\u7684\u7c7b\u578b\u662f \"Type[MyCalcMeta]\"\n        t.calc()  # Okay\n</code></pre> <p>Mypy can also use <code>issubclass</code> for better type inference when working with types and metaclasses:</p> <pre><code>class MyCalcMeta(type):\n    @classmethod\n    def calc(cls) -&gt; int:\n        ...\n\ndef f(o: object) -&gt; None:\n    t = type(o)  # We must use a variable here\n    reveal_type(t)  # Revealed type is \"builtins.type\"\n\n    if issubclass(t, MyCalcMeta):  # `issubclass(type(o), MyCalcMeta)` won't work\n        reveal_type(t)  # Revealed type is \"Type[MyCalcMeta]\"\n        t.calc()  # Okay\n</code></pre>"},{"location":"mypy/type_narrowing/#\u662f\u5426\u53ef\u8c03\u7528","title":"\u662f\u5426\u53ef\u8c03\u7528","text":"<p>callable</p> \u4e2d\u6587\u82f1\u6587 <p>Mypy \u5728\u7c7b\u578b\u68c0\u67e5\u671f\u95f4\u77e5\u9053\u54ea\u4e9b\u7c7b\u578b\u53ef\u8c03\u7528\uff0c\u54ea\u4e9b\u7c7b\u578b\u4e0d\u53ef\u8c03\u7528\u3002 \u6240\u4ee5\uff0c\u6211\u4eec\u77e5\u9053 <code>callable()</code> \u4f1a\u8fd4\u56de\u4ec0\u4e48\u3002 \u4f8b\u5982\uff1a</p> <pre><code>from typing import Callable\n\nx: Callable[[], int]\n\nif callable(x):\n    reveal_type(x)  # N: \u63ed\u793a\u7684\u7c7b\u578b\u662f \"def () -&gt; builtins.int\"\nelse:\n    ...  # \u6c38\u8fdc\u4e0d\u4f1a\u88ab\u6267\u884c\u5e76\u4e14\u4f1a\u5f15\u53d1\u9519\u8bef `--warn-unreachable`\n</code></pre> <p><code>callable</code> \u51fd\u6570\u751a\u81f3\u53ef\u4ee5\u5c06 <code>Union</code> \u7c7b\u578b\u62c6\u5206\u4e3a\u53ef\u8c03\u7528\u90e8\u5206\u548c\u4e0d\u53ef\u8c03\u7528\u90e8\u5206\uff1a</p> <pre><code>from typing import Callable, Union\n\nx: Union[int, Callable[[], int]]\n\nif callable(x):\n    reveal_type(x)  # N: \u63ed\u793a\u7684\u7c7b\u578b\u662f \"def () -&gt; builtins.int\"\nelse:\n    reveal_type(x)  # N: \u63ed\u793a\u7684\u7c7b\u578b\u662f \"builtins.int\"\n</code></pre> <p>Mypy knows what types are callable and which ones are not during type checking. So, we know what <code>callable()</code> will return. For example:</p> <pre><code>from typing import Callable\n\nx: Callable[[], int]\n\nif callable(x):\n    reveal_type(x)  # N: Revealed type is \"def () -&gt; builtins.int\"\nelse:\n    ...  # Will never be executed and will raise error with `--warn-unreachable`\n</code></pre> <p><code>callable</code> function can even split <code>Union</code> type for callable and non-callable parts:</p> <pre><code>from typing import Callable, Union\n\nx: Union[int, Callable[[], int]]\n\nif callable(x):\n    reveal_type(x)  # N: Revealed type is \"def () -&gt; builtins.int\"\nelse:\n    reveal_type(x)  # N: Revealed type is \"builtins.int\"\n</code></pre>"},{"location":"mypy/type_narrowing/#\u8f6c\u6362","title":"\u8f6c\u6362","text":"<p>Casts</p> \u4e2d\u6587\u82f1\u6587 <p>Mypy \u652f\u6301\u7c7b\u578b\u8f6c\u6362\uff0c\u901a\u5e38\u7528\u4e8e\u5c06\u9759\u6001\u7c7b\u578b\u503c\u5f3a\u5236\u8f6c\u6362\u4e3a\u5b50\u7c7b\u578b\u3002 \u7136\u800c\uff0c\u4e0e Java \u6216 C# \u7b49\u8bed\u8a00\u4e0d\u540c\uff0cmypy \u5f3a\u5236\u8f6c\u6362\u4ec5\u7528\u4f5c\u7c7b\u578b\u68c0\u67e5\u5668\u7684\u63d0\u793a\uff0c\u5e76\u4e14\u4e0d\u6267\u884c\u8fd0\u884c\u65f6\u7c7b\u578b\u68c0\u67e5\u3002 \u4f7f\u7528\u51fd\u6570 <code>typing.cast</code> \u6267\u884c\u8f6c\u6362\uff1a</p> <pre><code>from typing import cast\n\no: object = [1]\nx = cast(list[int], o)  # OK\ny = cast(list[str], o)  # OK (\u5f3a\u5236\u8f6c\u6362\u4e0d\u6267\u884c\u5b9e\u9645\u7684\u8fd0\u884c\u65f6\u68c0\u67e5)\n</code></pre> <p>\u4e3a\u4e86\u652f\u6301\u4e0a\u8ff0\u7c7b\u578b\u8f6c\u6362\u7684\u8fd0\u884c\u65f6\u68c0\u67e5\uff0c\u6211\u4eec\u5fc5\u987b\u68c0\u67e5\u6240\u6709\u5217\u8868\u9879\u7684\u7c7b\u578b\uff0c\u8fd9\u5bf9\u4e8e\u5927\u578b\u5217\u8868\u6765\u8bf4\u6548\u7387\u975e\u5e38\u4f4e\u3002 \u5f3a\u5236\u8f6c\u6362\u7528\u4e8e\u6d88\u9664\u865a\u5047\u7684\u7c7b\u578b\u68c0\u67e5\u5668\u8b66\u544a\uff0c\u5e76\u5728\u7c7b\u578b\u68c0\u67e5\u5668\u65e0\u6cd5\u5b8c\u5168\u7406\u89e3\u6b63\u5728\u53d1\u751f\u7684\u60c5\u51b5\u65f6\u4e3a\u7c7b\u578b\u68c0\u67e5\u5668\u63d0\u4f9b\u4e00\u4e9b\u5e2e\u52a9\u3002</p> <p>Note</p> <p>You can use an assertion if you want to perform an actual runtime check:</p> <pre><code>def foo(o: object) -&gt; None:\n    print(o + 5)  # Error: can't add 'object' and 'int'\n    assert isinstance(o, int)\n    print(o + 5)  # OK: type of 'o' is 'int' here\n</code></pre> <p>\u6b63\u5982\u524d\u9762\u6240\u89e3\u91ca\u7684\uff0c\u60a8\u4e0d\u9700\u8981\u5bf9<code>Any</code>\u7c7b\u578b\u7684\u8868\u8fbe\u5f0f\u8fdb\u884c\u5f3a\u5236\u8f6c\u6362\uff0c\u6216\u8005\u5728\u5206\u914d\u7ed9\u7c7b\u578b\u4e3a<code>Any</code>\u7684\u53d8\u91cf\u65f6\u8fdb\u884c\u5f3a\u5236\u8f6c\u6362\u3002 \u60a8\u8fd8\u53ef\u4ee5\u4f7f\u7528<code>Any</code>\u4f5c\u4e3a\u8f6c\u6362\u76ee\u6807\u7c7b\u578b\u2014\u2014\u8fd9\u5141\u8bb8\u60a8\u5bf9\u7ed3\u679c\u6267\u884c\u4efb\u4f55\u64cd\u4f5c\u3002 \u4f8b\u5982\uff1a</p> <pre><code>from typing import cast, Any\n\nx = 1\nx.whatever()  # Type check error\ny = cast(Any, x)\ny.whatever()  # Type check OK (runtime error)\n</code></pre> <p>Mypy supports type casts that are usually used to coerce a statically typed value to a subtype. Unlike languages such as Java or C#, however, mypy casts are only used as hints for the type checker, and they don't perform a runtime type check. Use the function <code>typing.cast</code> to perform a cast:</p> <pre><code>from typing import cast\n\no: object = [1]\nx = cast(list[int], o)  # OK\ny = cast(list[str], o)  # OK (cast performs no actual runtime check)\n</code></pre> <p>To support runtime checking of casts such as the above, we'd have to check the types of all list items, which would be very inefficient for large lists. Casts are used to silence spurious type checker warnings and give the type checker a little help when it can't quite understand what is going on.</p> <p>Note</p> <p>You can use an assertion if you want to perform an actual runtime check:</p> <pre><code>def foo(o: object) -&gt; None:\n    print(o + 5)  # Error: can't add 'object' and 'int'\n    assert isinstance(o, int)\n    print(o + 5)  # OK: type of 'o' is 'int' here\n</code></pre> <p>You don't need a cast for expressions with type <code>Any</code>, or when assigning to a variable with type <code>Any</code>, as was explained earlier. You can also use <code>Any</code> as the cast target type -- this lets you perform any operations on the result. For example:</p> <pre><code>from typing import cast, Any\n\nx = 1\nx.whatever()  # Type check error\ny = cast(Any, x)\ny.whatever()  # Type check OK (runtime error)\n</code></pre>"},{"location":"mypy/type_narrowing/#\u7528\u6237\u5b9a\u4e49\u7684\u7c7b\u578b\u4fdd\u62a4","title":"\u7528\u6237\u5b9a\u4e49\u7684\u7c7b\u578b\u4fdd\u62a4","text":"<p>User-Defined Type Guards</p> \u4e2d\u6587\u82f1\u6587 <p>Mypy \u652f\u6301\u7528\u6237\u5b9a\u4e49\u7684\u7c7b\u578b\u9632\u62a4 (<code>PEP 647</code>).</p> <p>\u7c7b\u578b\u4fdd\u62a4\u662f\u7a0b\u5e8f\u5f71\u54cd\u7c7b\u578b\u68c0\u67e5\u5668\u57fa\u4e8e\u8fd0\u884c\u65f6\u68c0\u67e5\u6240\u91c7\u7528\u7684\u6761\u4ef6\u7c7b\u578b\u7f29\u5c0f\u7684\u4e00\u79cd\u65b9\u5f0f\u3002</p> <p>\u57fa\u672c\u4e0a\uff0c<code>TypeGuard</code>\u662f<code>bool</code>\u7c7b\u578b\u7684\u201c\u667a\u80fd(smart)\u201d\u522b\u540d\u3002 \u8ba9\u6211\u4eec\u770b\u4e00\u4e0b\u5e38\u89c4\u7684<code>bool</code>\u793a\u4f8b\uff1a</p> <pre><code>def is_str_list(val: list[object]) -&gt; bool:\n\"\"\"\u5224\u65ad\u5217\u8868\u4e2d\u7684\u6240\u6709\u5bf9\u8c61\u662f\u5426\u90fd\u662f\u5b57\u7b26\u4e32\"\"\"\nreturn all(isinstance(x, str) for x in val)\n\ndef func1(val: list[object]) -&gt; None:\n    if is_str_list(val):\n        reveal_type(val)  # Reveals list[object]\n        print(\" \".join(val)) # Error: incompatible type\n</code></pre> <p>\u4e0e<code>TypeGuard</code>\u76f8\u540c\u7684\u793a\u4f8b:</p> <pre><code>from typing import TypeGuard  # use `typing_extensions` for Python 3.9 and below\n\ndef is_str_list(val: list[object]) -&gt; TypeGuard[list[str]]:\n    \"\"\"\u5224\u65ad\u5217\u8868\u4e2d\u7684\u6240\u6709\u5bf9\u8c61\u662f\u5426\u90fd\u662f\u5b57\u7b26\u4e32\"\"\"\n    return all(isinstance(x, str) for x in val)\n\ndef func1(val: list[object]) -&gt; None:\n    if is_str_list(val):\n        reveal_type(val)  # list[str]\n        print(\" \".join(val)) # ok\n</code></pre> <p>\u5b83\u662f\u5982\u4f55\u5de5\u4f5c\u7684\uff1f <code>TypeGuard</code> \u5c06\u7b2c\u4e00\u4e2a\u51fd\u6570\u53c2\u6570 (<code>val</code>) \u7f29\u5c0f\u4e3a\u6307\u5b9a\u4e3a\u7b2c\u4e00\u4e2a\u7c7b\u578b\u53c2\u6570 (<code>list[str]</code>) \u7684\u7c7b\u578b\u3002</p> <p>Note</p> <p>\u7f29\u5c0f\u8303\u56f4\u4e0d\u4e25\u683c(not strict)\u3002 \u4f8b\u5982\uff0c\u60a8\u53ef\u4ee5\u5c06<code>str</code>\u7f29\u5c0f\u4e3a<code>int</code>\uff1a</p> <pre><code>def f(value: str) -&gt; TypeGuard[int]:\n    return True\n</code></pre> <p>\u6ce8\u610f: \u7531\u4e8e\u4e0d\u5f3a\u5236\u6267\u884c\u4e25\u683c\u7684\u7f29\u5c0f\uff0c\u56e0\u6b64\u5f88\u5bb9\u6613\u7834\u574f\u7c7b\u578b\u5b89\u5168\u3002</p> <p>\u7136\u800c\uff0c\u575a\u5b9a\u6216\u4e0d\u77e5\u60c5\u7684\u5f00\u53d1\u4eba\u5458\u53ef\u4ee5\u901a\u8fc7\u591a\u79cd\u65b9\u5f0f\u7834\u574f\u7c7b\u578b\u5b89\u5168\u2014\u2014\u6700\u5e38\u89c1\u7684\u662f\u4f7f\u7528\u5f3a\u5236\u8f6c\u6362\u6216 Any\u3002 \u5982\u679c Python \u5f00\u53d1\u4eba\u5458\u82b1\u65f6\u95f4\u5728\u4ee3\u7801\u4e2d\u5b66\u4e60\u548c\u5b9e\u73b0\u7528\u6237\u5b9a\u4e49\u7684\u7c7b\u578b\u4fdd\u62a4\uff0c\u5219\u53ef\u4ee5\u5b89\u5168\u5730\u5047\u8bbe\u4ed6\u4eec\u5bf9\u7c7b\u578b\u5b89\u5168\u611f\u5174\u8da3\uff0c\u5e76\u4e14\u4e0d\u4f1a\u4ee5\u7834\u574f\u7c7b\u578b\u5b89\u5168\u6216\u7834\u574f\u7c7b\u578b\u5b89\u5168\u7684\u65b9\u5f0f\u7f16\u5199\u7c7b\u578b\u4fdd\u62a4\u51fd\u6570\u3002 \u4ea7\u751f\u65e0\u610f\u4e49\u7684\u7ed3\u679c\u3002</p> <p>Mypy supports User-Defined Type Guards (<code>PEP 647</code>).</p> <p>A type guard is a way for programs to influence conditional type narrowing employed by a type checker based on runtime checks.</p> <p>Basically, a <code>TypeGuard</code> is a \"smart\" alias for a <code>bool</code> type. Let's have a look at the regular <code>bool</code> example:</p> <pre><code>def is_str_list(val: list[object]) -&gt; bool:\n\"\"\"Determines whether all objects in the list are strings\"\"\"\nreturn all(isinstance(x, str) for x in val)\n\ndef func1(val: list[object]) -&gt; None:\n    if is_str_list(val):\n        reveal_type(val)  # Reveals list[object]\n        print(\" \".join(val)) # Error: incompatible type\n</code></pre> <p>The same example with <code>TypeGuard</code>:</p> <pre><code>from typing import TypeGuard  # use `typing_extensions` for Python 3.9 and below\n\ndef is_str_list(val: list[object]) -&gt; TypeGuard[list[str]]:\n    \"\"\"Determines whether all objects in the list are strings\"\"\"\n    return all(isinstance(x, str) for x in val)\n\ndef func1(val: list[object]) -&gt; None:\n    if is_str_list(val):\n        reveal_type(val)  # list[str]\n        print(\" \".join(val)) # ok\n</code></pre> <p>How does it work? <code>TypeGuard</code> narrows the first function argument (<code>val</code>) to the type specified as the first type parameter (<code>list[str]</code>).</p> <p>Note</p> <p>Narrowing is not strict. For example, you can narrow <code>str</code> to <code>int</code>:</p> <pre><code>def f(value: str) -&gt; TypeGuard[int]:\n    return True\n</code></pre> <p>Note: since strict narrowing is not enforced, it's easy to break type safety.</p> <p>However, there are many ways a determined or uninformed developer can subvert type safety -- most commonly by using cast or Any. If a Python developer takes the time to learn about and implement user-defined type guards within their code, it is safe to assume that they are interested in type safety and will not write their type guard functions in a way that will undermine type safety or produce nonsensical results.</p>"},{"location":"mypy/type_narrowing/#\u6cdb\u578b\u7c7b\u578b\u4fdd\u62a4","title":"\u6cdb\u578b\u7c7b\u578b\u4fdd\u62a4","text":"\u4e2d\u6587\u82f1\u6587 <p><code>TypeGuard</code> \u4e5f\u53ef\u4ee5\u4f7f\u7528\u6cdb\u578b\u7c7b\u578b\uff1a</p> <pre><code>from typing import TypeVar\nfrom typing import TypeGuard  # use `typing_extensions` for `python&lt;3.10`\n\n_T = TypeVar(\"_T\")\n\ndef is_two_element_tuple(val: tuple[_T, ...]) -&gt; TypeGuard[tuple[_T, _T]]:\n    return len(val) == 2\n\ndef func(names: tuple[str, ...]):\n    if is_two_element_tuple(names):\n        reveal_type(names)  # tuple[str, str]\n    else:\n        reveal_type(names)  # tuple[str, ...]\n</code></pre> <p><code>TypeGuard</code> can also work with generic types:</p> <pre><code>from typing import TypeVar\nfrom typing import TypeGuard  # use `typing_extensions` for `python&lt;3.10`\n\n_T = TypeVar(\"_T\")\n\ndef is_two_element_tuple(val: tuple[_T, ...]) -&gt; TypeGuard[tuple[_T, _T]]:\n    return len(val) == 2\n\ndef func(names: tuple[str, ...]):\n    if is_two_element_tuple(names):\n        reveal_type(names)  # tuple[str, str]\n    else:\n        reveal_type(names)  # tuple[str, ...]\n</code></pre>"},{"location":"mypy/type_narrowing/#\u5e26\u53c2\u6570\u7684\u7c7b\u578b\u4fdd\u62a4","title":"\u5e26\u53c2\u6570\u7684\u7c7b\u578b\u4fdd\u62a4","text":"<p>Typeguards with parameters</p> \u4e2d\u6587\u82f1\u6587 <p>\u7c7b\u578b\u4fdd\u62a4\u51fd\u6570\u53ef\u4ee5\u63a5\u53d7\u989d\u5916\u7684\u53c2\u6570\uff1a</p> <pre><code>from typing import Type, TypeVar\nfrom typing import TypeGuard  # use `typing_extensions` for `python&lt;3.10`\n\n_T = TypeVar(\"_T\")\n\ndef is_set_of(val: set[Any], type: Type[_T]) -&gt; TypeGuard[set[_T]]:\n    return all(isinstance(x, type) for x in val)\n\nitems: set[Any]\nif is_set_of(items, str):\n    reveal_type(items)  # set[str]\n</code></pre> <p>Type guard functions can accept extra arguments:</p> <pre><code>from typing import Type, TypeVar\nfrom typing import TypeGuard  # use `typing_extensions` for `python&lt;3.10`\n\n_T = TypeVar(\"_T\")\n\ndef is_set_of(val: set[Any], type: Type[_T]) -&gt; TypeGuard[set[_T]]:\n    return all(isinstance(x, type) for x in val)\n\nitems: set[Any]\nif is_set_of(items, str):\n    reveal_type(items)  # set[str]\n</code></pre>"},{"location":"mypy/type_narrowing/#\u4f5c\u4e3a\u65b9\u6cd5\u7684\u7c7b\u578b\u4fdd\u62a4","title":"\u4f5c\u4e3a\u65b9\u6cd5\u7684\u7c7b\u578b\u4fdd\u62a4","text":"<p>TypeGuards as methods</p> \u4e2d\u6587\u82f1\u6587 <p>\u65b9\u6cd5\u4e5f\u53ef\u4ee5\u5145\u5f53<code>TypeGuard</code>\uff1a</p> <pre><code>class StrValidator:\n    def is_valid(self, instance: object) -&gt; TypeGuard[str]:\n        return isinstance(instance, str)\n\ndef func(to_validate: object) -&gt; None:\n    if StrValidator().is_valid(to_validate):\n        reveal_type(to_validate)  # Revealed type is \"builtins.str\"\n</code></pre> <p>Note</p> <p>\u8bf7\u6ce8\u610f\uff0c<code>TypeGuard</code>\u4e0d\u4f1a\u7f29\u5c0f<code>self</code>\u7684\u7c7b\u578b \u6216<code>cls</code>\u9690\u5f0f\u53c2\u6570\u3002</p> <p>\u5982\u679c\u9700\u8981\u7f29\u5c0f<code>self</code>\u6216<code>cls</code>\uff0c\u5219\u53ef\u4ee5\u5c06\u8be5\u503c\u4f5c\u4e3a\u663e\u5f0f\u53c2\u6570\u4f20\u9012\u7ed9\u7c7b\u578b\u4fdd\u62a4\u51fd\u6570\uff1a</p> <pre><code>class Parent:\n    def method(self) -&gt; None:\n        reveal_type(self)  # Revealed type is \"Parent\"\n        if is_child(self):\n            reveal_type(self)  # Revealed type is \"Child\"\n\nclass Child(Parent):\n    ...\n\ndef is_child(instance: Parent) -&gt; TypeGuard[Child]:\n    return isinstance(instance, Child)\n</code></pre> <p>A method can also serve as the <code>TypeGuard</code>:</p> <pre><code>class StrValidator:\n    def is_valid(self, instance: object) -&gt; TypeGuard[str]:\n        return isinstance(instance, str)\n\ndef func(to_validate: object) -&gt; None:\n    if StrValidator().is_valid(to_validate):\n        reveal_type(to_validate)  # Revealed type is \"builtins.str\"\n</code></pre> <p>Note</p> <p>Note, that <code>TypeGuard</code> does not narrow types of <code>self</code> or <code>cls</code> implicit arguments.</p> <p>If narrowing of <code>self</code> or <code>cls</code> is required, the value can be passed as an explicit argument to a type guard function:</p> <pre><code>class Parent:\n    def method(self) -&gt; None:\n        reveal_type(self)  # Revealed type is \"Parent\"\n        if is_child(self):\n            reveal_type(self)  # Revealed type is \"Child\"\n\nclass Child(Parent):\n    ...\n\ndef is_child(instance: Parent) -&gt; TypeGuard[Child]:\n    return isinstance(instance, Child)\n</code></pre>"},{"location":"mypy/type_narrowing/#\u4f5c\u4e3a\u7c7b\u578b\u4fdd\u62a4\u7684\u8d4b\u503c\u8868\u8fbe\u5f0f","title":"\u4f5c\u4e3a\u7c7b\u578b\u4fdd\u62a4\u7684\u8d4b\u503c\u8868\u8fbe\u5f0f","text":"<p>Assignment expressions as TypeGuards</p> \u4e2d\u6587\u82f1\u6587 <p>\u6709\u65f6\u60a8\u53ef\u80fd\u9700\u8981\u521b\u5efa\u4e00\u4e2a\u65b0\u53d8\u91cf\u5e76\u540c\u65f6\u5c06\u5176\u7f29\u5c0f\u4e3a\u67d0\u79cd\u7279\u5b9a\u7c7b\u578b\u3002 \u8fd9\u53ef\u4ee5\u901a\u8fc7\u5c06<code>TypeGuard</code>\u4e0e := \u8fd0\u7b97\u7b26 \u4e00\u8d77\u4f7f\u7528\u6765\u5b9e\u73b0\u3002</p> <pre><code>from typing import TypeGuard  # use `typing_extensions` for `python&lt;3.10`\n\ndef is_float(a: object) -&gt; TypeGuard[float]:\n    return isinstance(a, float)\n\ndef main(a: object) -&gt; None:\n    if is_float(x := a):\n        reveal_type(x)  # N: Revealed type is 'builtins.float'\n        reveal_type(a)  # N: Revealed type is 'builtins.object'\n    reveal_type(x)  # N: Revealed type is 'builtins.object'\n    reveal_type(a)  # N: Revealed type is 'builtins.object'\n</code></pre> <p>\u8fd9\u91cc\u4f1a\u53d1\u751f\u4ec0\u4e48\uff1f</p> <ol> <li>\u6211\u4eec\u521b\u5efa\u4e00\u4e2a\u65b0\u53d8\u91cf<code>x</code>\u5e76\u4e3a\u5176\u5206\u914d\u503c<code>a</code></li> <li>\u6211\u4eec\u5728<code>x</code>\u4e0a\u8fd0\u884c<code>is_float()</code>\u7c7b\u578b\u4fdd\u62a4</li> <li>\u5b83\u5c06<code>x</code>\u7f29\u5c0f\u4e3a<code>if</code>\u4e0a\u4e0b\u6587\u4e2d\u7684<code>float</code>\uff0c\u5e76\u4e14\u4e0d\u6d89\u53ca<code>a</code></li> </ol> <p>Note</p> <p>\u8fd9\u540c\u6837\u9002\u7528\u4e8e<code>isinstance(x := a, float)</code>\u3002</p> <p>Sometimes you might need to create a new variable and narrow it to some specific type at the same time. This can be achieved by using <code>TypeGuard</code> together with := operator.</p> <pre><code>from typing import TypeGuard  # use `typing_extensions` for `python&lt;3.10`\n\ndef is_float(a: object) -&gt; TypeGuard[float]:\n    return isinstance(a, float)\n\ndef main(a: object) -&gt; None:\n    if is_float(x := a):\n        reveal_type(x)  # N: Revealed type is 'builtins.float'\n        reveal_type(a)  # N: Revealed type is 'builtins.object'\n    reveal_type(x)  # N: Revealed type is 'builtins.object'\n    reveal_type(a)  # N: Revealed type is 'builtins.object'\n</code></pre> <p>What happens here?</p> <ol> <li>We create a new variable <code>x</code> and assign a value of <code>a</code> to it</li> <li>We run <code>is_float()</code> type guard on <code>x</code></li> <li>It narrows <code>x</code> to be <code>float</code> in the <code>if</code> context and does not touch <code>a</code></li> </ol> <p>Note</p> <p>The same will work with <code>isinstance(x := a, float)</code> as well.</p>"},{"location":"mypy/typeddict/","title":"\u7c7b\u578b\u5b57\u5178","text":"<p>TypedDict</p> \u4e2d\u6587\u82f1\u6587 <p>Python \u7a0b\u5e8f\u7ecf\u5e38\u4f7f\u7528\u5e26\u6709\u5b57\u7b26\u4e32\u952e\u7684\u5b57\u5178\u6765\u8868\u793a\u5bf9\u8c61\u3002 <code>TypedDict</code> \u5141\u8bb8\u60a8\u4e3a\u8868\u793a\u5177\u6709\u56fa\u5b9a\u6a21\u5f0f\u7684\u5bf9\u8c61\u7684\u5b57\u5178\u63d0\u4f9b\u7cbe\u786e\u7684\u7c7b\u578b\uff0c\u4f8b\u5982 <code>{'id': 1, 'items': ['x']}</code>\u3002</p> <p>\u8fd9\u662f\u4e00\u4e2a\u5178\u578b\u7684\u4f8b\u5b50\uff1a</p> <pre><code>movie = {'name': 'Blade Runner', 'year': 1982}\n</code></pre> <p>\u4ec5\u9700\u8981\u4e00\u7ec4\u56fa\u5b9a\u7684\u5b57\u7b26\u4e32\u952e\uff08\u4e0a\u9762\u7684\u201cname\u201d\u548c\u201cyear\u201d\uff09\uff0c\u5e76\u4e14\u6bcf\u4e2a\u952e\u90fd\u6709\u4e00\u4e2a\u72ec\u7acb\u7684\u503c\u7c7b\u578b\uff08\u201cstr\u201d\u4ee3\u8868\u201cname\u201d\uff0c\u201cint\u201d\u4ee3\u8868\u201cyear\u201d '` \u4e0a\u9762\uff09\u3002 \u6211\u4eec\u4e4b\u524d\u5df2\u7ecf\u770b\u5230\u8fc7\u201cdict[K, V]\u201d\u7c7b\u578b\uff0c\u5b83\u5141\u8bb8\u60a8\u58f0\u660e\u7edf\u4e00\u7684\u5b57\u5178\u7c7b\u578b\uff0c\u5176\u4e2d\u6bcf\u4e2a\u503c\u90fd\u5177\u6709\u76f8\u540c\u7684\u7c7b\u578b\uff0c\u5e76\u4e14\u652f\u6301\u4efb\u610f\u952e\u3002 \u8fd9\u663e\u7136\u4e0d\u592a\u9002\u5408\u4e0a\u9762\u7684\u201c\u7535\u5f71\u201d\u3002 \u76f8\u53cd\uff0c\u60a8\u53ef\u4ee5\u4f7f\u7528\u201cTypedDict\u201d\u4e3a\u201cmovie\u201d\u7b49\u5bf9\u8c61\u63d0\u4f9b\u7cbe\u786e\u7684\u7c7b\u578b\uff0c\u5176\u4e2d\u6bcf\u4e2a\u5b57\u5178\u503c\u7684\u7c7b\u578b\u53d6\u51b3\u4e8e\u952e\uff1a</p> <pre><code>from typing_extensions import TypedDict\n\nMovie = TypedDict('Movie', {'name': str, 'year': int})\n\nmovie: Movie = {'name': 'Blade Runner', 'year': 1982}\n</code></pre> <p><code>Movie</code> \u662f\u4e00\u4e2a <code>TypedDict</code> \u7c7b\u578b\uff0c\u5305\u542b\u4e24\u9879\uff1a<code>'name'</code>\uff08\u7c7b\u578b\u4e3a <code>str</code>\uff09\u548c <code>'year'</code>\uff08\u7c7b\u578b\u4e3a <code>int</code>\uff09\u3002 \u8bf7\u6ce8\u610f\uff0c\u6211\u4eec\u5bf9\u201cmovie\u201d\u53d8\u91cf\u4f7f\u7528\u4e86\u663e\u5f0f\u7c7b\u578b\u6ce8\u91ca\u3002 \u8fd9\u79cd\u7c7b\u578b\u6ce8\u91ca\u5f88\u91cd\u8981\u2014\u2014\u6ca1\u6709\u5b83\uff0cmypy \u5c06\u5c1d\u8bd5\u4e3a\u201cmovie\u201d\u63a8\u65ad\u51fa\u5e38\u89c4\u7684\u3001\u7edf\u4e00\u7684 <code>dict</code> \u7c7b\u578b \uff0c\u8fd9\u4e0d\u662f\u6211\u4eec\u60f3\u8981\u7684\u3002</p> <p>Note</p> <p>\u5982\u679c\u5c06 <code>TypedDict</code> \u5bf9\u8c61\u4f5c\u4e3a\u53c2\u6570\u4f20\u9012\u7ed9\u51fd\u6570\uff0c\u901a\u5e38\u4e0d\u9700\u8981\u7c7b\u578b\u6ce8\u91ca\uff0c\u56e0\u4e3a mypy \u53ef\u4ee5\u6839\u636e\u58f0\u660e\u7684\u53c2\u6570\u7c7b\u578b\u63a8\u65ad\u6240\u9700\u7684\u7c7b\u578b\u3002 \u53e6\u5916\uff0c\u5982\u679c\u4e4b\u524d\u5df2\u7ecf\u5b9a\u4e49\u4e86\u8d4b\u503c\u76ee\u6807\uff0c\u5e76\u4e14\u5b83\u5177\u6709 <code>TypedDict</code> \u7c7b\u578b\uff0c\u5219 mypy \u4f1a\u5c06\u5206\u914d\u7684\u503c\u89c6\u4e3a <code>TypedDict</code>\uff0c\u800c\u4e0d\u662f <code>dict</code>\u3002</p> <p>\u73b0\u5728 mypy \u4f1a\u8bc6\u522b\u8fd9\u4e9b\u662f\u6709\u6548\u7684\uff1a</p> <pre><code>name = movie['name']  # Okay; type of name is str\nyear = movie['year']  # Okay; type of year is int\n</code></pre> <p>Mypy \u4f1a\u5c06\u65e0\u6548\u5bc6\u94a5\u68c0\u6d4b\u4e3a\u9519\u8bef\uff1a</p> <pre><code>director = movie['director']  # Error: 'director' is not a valid key\n</code></pre> <p>Mypy \u8fd8\u5c06\u62d2\u7edd\u8fd0\u884c\u65f6\u8ba1\u7b97\u7684\u8868\u8fbe\u5f0f\u4f5c\u4e3a\u5bc6\u94a5\uff0c\u56e0\u4e3a\u5b83\u65e0\u6cd5\u9a8c\u8bc1\u5b83\u662f\u5426\u662f\u6709\u6548\u7684\u5bc6\u94a5\u3002 \u60a8\u53ea\u80fd\u4f7f\u7528\u5b57\u7b26\u4e32\u6587\u5b57\u4f5c\u4e3a\u201cTypedDict\u201d\u952e\u3002</p> <p><code>TypedDict</code> \u7c7b\u578b\u5bf9\u8c61\u4e5f\u53ef\u4ee5\u5145\u5f53\u6784\u9020\u51fd\u6570\u3002 \u5b83\u5728\u8fd0\u884c\u65f6\u8fd4\u56de\u4e00\u4e2a\u666e\u901a\u7684 <code>dict</code> \u5bf9\u8c61\u2014\u2014<code>TypedDict</code> \u4e0d\u5b9a\u4e49\u65b0\u7684\u8fd0\u884c\u65f6\u7c7b\u578b\uff1a</p> <pre><code>toy_story = Movie(name='Toy Story', year=1995)\n</code></pre> <p>\u8fd9\u76f8\u5f53\u4e8e\u76f4\u63a5\u4f7f\u7528 <code>{ ... }</code> \u6216 <code>dict(key=value, ...)</code> \u6784\u9020\u4e00\u4e2a\u5b57\u5178\u3002 \u6784\u9020\u51fd\u6570\u5f62\u5f0f\u6709\u65f6\u5f88\u65b9\u4fbf\uff0c\u56e0\u4e3a\u5b83\u53ef\u4ee5\u5728\u6ca1\u6709\u7c7b\u578b\u6ce8\u91ca\u7684\u60c5\u51b5\u4e0b\u4f7f\u7528\uff0c\u5e76\u4e14\u5b83\u8fd8\u4f7f\u5bf9\u8c61\u7684\u7c7b\u578b\u663e\u5f0f\u5316\u3002</p> <p>\u4e0e\u6240\u6709\u7c7b\u578b\u4e00\u6837\uff0c\u201cTypedDict\u201d\u53ef\u4ee5\u7528\u4f5c\u7ec4\u4ef6\u6765\u6784\u5efa\u4efb\u610f\u590d\u6742\u7684\u7c7b\u578b\u3002 \u4f8b\u5982\uff0c\u60a8\u53ef\u4ee5\u4f7f\u7528\u201cTypedDict\u201d\u9879\u5b9a\u4e49\u5d4c\u5957\u7684\u201cTypedDict\u201d\u548c\u5bb9\u5668\u3002 \u4e0e\u5927\u591a\u6570\u5176\u4ed6\u7c7b\u578b\u4e0d\u540c\uff0cmypy \u4f7f\u7528 TypedDict \u7684\u7ed3\u6784\u517c\u5bb9\u6027\u68c0\u67e5\uff08\u6216\u7ed3\u6784\u5b50\u7c7b\u578b\uff09\u3002 \u5047\u8bbe\u9879\u76ee\u7c7b\u578b\u517c\u5bb9\uff0c\u5177\u6709\u989d\u5916\u9879\u76ee\u7684\u201cTypedDict\u201d\u5bf9\u8c61\u4e0e\u8f83\u7a84\u7684\u201cTypedDict\u201d\uff08\u5b50\u7c7b\u578b\uff09\u517c\u5bb9\uff08totality\u4e5f\u4f1a\u5f71\u54cd\u5b50\u7c7b\u578b\uff0c\u5982\u4e0b\u6240\u8ff0\uff09\u3002</p> <p><code>TypedDict</code> \u5bf9\u8c61\u4e0d\u662f\u5e38\u89c4 <code>dict[...]</code> \u7c7b\u578b\u7684\u5b50\u7c7b\u578b\uff08\u53cd\u4e4b\u4ea6\u7136\uff09\uff0c\u56e0\u4e3a <code>dict</code> \u5141\u8bb8\u6dfb\u52a0\u548c\u5220\u9664\u4efb\u610f\u952e\uff0c\u4e0e\u201cTypedDict\u201d\u4e0d\u540c\u3002 \u7136\u800c\uff0c\u4efb\u4f55 <code>TypedDict</code> \u5bf9\u8c61\u90fd\u662f <code>Mapping[str, object]</code> \u7684\u5b50\u7c7b\u578b\uff08\u5373\u517c\u5bb9\uff09\uff0c\u56e0\u4e3a <code>Mapping</code> \u4ec5\u63d0\u4f9b\u5bf9\u5b57\u5178\u9879\u7684\u53ea\u8bfb\u8bbf\u95ee\uff1a</p> <pre><code>def print_typed_dict(obj: Mapping[str, object]) -&gt; None:\n    for key, value in obj.items():\n        print(f'{key}: {value}')\n\nprint_typed_dict(Movie(name='Toy Story', year=1995))  # OK\n</code></pre> <p>Note</p> <p>\u9664\u975e\u60a8\u4f7f\u7528\u7684\u662f Python 3.8 \u6216\u66f4\u9ad8\u7248\u672c\uff08\u5176\u4e2d\u6807\u51c6\u5e93 <code>typing</code> \u6a21\u5757\u4e2d\u63d0\u4f9b\u4e86 <code>TypedDict</code>\uff09\uff0c\u5426\u5219\u60a8\u9700\u8981\u4f7f\u7528 pip \u5b89\u88c5 <code>typing_extensions</code> \u4ee5\u4f7f\u7528 <code>TypedDict</code>\uff1a</p> <pre><code>python3 -m pip install --upgrade typing-extensions\n</code></pre> <p>Python programs often use dictionaries with string keys to represent objects. <code>TypedDict</code> lets you give precise types for dictionaries that represent objects with a fixed schema, such as <code>{'id': 1, 'items': ['x']}</code>.</p> <p>Here is a typical example:</p> <pre><code>movie = {'name': 'Blade Runner', 'year': 1982}\n</code></pre> <p>Only a fixed set of string keys is expected (<code>'name'</code> and <code>'year'</code> above), and each key has an independent value type (<code>str</code> for <code>'name'</code> and <code>int</code> for <code>'year'</code> above). We've previously seen the <code>dict[K, V]</code> type, which lets you declare uniform dictionary types, where every value has the same type, and arbitrary keys are supported. This is clearly not a good fit for <code>movie</code> above. Instead, you can use a <code>TypedDict</code> to give a precise type for objects like <code>movie</code>, where the type of each dictionary value depends on the key:</p> <pre><code>from typing_extensions import TypedDict\n\nMovie = TypedDict('Movie', {'name': str, 'year': int})\n\nmovie: Movie = {'name': 'Blade Runner', 'year': 1982}\n</code></pre> <p><code>Movie</code> is a <code>TypedDict</code> type with two items: <code>'name'</code> (with type <code>str</code>) and <code>'year'</code> (with type <code>int</code>). Note that we used an explicit type annotation for the <code>movie</code> variable. This type annotation is important -- without it, mypy will try to infer a regular, uniform <code>dict</code> type for <code>movie</code>, which is not what we want here.</p> <p>Note</p> <p>If you pass a <code>TypedDict</code> object as an argument to a function, no type annotation is usually necessary since mypy can infer the desired type based on the declared argument type. Also, if an assignment target has been previously defined, and it has a <code>TypedDict</code> type, mypy will treat the assigned value as a <code>TypedDict</code>, not <code>dict</code>.</p> <p>Now mypy will recognize these as valid:</p> <pre><code>name = movie['name']  # Okay; type of name is str\nyear = movie['year']  # Okay; type of year is int\n</code></pre> <p>Mypy will detect an invalid key as an error:</p> <pre><code>director = movie['director']  # Error: 'director' is not a valid key\n</code></pre> <p>Mypy will also reject a runtime-computed expression as a key, as it can't verify that it's a valid key. You can only use string literals as <code>TypedDict</code> keys.</p> <p>The <code>TypedDict</code> type object can also act as a constructor. It returns a normal <code>dict</code> object at runtime -- a <code>TypedDict</code> does not define a new runtime type:</p> <pre><code>toy_story = Movie(name='Toy Story', year=1995)\n</code></pre> <p>This is equivalent to just constructing a dictionary directly using <code>{ ... }</code> or <code>dict(key=value, ...)</code>. The constructor form is sometimes convenient, since it can be used without a type annotation, and it also makes the type of the object explicit.</p> <p>Like all types, <code>TypedDict</code>s can be used as components to build arbitrarily complex types. For example, you can define nested <code>TypedDict</code>s and containers with <code>TypedDict</code> items. Unlike most other types, mypy uses structural compatibility checking (or structural subtyping) with <code>TypedDict</code>s. A <code>TypedDict</code> object with extra items is compatible with (a subtype of) a narrower <code>TypedDict</code>, assuming item types are compatible (totality also affects subtyping, as discussed below).</p> <p>A <code>TypedDict</code> object is not a subtype of the regular <code>dict[...]</code> type (and vice versa), since <code>dict</code> allows arbitrary keys to be added and removed, unlike <code>TypedDict</code>. However, any <code>TypedDict</code> object is a subtype of (that is, compatible with) <code>Mapping[str, object]</code>, since <code>Mapping</code> only provides read-only access to the dictionary items:</p> <pre><code>def print_typed_dict(obj: Mapping[str, object]) -&gt; None:\n    for key, value in obj.items():\n        print(f'{key}: {value}')\n\nprint_typed_dict(Movie(name='Toy Story', year=1995))  # OK\n</code></pre> <p>Note</p> <p>Unless you are on Python 3.8 or newer (where <code>TypedDict</code> is available in standard library <code>typing</code> module) you need to install <code>typing_extensions</code> using pip to use <code>TypedDict</code>:</p> <pre><code>python3 -m pip install --upgrade typing-extensions\n</code></pre>"},{"location":"mypy/typeddict/#\u6574\u4f53\u6027","title":"\u6574\u4f53\u6027","text":"<p>Totality</p> \u4e2d\u6587\u82f1\u6587 <p>\u9ed8\u8ba4\u60c5\u51b5\u4e0b\uff0cmypy \u786e\u4fdd\u201cTypedDict\u201d\u5bf9\u8c61\u5177\u6709\u6240\u6709\u6307\u5b9a\u7684\u952e\u3002 \u8fd9\u5c06\u88ab\u6807\u8bb0\u4e3a\u9519\u8bef\uff1a</p> <pre><code># Error: 'year' missing\ntoy_story: Movie = {'name': 'Toy Story'}\n</code></pre> <p>\u6709\u65f6\u60a8\u5e0c\u671b\u5728\u521b\u5efa\u201cTypedDict\u201d\u5bf9\u8c61\u65f6\u5141\u8bb8\u7701\u7565\u952e\u3002 \u60a8\u53ef\u4ee5\u5411\u201cTypedDict(...)\u201d\u63d0\u4f9b\u201ctotal=False\u201d\u53c2\u6570\u6765\u5b9e\u73b0\u6b64\u76ee\u7684\uff1a</p> <pre><code>GuiOptions = TypedDict(\n    'GuiOptions', {'language': str, 'color': str}, total=False)\noptions: GuiOptions = {}  # Okay\noptions['language'] = 'en'\n</code></pre> <p>\u60a8\u53ef\u80fd\u9700\u8981\u4f7f\u7528 <code>dict.get</code> \u6765\u8bbf\u95ee\u90e8\u5206\uff08\u975e\u5168\u90e8\uff09<code>TypedDict</code> \u7684\u9879\u76ee\uff0c \u56e0\u4e3a\u4f7f\u7528 <code>[]</code> \u8fdb\u884c\u7d22\u5f15\u53ef\u80fd\u4f1a\u5728\u8fd0\u884c\u65f6\u5931\u8d25\u3002 \u7136\u800c\uff0cmypy \u4ecd\u7136\u5141\u8bb8\u4f7f\u7528\u5e26\u6709\u90e8\u5206 <code>TypedDict</code> \u7684 <code>[]</code> \u2014\u2014\u4f60\u53ea\u9700\u8981\u5c0f\u5fc3\u5b83\uff0c\u56e0\u4e3a\u5b83\u53ef\u80fd\u4f1a\u5bfc\u81f4 <code>KeyError</code>\u3002 \u5230\u5904\u90fd\u9700\u8981 <code>dict.get</code> \u592a\u9ebb\u70e6\u4e86\u3002 \uff08\u8bf7\u6ce8\u610f\uff0c\u60a8\u4e5f\u53ef\u4ee5\u81ea\u7531\u4f7f\u7528 <code>dict.get</code> \u4ee5\u53ca\u6240\u6709 <code>TypedDict</code>\u3002\uff09</p> <p>\u4e0d\u9700\u8981\u7684\u952e\u5728\u9519\u8bef\u6d88\u606f\u4e2d\u663e\u793a\u4e3a\u201c\uff1f\u201d\uff1a</p> <pre><code># Revealed type is \"TypedDict('GuiOptions', {'language'?: builtins.str,\n#                                            'color'?: builtins.str})\"\nreveal_type(options)\n</code></pre> <p>\u6574\u4f53\u6027\u4e5f\u4f1a\u5f71\u54cd\u7ed3\u6784\u517c\u5bb9\u6027\u3002 \u5f53\u9700\u8981\u5b8c\u6574\u7684\u201cTypedDict\u201d\u65f6\uff0c\u60a8\u4e0d\u80fd\u4f7f\u7528\u90e8\u5206\u201cTypedDict\u201d\u3002 \u6b64\u5916\uff0c\u5f53\u9700\u8981\u90e8\u5206\u201cTypedDict\u201d\u65f6\uff0c\u6574\u4e2a\u201cTypedDict\u201d\u65e0\u6548\u3002</p> <p>By default mypy ensures that a <code>TypedDict</code> object has all the specified keys. This will be flagged as an error:</p> <pre><code># Error: 'year' missing\ntoy_story: Movie = {'name': 'Toy Story'}\n</code></pre> <p>Sometimes you want to allow keys to be left out when creating a <code>TypedDict</code> object. You can provide the <code>total=False</code> argument to <code>TypedDict(...)</code> to achieve this:</p> <pre><code>GuiOptions = TypedDict(\n    'GuiOptions', {'language': str, 'color': str}, total=False)\noptions: GuiOptions = {}  # Okay\noptions['language'] = 'en'\n</code></pre> <p>You may need to use <code>dict.get</code> to access items of a partial (non-total) <code>TypedDict</code>, since indexing using <code>[]</code> could fail at runtime. However, mypy still lets use <code>[]</code> with a partial <code>TypedDict</code> -- you just need to be careful with it, as it could result in a <code>KeyError</code>. Requiring <code>dict.get</code> everywhere would be too cumbersome. (Note that you are free to use <code>dict.get</code> with total <code>TypedDict</code>s as well.)</p> <p>Keys that aren't required are shown with a <code>?</code> in error messages:</p> <pre><code># Revealed type is \"TypedDict('GuiOptions', {'language'?: builtins.str,\n#                                            'color'?: builtins.str})\"\nreveal_type(options)\n</code></pre> <p>Totality also affects structural compatibility. You can't use a partial <code>TypedDict</code> when a total one is expected. Also, a total <code>TypedDict</code> is not valid when a partial one is expected.</p>"},{"location":"mypy/typeddict/#\u652f\u6301\u7684\u64cd\u4f5c","title":"\u652f\u6301\u7684\u64cd\u4f5c","text":"<p>Supported operations</p> \u4e2d\u6587\u82f1\u6587 <p><code>TypedDict</code> \u5bf9\u8c61\u652f\u6301\u5b57\u5178\u64cd\u4f5c\u548c\u65b9\u6cd5\u7684\u5b50\u96c6\u3002 \u8c03\u7528\u5927\u591a\u6570\u65b9\u6cd5\u65f6\u5fc5\u987b\u4f7f\u7528\u5b57\u7b26\u4e32\u6587\u5b57\u4f5c\u4e3a\u952e\uff0c\u5426\u5219 mypy \u5c06\u65e0\u6cd5\u68c0\u67e5\u8be5\u952e\u662f\u5426\u6709\u6548\u3002 \u652f\u6301\u7684\u64cd\u4f5c\u5217\u8868\uff1a</p> <ul> <li> <p><code>typing.Mapping</code>\u4e2d\u5305\u542b\u7684\u4efb\u4f55\u5185\u5bb9:</p> </li> <li> <p><code>d[key]</code></p> </li> <li><code>key in d</code></li> <li><code>len(d)</code></li> <li><code>for key in d</code> (iteration)</li> <li><code>d.get(key[, default])</code></li> <li><code>d.keys()</code></li> <li><code>d.values()</code></li> <li> <p><code>d.items()</code></p> </li> <li> <p><code>d.copy()</code></p> </li> <li><code>d.setdefault(key, default)</code></li> <li><code>d1.update(d2)</code></li> <li><code>d.pop(key[, default])</code> (partial <code>TypedDict</code>s only)</li> <li><code>del d[key]</code> (partial <code>TypedDict</code>s only)</li> </ul> <p>Note</p> <p><code>dict.clear</code> \u548c <code>dict.popitem</code> \u4e0d\u652f\u6301\uff0c\u56e0\u4e3a\u5b83\u4eec\u4e0d\u5b89\u5168\u2014\u2014\u5b83\u4eec\u53ef\u4ee5\u5220\u9664\u7531\u4e8e\u7ed3\u6784\u5b50\u7c7b\u578b\u800c\u5bf9 mypy \u4e0d\u53ef\u89c1\u7684\u5fc5\u9700\u7684\u201cTypedDict\u201d\u9879\u3002</p> <p><code>TypedDict</code> objects support a subset of dictionary operations and methods. You must use string literals as keys when calling most of the methods, as otherwise mypy won't be able to check that the key is valid. List of supported operations:</p> <ul> <li> <p>Anything included in <code>typing.Mapping</code>:</p> </li> <li> <p><code>d[key]</code></p> </li> <li><code>key in d</code></li> <li><code>len(d)</code></li> <li><code>for key in d</code> (iteration)</li> <li><code>d.get(key[, default])</code></li> <li><code>d.keys()</code></li> <li><code>d.values()</code></li> <li> <p><code>d.items()</code></p> </li> <li> <p><code>d.copy()</code></p> </li> <li><code>d.setdefault(key, default)</code></li> <li><code>d1.update(d2)</code></li> <li><code>d.pop(key[, default])</code> (partial <code>TypedDict</code>s only)</li> <li><code>del d[key]</code> (partial <code>TypedDict</code>s only)</li> </ul> <p>Note</p> <p><code>dict.clear</code> and <code>dict.popitem</code> are not supported since they are unsafe -- they could delete required <code>TypedDict</code> items that are not visible to mypy because of structural subtyping.</p>"},{"location":"mypy/typeddict/#\u57fa\u4e8e\u7c7b\u7684\u8bed\u6cd5","title":"\u57fa\u4e8e\u7c7b\u7684\u8bed\u6cd5","text":"<p>Class-based syntax</p> \u4e2d\u6587\u82f1\u6587 <p>Python 3.6 \u53ca\u66f4\u9ad8\u7248\u672c\u652f\u6301\u53e6\u4e00\u79cd\u57fa\u4e8e\u7c7b\u7684\u8bed\u6cd5\u6765\u5b9a\u4e49\u201cTypedDict\u201d\uff1a</p> <pre><code>from typing_extensions import TypedDict\n\nclass Movie(TypedDict):\n    name: str\n    year: int\n</code></pre> <p>\u4e0a\u9762\u7684\u5b9a\u4e49\u76f8\u5f53\u4e8e\u539f\u6765\u7684\u201cMovie\u201d\u5b9a\u4e49\u3002 \u5b83\u5b9e\u9645\u4e0a\u5e76\u6ca1\u6709\u5b9a\u4e49\u771f\u6b63\u7684\u7c7b\u3002 \u6b64\u8bed\u6cd5\u8fd8\u652f\u6301\u4e00\u79cd\u7ee7\u627f\u5f62\u5f0f\u2014\u2014\u5b50\u7c7b\u53ef\u4ee5\u5b9a\u4e49\u9644\u52a0\u9879\u3002 \u7136\u800c\uff0c\u8fd9\u4e3b\u8981\u662f\u4e00\u79cd\u7b26\u53f7\u5feb\u6377\u65b9\u5f0f\u3002 \u7531\u4e8e mypy \u4f7f\u7528\u4e0e TypedDict \u7684\u7ed3\u6784\u517c\u5bb9\u6027\uff0c\u56e0\u6b64\u4e0d\u9700\u8981\u7ee7\u627f\u6765\u5b9e\u73b0\u517c\u5bb9\u6027\u3002 \u4e0b\u9762\u662f\u4e00\u4e2a\u7ee7\u627f\u7684\u4f8b\u5b50\uff1a</p> <pre><code>class Movie(TypedDict):\n    name: str\n    year: int\n\nclass BookBasedMovie(Movie):\n    based_on: str\n</code></pre> <p>\u73b0\u5728\u201cBookBasedMovie\u201d\u6709\u952e\u201cname\u201d\u3001\u201cyear\u201d\u548c\u201cbased_on\u201d\u3002</p> <p>An alternative, class-based syntax to define a <code>TypedDict</code> is supported in Python 3.6 and later:</p> <pre><code>from typing_extensions import TypedDict\n\nclass Movie(TypedDict):\n    name: str\n    year: int\n</code></pre> <p>The above definition is equivalent to the original <code>Movie</code> definition. It doesn't actually define a real class. This syntax also supports a form of inheritance -- subclasses can define additional items. However, this is primarily a notational shortcut. Since mypy uses structural compatibility with <code>TypedDict</code>s, inheritance is not required for compatibility. Here is an example of inheritance:</p> <pre><code>class Movie(TypedDict):\n    name: str\n    year: int\n\nclass BookBasedMovie(Movie):\n    based_on: str\n</code></pre> <p>Now <code>BookBasedMovie</code> has keys <code>name</code>, <code>year</code> and <code>based_on</code>.</p>"},{"location":"mypy/typeddict/#\u6df7\u5408\u5fc5\u9700\u548c\u975e\u5fc5\u9700\u7684\u9879\u76ee","title":"\u6df7\u5408\u5fc5\u9700\u548c\u975e\u5fc5\u9700\u7684\u9879\u76ee","text":"<p>Mixing required and non-required items</p> \u4e2d\u6587\u82f1\u6587 <p>\u9664\u4e86\u5141\u8bb8\u8de8\u201cTypedDict\u201d\u7c7b\u578b\u91cd\u7528\u4e4b\u5916\uff0c\u7ee7\u627f\u8fd8\u5141\u8bb8\u60a8\u5728\u5355\u4e2a\u201cTypedDict\u201d\u4e2d\u6df7\u5408\u5fc5\u9700\u548c\u975e\u5fc5\u9700\uff08\u4f7f\u7528\u201ctotal=False\u201d\uff09\u9879\u3002 \u4f8b\u5b50\uff1a</p> <pre><code>class MovieBase(TypedDict):\n    name: str\n    year: int\n\nclass Movie(MovieBase, total=False):\n    based_on: str\n</code></pre> <p>\u73b0\u5728\u201cMovie\u201d\u9700\u8981\u952e\u201cname\u201d\u548c\u201cyear\u201d\uff0c\u800c\u201cbased_on\u201d\u5728\u6784\u9020\u5bf9\u8c61\u65f6\u53ef\u4ee5\u7701\u7565\u3002 \u6df7\u5408\u4e86\u5fc5\u9700\u548c\u975e\u5fc5\u9700\u952e\u7684\u201cTypedDict\u201d\uff08\u4f8b\u5982\u4e0a\u9762\u7684\u201cMovie\u201d\uff09\u4ec5\u5f53\u5176\u4ed6\u201cTypedDict\u201d\u4e2d\u7684\u6240\u6709\u5fc5\u9700\u952e\u90fd\u662f\u7b2c\u4e00\u4e2a\u201cTypedDict\u201d\u4e2d\u7684\u5fc5\u9700\u952e\u65f6\u624d\u4e0e\u53e6\u4e00\u4e2a\u201cTypedDict\u201d\u517c\u5bb9 \uff0c\u5e76\u4e14\u5176\u4ed6\u201cTypedDict\u201d\u7684\u6240\u6709\u975e\u5fc5\u9700\u952e\u4e5f\u662f\u7b2c\u4e00\u4e2a\u201cTypedDict\u201d\u4e2d\u7684\u975e\u5fc5\u9700\u952e\u3002</p> <p>In addition to allowing reuse across <code>TypedDict</code> types, inheritance also allows you to mix required and non-required (using <code>total=False</code>) items in a single <code>TypedDict</code>. Example:</p> <pre><code>class MovieBase(TypedDict):\n    name: str\n    year: int\n\nclass Movie(MovieBase, total=False):\n    based_on: str\n</code></pre> <p>Now <code>Movie</code> has required keys <code>name</code> and <code>year</code>, while <code>based_on</code> can be left out when constructing an object. A <code>TypedDict</code> with a mix of required and non-required keys, such as <code>Movie</code> above, will only be compatible with another <code>TypedDict</code> if all required keys in the other <code>TypedDict</code> are required keys in the first <code>TypedDict</code>, and all non-required keys of the other <code>TypedDict</code> are also non-required keys in the first <code>TypedDict</code>.</p>"},{"location":"mypy/typeddict/#typeddict-\u7684\u8054\u5408","title":"TypedDict \u7684\u8054\u5408","text":"<p>Unions of TypedDicts</p> \u4e2d\u6587\u82f1\u6587 <p>\u7531\u4e8e TypedDict \u5728\u8fd0\u884c\u65f6\u5b9e\u9645\u4e0a\u53ea\u662f\u5e38\u89c4\u5b57\u5178\uff0c\u56e0\u6b64\u4e0d\u53ef\u80fd\u4f7f\u7528\u201cisinstance\u201d\u68c0\u67e5\u6765\u533a\u5206 TypedDict Union \u7684\u4e0d\u540c\u53d8\u4f53\uff0c\u5c31\u50cf\u5904\u7406\u5e38\u89c4\u5bf9\u8c61\u4e00\u6837\u3002</p> <p>\u76f8\u53cd\uff0c\u60a8\u53ef\u4ee5\u4f7f\u7528<code>\u6807\u8bb0\u8054\u5408\u6a21\u5f0f</code>\u3002 \u6587\u6863\u7684\u5f15\u7528\u90e8\u5206\u6709\u5b8c\u6574\u7684\u63cf\u8ff0\u548c\u793a\u4f8b\uff0c\u4f46\u7b80\u800c\u8a00\u4e4b\uff0c\u60a8\u9700\u8981\u4e3a\u6bcf\u4e2a TypedDict \u63d0\u4f9b\u76f8\u540c\u7684\u952e\uff0c\u5176\u4e2d\u6bcf\u4e2a\u503c\u90fd\u6709\u552f\u4e00\u7684 <code>Literal type</code>\u3002 \u7136\u540e\uff0c\u68c0\u67e5\u8be5\u952e\u4ee5\u533a\u5206\u60a8\u7684 TypedDict\u3002</p> <p>Since TypedDicts are really just regular dicts at runtime, it is not possible to use <code>isinstance</code> checks to distinguish between different variants of a Union of TypedDict in the same way you can with regular objects.</p> <p>Instead, you can use the <code>tagged union pattern</code>. The referenced section of the docs has a full description with an example, but in short, you will need to give each TypedDict the same key where each value has a unique <code>Literal type</code>. Then, check that key to distinguish between your TypedDicts.</p>"},{"location":"mypy_conf/","title":"\u914d\u7f6e\u548c\u8fd0\u884cmypy","text":"<p>\u6682\u6ca1\u6709\u65f6\u95f4\u6c49\u5316\uff0c\u770b\u539f\u6587...</p>"},{"location":"mypy_other/","title":"\u5176\u4ed6\u6742\u9879","text":"<p>\u6682\u6ca1\u6709\u65f6\u95f4\u6c49\u5316\uff0c\u770b\u539f\u6587...</p>"}]}